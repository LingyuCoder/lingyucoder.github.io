<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>天镶的博客</title>
    <link>http://lingyu.life/</link>
    
    <image>
      <url>http://lingyu.life/img/favicon-32x32.png</url>
      <title>天镶的博客</title>
      <link>http://lingyu.life/</link>
    </image>
    
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 07 Mar 2020 15:17:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>用React做重构时的一些思考</title>
      <link>https://lingyu.life/#/post/2015/08/30/chonggou</link>
      <guid>https://lingyu.life/#/post/2015/08/30/chonggou</guid>
      <pubDate>Sat, 29 Aug 2015 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;好久没写东西了，主要是工作比以前学生时代忙多了，周末也是各种加班充电，沉淀的少了。最近一直在用React对手上的老业务做重构，这里写一下重构中的一些感悟和思考&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>好久没写东西了，主要是工作比以前学生时代忙多了，周末也是各种加班充电，沉淀的少了。最近一直在用React对手上的老业务做重构，这里写一下重构中的一些感悟和思考</p><a id="more"></a><h2 id="老业务和老代码"><a href="#老业务和老代码" class="headerlink" title="老业务和老代码"></a>老业务和老代码</h2><h3 id="前台和后台"><a href="#前台和后台" class="headerlink" title="前台和后台"></a>前台和后台</h3><p>入职之后刚开始接手的是前台展示业务，基本上是在已有的框架上写模块，前台业务尤其是活动期间光完成业务就累得半死。</p><p>后来随着一次业务调整，开始负责商家后台业务了，两边节奏和开发方式都完全不同。前台业务更新换代较快，没事就改个版啥的，后台就完全不同了：</p><ol><li>后台的业务偏重的是功能，与前台业务酷炫的交互不同，后台业务往往是数据的直观展示和CRUD操作</li><li>前台业务往往可以根据展示的区域划分为多个模块，模块较为独立，很少有模块之间的通信。而后台业务往往是多个子功能模块通过复杂的业务逻辑串联到一起形成完整的功能</li></ol><h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>目前负责的应用应该是整个天猫最复杂的应用，里面都是一些老旧的代码，有很重的历史包袱。模块之间的划分不清晰，模块之间的耦合也比较严重，对DOM的交叉修改，不必要的依赖各种各样。进来后思考的最多的就是对这块老代码做重构。</p><p>当然老业务只是代码老，并不代表没有新需求，所以对于接手老代码的开发者来说，最重要的一点是：</p><blockquote><p>老坑没填的情况下，首先保证不会挖新坑，不要明知道之前的开发者使用了错误的开发方式，还不负责任的继续使用。历史问题会随着技术的发展和时间的推移而像滚雪球一样越滚越大，如果放任其滚下去很可能最后整个应用完全不可维护</p></blockquote><p>目前负责老业务并不是单纯的老到只需要维护就可以了，事实上还有大量的新需求不断加入当中，它们就是滚雪球时不断粘附到雪球上的雪</p><ul><li>对于与老代码之间耦合不是特别强烈的新需求，采用较为独立的模块化开发方式，以一种可插拔的形式嵌入到老业务中，保证插和拔的时候不会影响老业务正常运作</li><li>在老业务原有的代码上做更改，这是熟悉老业务代码的最佳方式，理清楚要修改的老业务代码逻辑，若涉及的模块和其他模块耦合程度较低，就将其抽离。如果耦合程度较高，就采用对现有架构尽可能小影响的开发方式开发</li><li>解耦的过程就像剥洋葱，剥离了最外面一层，里面一层就变成最外一层了，一层层剥到核心，整个解耦过程就完成了</li></ul><h2 id="老业务中的React"><a href="#老业务中的React" class="headerlink" title="老业务中的React"></a>老业务中的React</h2><p>在整个解耦的过程中，采用React做解耦。目前比较流行的React开发方式是采用Common JS开发，模块直接通过npm管理，上线时采用webpack或browserify做打包。但受限于身上的历史包袱，不可能整页采用React实现，成本太大。目前整体页面依旧是普通JS，通过模块加载器管理着各个模块，其中一些模块是React实现的，利用browserify的babelify+babel-runtime做ES 6语法编译，保证即使ES 6语法编写的代码也能够正常跑在浏览器上，由于每个模块是独立的，因此这样会产生一些问题，后面会讲到</p><h3 id="React做模块"><a href="#React做模块" class="headerlink" title="React做模块"></a>React做模块</h3><p>为什么要用 React 做解耦，主要是看中其封装理念，一个模块或组件，应当有：</p><ol><li>提供一些配置数据</li><li>模块自己内部逻辑用的数据</li><li>提供一些供交互的接口和事件</li></ol><h4 id="兼容JSX和原生JS调用"><a href="#兼容JSX和原生JS调用" class="headerlink" title="兼容JSX和原生JS调用"></a>兼容JSX和原生JS调用</h4><p>1，2，3分别对应props、state和onXXX回调。对于老业务而言，如果外层不是React，而是模块加载器包裹的原生JS怎么办呢？其实React组件完全可以独立运行，毕竟有<code>React.render</code>，举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'react'</span>, <span class="string">'event-mixin'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">React, EventMixin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defaultConfig = &#123;</span><br><span class="line">    value: <span class="string">''</span>,</span><br><span class="line">    onChange: noop</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> Component = React.createClass(&#123;</span><br><span class="line">    mixins: [EventMixin],</span><br><span class="line">    propTypes: &#123;&#125;,</span><br><span class="line">    getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> defaultConfig;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    setValue: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Component.init = <span class="function"><span class="keyword">function</span>(<span class="params">container, config</span>) </span>&#123;</span><br><span class="line">    config = S.merge(&#123;&#125;, defaultConfig, config);</span><br><span class="line">    <span class="keyword">return</span> React.render(<span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...config</span>&#125;/&gt;</span></span>, container);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Component;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，返回一个React类，这个类提供了静态方法用于在容器中直接绘制组件，方便原生JS，而JSX中也可以直接使用标签的方式使用组件</p><p>对于上面说的三点：</p><ol><li>配置数据props的传入：原生JS采用init方法传入，JSX直接写在标签上</li><li>内部数据state组件维护</li><li>组件的方法和事件，对于原生JS提供了getValue、setValue这样的方法，而对于JSX使用则直接可以通过配置传入。对于事件的处理采用了混入Event模型的方式，为组件自身提供了on、off、fire这种事件模型方法供原生JS使用，而对于JSX的调用方式，则直接使用onXXX风格的回调即可</li></ol><p>这样组件就可以兼容外层是JSX或外层是JS的调用方式，同时兼容新业务和老业务</p><h4 id="组件独立性"><a href="#组件独立性" class="headerlink" title="组件独立性"></a>组件独立性</h4><p>同时，一个组件应当保证对应的独立性：</p><ol><li>样式的独立</li><li>DOM的独立</li><li>组件逻辑的独立</li></ol><p>个人认为一个组件应该standalone就能跑起来的，React非常好的提供了DOM的独立和组件逻辑的独立，采用inline-style的方式也能提供样式的独立。其中DOM的独立非常重要，一旦多个组件DOM形成耦合，这几个组件的解耦将异常困难。React组件的每个DOM元素都分配了自己的id，一旦修改就会发生错误，强制了DOM的独立。</p><p>这样组件就只关注自己了，那么问题就来了，组件都只关注自己，组件之间交互怎么办？所以有Flux</p><h4 id="模块间通信"><a href="#模块间通信" class="headerlink" title="模块间通信"></a>模块间通信</h4><p>React解决了组件实现，组件间通信就交给了Flux的模式，Flux是一种数据通信模式，其实说简单点就是全局有一些保存数据的Store，各个React组件相互之间通信不是直接通信，而是通过这些保存数据的Store，一个组件修改Store递交数据，另外一个组件监听Store的变化获得数据来实现数据的传输。不过数据传输是单向的</p><p>以往组件之间的耦合是因为一个组件直接调用了另外一个组件的接口，现在大家都不依赖接口了，直接依赖数据，从主动调用变成了被动通知变更</p><p>这里有几个点：</p><ol><li>一个数据需求模块初始化后，一直在监听数据变化，但变更数据的模块可能根本就不存在，这个数据需求模块就蛋疼了，其实当不存在数据变更模块的时候，这个数据需求模块是不应该被初始化的</li><li>由于数据需求模块只在乎数据，给他的数据长啥样，它就长啥样，多个模块共同修改同一份数据时，永远是最新的数据决定了模块的展示，数据需求模块本身必须是无状态的，因为它没办法保证它所依赖的多份数据的递交顺序</li><li>数据需求模块依赖的数据结构是定死的， 变更数据的模块吐出来的数据结果也是定死的，这就产生一个问题，这两个定死的数据结构需要做适配，每个模块只关注自身，当然不应该考虑为其他模块做数据适配。所以这个适配就得在Flux上做，需要尽可能的通过定义开发规范来减少数据适配的出现</li><li>需要immutable保证数据本身的独立性，防止交叉修改同一份数据导致数据污染</li><li>数据都是整块递交，需要DOM Diff这样的方式来保证重绘范围尽可能小</li></ol><h3 id="Webpack和Browserify"><a href="#Webpack和Browserify" class="headerlink" title="Webpack和Browserify"></a>Webpack和Browserify</h3><p>这俩的运行机制大体上来说就是分析Common JS代码的AST语法树，找到其中的require指定的依赖名称，然后递归的分析依赖，最后将所有的依赖打包在一起，并配合打包工具自己的模块加载机制复写或替换require实现加载。采用这种方式，组件的安装和使用变得和Common JS一样简单，不用考虑组件的版本管理，因为组件在node_modules里面都有对应版本的源码。</p><p>但这种方式容易产生性能问题：</p><ol><li>不少Common JS的模块都有自己依赖的工具包，这些工具包的版本通常并不相同，这也就导致了重复打包的问题</li><li>Common JS的模块开发方式使得不少开发者没有在意自己使用的包的大小或内容，往往会为了几个很小的功能而引入一个完整的工具库，这在Node.Js上没什么，但是到了浏览器端，就成了大问题</li><li>很多模块没有采用异步加载依赖的方式，而是直接require同步加载依赖，导致打包出来的入口文件巨大无比…首屏很慢</li><li>ES 6的打包碎片问题，如果整页打包当然不存在碎片的问题。但是对于多个模块分开打包，就很导致每个模块自己独立打包，会生成自己的一些编译依赖，而通过模块加载器一起使用时，由于模块相互之间独立，这些依赖虽然有很多是相同的，但也会被引入很多次。目前没有什么好的解决办法，就是减少碎片生成。</li><li>React组件对于子组件的引入都是同步的，如果整页都是React开发就很容易遇到3中的问题</li></ol><p>对于一些新业务，用打包工具整页打包还是可行的，但是一定要注意处理好异步加载的模块，同时保证依赖本身的轻量。而对于老业务，则需要减少独立打包时产生的碎片。不管什么开发方式，都需要注意1，2的情况，个人比较倾向的方式就是，最外层依旧采用现有的AMD模块管理方式，而部分模块采用React开发，防止出现5和3的问题，但4的问题就得通过定义开发规范的方式来规避了</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这里随便写一点，可能个人对于React和打包技术的理解有误导致观点不符。其实还是一点，不同的业务场景有自身的技术取舍，能解决问题的技术就是好技术。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/">前端综合</category>
      
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/React/">React</category>
      
      
      <comments>http://lingyu.life/2015/08/30/chonggou/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>轻松入门React和Webpack</title>
      <link>https://lingyu.life/#/post/2015/05/15/react-and-webpack</link>
      <guid>https://lingyu.life/#/post/2015/05/15/react-and-webpack</guid>
      <pubDate>Thu, 14 May 2015 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近在学习React.js，之前都是直接用最原生的方式去写React代码，发现组织起来特别麻烦，之前听人说用Webpack组织React组件得心应手，就花了点时间学习了一下，收获颇丰&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近在学习React.js，之前都是直接用最原生的方式去写React代码，发现组织起来特别麻烦，之前听人说用Webpack组织React组件得心应手，就花了点时间学习了一下，收获颇丰</p><a id="more"></a><h2 id="说说React"><a href="#说说React" class="headerlink" title="说说React"></a>说说React</h2><p>一个组件，有自己的结构，有自己的逻辑，有自己的样式，会依赖一些资源，会依赖某些其他组件。比如日常写一个组件，比较常规的方式：</p><p>－ 通过前端模板引擎定义结构<br>－ JS文件中写自己的逻辑<br>－ CSS中写组件的样式<br>－ 通过RequireJS、SeaJS这样的库来解决模块之间的相互依赖，<br>那么在React中是什么样子呢？</p><h3 id="结构和逻辑"><a href="#结构和逻辑" class="headerlink" title="结构和逻辑"></a>结构和逻辑</h3><p>在React的世界里，结构和逻辑交由JSX文件组织，React将模板内嵌到逻辑内部，实现了一个JS代码和HTML混合的JSX。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>在JSX文件中，可以直接通过<code>React.createClass</code>来定义组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CustomComponent = React.creatClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"custom-component"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这种方式可以很方便的定义一个组件，组件的结构定义在render函数中，但这并不是简单的模板引擎，我们可以通过js方便、直观的操控组件结构，比如我想给组件增加几个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CustomComponent = React.creatClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $nodes = [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;str&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"custom-component"</span>&gt;</span>&#123;$nodes&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这种方式，React使得组件拥有灵活的结构。那么React又是如何处理逻辑的呢？</p><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>写过前端组件的人都知道，组件通常首先需要相应自身DOM事件，做一些处理。必要时候还需要暴露一些外部接口，那么React组件要怎么做到这两点呢？</p><h5 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h5><p>比如我有个按钮组件，点击之后需要做一些处理逻辑，那么React组件大致上长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击按钮应当触发相应地逻辑，一种比较直观的方式就是给button绑定一个<code>onclick</code>事件，里面就是需要执行的逻辑了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDragonKillingSword</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//送宝刀</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getDragonKillingSword()"</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但事实上<code>getDragonKillingSword()</code>的逻辑属于组件内部行为，显然应当包装在组件内部，于是在React中就可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    getDragonKillingSword: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//送宝刀</span></span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就实现内部事件的响应了，那如果需要暴露接口怎么办呢？</p><h5 id="暴露接口"><a href="#暴露接口" class="headerlink" title="暴露接口"></a>暴露接口</h5><p>事实上现在<code>getDragonKillingSword</code>已经是一个接口了，如果有一个父组件，想要调用这个接口怎么办呢？</p><p>父组件大概长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ImDaddyComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                <span class="comment">//其他组件</span></span><br><span class="line">                &lt;ButtonComponent /&gt;</span><br><span class="line">                <span class="comment">//其他组件</span></span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p>那么如果想手动调用组件的方法，首先在ButtonComponent上设置一个<code>ref=&quot;&quot;</code>属性来标记一下，比如这里把子组件设置成<code>&lt;ButtonComponent ref=&quot;getSwordButton&quot;/&gt;</code>，那么在父组件的逻辑里，就可以在父组件自己的方法中通过这种方式来调用接口方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.refs.getSwordButton.getDragonKillingSword();</span><br></pre></td></tr></table></figure><p>看起来屌屌哒~那么问题又来了，父组件希望自己能够按钮点击时调用的方法，那该怎么办呢？</p><h5 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h5><p>父组件可以直接将需要执行的函数传递给子组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ButtonComponent clickCallback=&#123;<span class="keyword">this</span>.getSwordButtonClickCallback&#125;/&gt;</span><br></pre></td></tr></table></figure><p>然后在子组件中调用父组件方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.clickCallback&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子组件通过<code>this.props</code>能够获取在父组件创建子组件时传入的任何参数，因此<code>this.props</code>也常被当做配置参数来使用</p><p>屠龙宝刀每个人只能领取一把，按钮点击一下就应该灰掉，应当在子组件中增加一个是否点击过的状态，这又应当处理呢？</p><h5 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h5><p>在React中，每个组件都有自己的状态，可以在自身的方法中通过<code>this.state</code>取到，而初始状态则通过<code>getInitialState()</code>方法来定义，比如这个屠龙宝刀按钮组件，它的初始状态应该是没有点击过，所以<code>getInitialState</code>方法里面应当定义初始状态<code>clicked: false</code>。而在点击执行的方法中，应当修改这个状态值为<code>click: true</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//确定初始状态</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            clicked: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    getDragonKillingSword: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//送宝刀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改点击状态</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            clicked: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样点击状态的维护就完成了，那么render函数中也应当根据状态来维护节点的样式，比如这里将按钮设置为<code>disabled</code>，那么render函数就要添加相应的判断逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clicked = <span class="keyword">this</span>.state.clicked;</span><br><span class="line">    <span class="keyword">if</span>(clicked)</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p>这里简单介绍了通过JSX来管理组件的结构和逻辑，事实上React给组件还定义了很多方法，以及组件自身的生命周期，这些都使得组件的逻辑处理更加强大</p><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>CSS文件定义了组件的样式，现在的模块加载器通常都能够加载CSS文件，如果不能一般也提供了相应的插件。事实上CSS、图片可以看做是一种资源，因为加载过来后一般不需要做什么处理。</p><p>React对这一方面并没有做特别的处理，虽然它提供了Inline Style的方式把CSS写在JSX里面，但估计没有多少人会去尝试，毕竟现在CSS样式已经不再只是简单的CSS文件了，通常都会去用Less、Sass等预处理，然后再用像postcss、myth、autoprefixer、cssmin等等后处理。资源加载一般也就简单粗暴地使用模块加载器完成了</p><h3 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h3><p>组件依赖的处理一般分为两个部分：组件加载和组件使用</p><h4 id="组件加载"><a href="#组件加载" class="headerlink" title="组件加载"></a>组件加载</h4><p>React没有提供相关的组件加载方法，依旧需要通过<code>&lt;script&gt;</code>标签引入，或者使用模块加载器加载组件的JSX和资源文件。</p><h4 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h4><p>如果细心，就会发现其实之前已经有使用的例子了，要想在一个组件中使用另外一个组件，比如在<code>ParentComponent</code>中使用<code>ChildComponent</code>，就只需要在<code>ParentComponent</code>的<code>render()</code>方法中写上<code>&lt;ChildComponent /&gt;</code>就行了，必要的时候还可以传些参数。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>到这里就会发现一个问题，React除了只处理了结构和逻辑，资源也不管，依赖也不管。是的，React将近两万行代码，连个模块加载器都没有提供，更与Angularjs，jQuery等不同的是，他还不带啥脚手架…没有Ajax库，没有Promise库，要啥啥没有…</p><h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>那它为啥这么大？因为它实现了一个虚拟DOM（Virtual DOM）。虚拟DOM是干什么的？这就要从浏览器本身讲起</p><p>如我们所知，在浏览器渲染网页的过程中，加载到HTML文档后，会将文档解析并构建DOM树，然后将其与解析CSS生成的CSSOM树一起结合产生爱的结晶——RenderObject树，然后将RenderObject树渲染成页面（当然中间可能会有一些优化，比如RenderLayer树）。这些过程都存在与渲染引擎之中，渲染引擎在浏览器中是于JavaScript引擎（JavaScriptCore也好V8也好）分离开的，但为了方便JS操作DOM结构，渲染引擎会暴露一些接口供JavaScript调用。由于这两块相互分离，通信是需要付出代价的，因此JavaScript调用DOM提供的接口性能不咋地。各种性能优化的最佳实践也都在尽可能的减少DOM操作次数。</p><p>而虚拟DOM干了什么？它直接用JavaScript实现了DOM树（大致上）。组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React又通过在这个虚拟DOM上实现了一个 diff 算法找出最小变更，再把这些变更写入实际的DOM中。这个虚拟DOM以JS结构的形式存在，计算性能会比较好，而且由于减少了实际DOM操作次数，性能会有较大提升</p><p><strong>道理我都懂，可是为什么我们没有模块加载器？</strong></p><p>所以就需要Webpack了</p><h2 id="说说Webpack"><a href="#说说Webpack" class="headerlink" title="说说Webpack"></a>说说Webpack</h2><h3 id="什么是Webpack？"><a href="#什么是Webpack？" class="headerlink" title="什么是Webpack？"></a>什么是Webpack？</h3><p>事实上它是一个打包工具，而不是像RequireJS或SeaJS这样的模块加载器，通过使用Webpack，能够像Node.js一样处理依赖关系，然后解析出模块之间的依赖，将代码打包</p><h3 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h3><p>首先得有Node.js</p><p>然后通过<code>npm install -g webpack</code>安装webpack，当然也可以通过gulp来处理webpack任务，如果使用gulp的话就<code>npm install --save-dev gulp-webpack</code></p><h3 id="配置Webpack"><a href="#配置Webpack" class="headerlink" title="配置Webpack"></a>配置Webpack</h3><p>Webpack的构建过程需要一个配置文件，一个典型的配置文件大概就是这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> commonsPlugin = <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        entry1: <span class="string">'./entry/entry1.js'</span>,</span><br><span class="line">        entry2: <span class="string">'./entry/entry2.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: <span class="string">'[name].entry.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.jsx$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader!jsx-loader?harmony'</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [commonsPlugin]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里对Webpack的打包行为做了配置，主要分为几个部分：</p><ul><li>entry：指定打包的入口文件，每有一个键值对，就是一个入口文件</li><li>output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称，filename里面的<code>[name]</code>会由entry中的键（这里是entry1和entry2）替换</li><li>resolve：定义了解析模块路径时的配置，常用的就是extensions，可以用来指定模块的后缀，这样在引入模块时就不需要写后缀了，会自动补全</li><li>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。比如这里定义了凡是<code>.js</code>结尾的文件都是用<code>babel-loader</code>做处理，而<code>.jsx</code>结尾的文件会先经过<code>jsx-loader</code>处理，然后经过<code>babel-loader</code>处理。当然这些loader也需要通过<code>npm install</code>安装</li><li>plugins: 这里定义了需要使用的插件，比如commonsPlugin在打包多个入口文件时会提取出公用的部分，生成common.js</li></ul><p>当然Webpack还有很多其他的配置，具体可以参照它的<a href="http://webpack.github.io/docs/configuration.html#entry" target="_blank" rel="noopener">配置文档</a></p><h3 id="执行打包"><a href="#执行打包" class="headerlink" title="执行打包"></a>执行打包</h3><p>如果通过<code>npm install -g webpack</code>方式安装webpack的话，可以通过命令行直接执行打包命令，比如这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">webpack --config webpack.config.js</span></span><br></pre></td></tr></table></figure><p>这样就会读取当前目录下的webpack.config.js作为配置文件执行打包操作</p><p>如果是通过gulp插件gulp-webpack，则可以在gulpfile中写上gulp任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'gulp-webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line">gulp.task(<span class="string">"webpack"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .src(<span class="string">'./'</span>)</span><br><span class="line">        .pipe(webpack(webpackConfig))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="组件编写"><a href="#组件编写" class="headerlink" title="组件编写"></a>组件编写</h3><h4 id="使用Babel提升逼格"><a href="#使用Babel提升逼格" class="headerlink" title="使用Babel提升逼格"></a>使用Babel提升逼格</h4><p>Webpack使得我们可以使用Node.js的CommonJS规范来编写模块，比如一个简单的Hello world模块，就可以这么处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloWorldComponent = React.createClass(&#123;</span><br><span class="line">    displayName: <span class="string">'HelloWorldComponent'</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloWorldComponent;</span><br></pre></td></tr></table></figure><p>等等，这和之前的写法没啥差别啊，依旧没有逼格…程序员敲码要有geek范，要逼格than逼格，这太low了。现在都ES6了，React的代码也要写ES6，<code>babel-loader</code>就是干这个的。<a href="https://babeljs.io" target="_blank" rel="noopener">Babel</a>能够将ES6代码转换成ES5。首先需要通过命令<code>npm install --save-dev babel-loader</code>来进行安装，安装完成后就可以使用了，一种使用方式是之前介绍的在<code>webpack.config.js</code>的loaders中配置，另一种是直接在代码中使用，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloWorldComponent = <span class="built_in">require</span>(<span class="string">'!babel!jsx!./HelloWorldComponent'</span>);</span><br></pre></td></tr></table></figure><p>那我们应当如何使用Babel提升代码的逼格呢？改造一下之前的HelloWorld代码吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在其他组件中需要引入HelloWorldComponent组件，就只要就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorldComponent <span class="keyword">from</span> <span class="string">'./HelloWorldComponent'</span></span><br></pre></td></tr></table></figure><p>怎么样是不是更有逼格了？通过import引入模块，还可以直接定义类和类的继承关系，这里也不再需要<code>getInitialState</code>了，直接在构造函数<code>constructor</code>中用<code>this.state = xxx</code>就好了</p><p>Babel带来的当然还不止这些，在其帮助下还能尝试很多优秀的ES6特性，比如箭头函数，箭头函数的特点就是内部的this和外部保持一致，从此可以和<code>that</code>、<code>_this</code>说再见了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>].map(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;c&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其他还有很多，具体可以参照<a href="https://babeljs.io/docs/learn-es6" target="_blank" rel="noopener">Babel的学习文档</a></p><h4 id="样式编写"><a href="#样式编写" class="headerlink" title="样式编写"></a>样式编写</h4><p>我是一个强烈地Less依赖患者，脱离了Less直接写CSS就会出现四肢乏力、不想干活、心情烦躁等现象，而且还不喜欢在写Less时候加前缀，平常都是gulp+less+autoprefixer直接处理的，那么在Webpack组织的React组件中要怎么写呢？</p><p><strong>没错，依旧是使用loader</strong></p><p>可以在<code>webpack.config.js</code>的loaders中增加Less的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  loader: <span class="string">'style-loader!css-loader!autoprefixer-loader!less-loader'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的配置，就可以直接在模块代码中引入Less样式了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./HelloWorldComponent.less'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Webpack的loader为React组件化提供了很多帮助，像图片也提供了相关的loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.png$/</span>, <span class="attr">loader</span>: <span class="string">"url-loader?mimetype=image/png"</span> &#125;</span><br></pre></td></tr></table></figure><p>更多地loader可以移步<a href="https://github.com/webpack/docs/wiki/list-of-loaders" target="_blank" rel="noopener">webpack的wiki</a></p><h2 id="在Webpack下实时调试React组件"><a href="#在Webpack下实时调试React组件" class="headerlink" title="在Webpack下实时调试React组件"></a>在Webpack下实时调试React组件</h2><p>Webpack和React结合的另一个强大的地方就是，在修改了组件源码之后，不刷新页面就能把修改同步到页面上。这里需要用到两个库<code>webpack-dev-server</code>和<code>react-hot-loader</code>。</p><p>首先需要安装这两个库，<code>npm install --save-dev webpack-dev-server react-hot-loader</code></p><p>安装完成后，就要开始配置了，首先需要修改entry配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  helloworld: [</span><br><span class="line">    <span class="string">'webpack-dev-server/client?http://localhost:3000'</span>,</span><br><span class="line">    <span class="string">'webpack/hot/only-dev-server'</span>,</span><br><span class="line">    <span class="string">'./helloworld'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>通过这种方式指定资源热启动对应的服务器，然后需要配置<code>react-hot-loader</code>到loaders的配置当中，比如我的所有组件代码全部放在scripts文件夹下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">  loaders: [<span class="string">'react-hot'</span>, <span class="string">'babel'</span>],</span><br><span class="line">  include: [path.join(__dirname, <span class="string">'scripts'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配置一下plugins，加上热替换的插件和防止报错的插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  <span class="keyword">new</span> webpack.NoErrorsPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样配置就完成了，但是现在要调试需要启动一个服务器，而且之前配置里映射到<code>http://localhost:3000</code>，所以就在本地3000端口起个服务器吧，在项目根目录下面建个server.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> WebpackDevServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  publicPath: config.output.publicPath,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening at localhost:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以在本地3000端口开启调试服务器了，比如我的页面是根目录下地<code>index.html</code>，就可以直接通过<code>http://localhost:3000/index.html</code>访问页面，修改React组件后页面也会被同步修改，这里貌似使用了websocket来同步数据。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>React的组件化开发很有想法，而Webpack使得React组件编写和管理更加方便，这里只涉及到了React和Webpack得很小一部分，还有更多的最佳实践有待在学习的路上不断发掘</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/JS%E6%8A%80%E6%9C%AF/">JS技术</category>
      
      
      <category domain="http://lingyu.life/tags/React/">React</category>
      
      
      <comments>http://lingyu.life/2015/05/15/react-and-webpack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前端动画对比</title>
      <link>https://lingyu.life/#/post/2015/04/18/learn-canvas-1</link>
      <guid>https://lingyu.life/#/post/2015/04/18/learn-canvas-1</guid>
      <pubDate>Fri, 17 Apr 2015 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;将近三个月没写文章了，就在这三个月内，我从一只学生狗变成了上班族。现在一切都稳定下来了，决定重新开始写点东西了。以后的计划是每周一篇，努力坚持~&lt;/p&gt;
&lt;p&gt;之前玩了很长时间的Canvas动画，也写了一些工具和一些demo，放在了我Github上的&lt;a href=&quot;https://github.com/LingyuCoder/learn-canvas&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;learn-canvas&lt;/a&gt;仓库里。在学习Canvas动画的过程中学到了不少宝贵的新知识，这篇主要是个人对于Canvas动画的一些想法以及与其他前端动画实现的一些对比。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>将近三个月没写文章了，就在这三个月内，我从一只学生狗变成了上班族。现在一切都稳定下来了，决定重新开始写点东西了。以后的计划是每周一篇，努力坚持~</p><p>之前玩了很长时间的Canvas动画，也写了一些工具和一些demo，放在了我Github上的<a href="https://github.com/LingyuCoder/learn-canvas" target="_blank" rel="noopener">learn-canvas</a>仓库里。在学习Canvas动画的过程中学到了不少宝贵的新知识，这篇主要是个人对于Canvas动画的一些想法以及与其他前端动画实现的一些对比。</p><a id="more"></a><h2 id="动画？"><a href="#动画？" class="headerlink" title="动画？"></a>动画？</h2><p>几年前，网页开发主要的侧重点还在于功能的实现。那时候的界面虽然不漂亮甚至很丑，但只要提供了用户切实需要的功能，也往往能够得到认可。但如今，随着互联网的快速发展，提供相同功能的互联网产品层出不穷，相互之间的竞争也日益增大。</p><p>互联网产品与传统的软件产品不同，以前用户通常是通过购买软件安装软体来获取服务，这种方式使得用户在竞品之间相互转换的代价很高，因此产品往往会有一批自己的用户，竞品相互之间会各有一片领地，然后通过销售、广告等等渠道缓慢的蚕食对手的地盘。</p><p>然而互联网产品的情境就完全不同了，用户只需要在浏览器中敲入一个网址，就可以轻松的获取服务。这方便了产品的推广和传播，同时也大大降低了用户对于产品的依赖程度，用户可以很方便的获取到其他同类产品的服务。因此服务提供商就需要想尽各种办法来留住用户。</p><p>当然留住用户的方法有很多，比如提供竞品没有的功能、仔细研究特殊用户群的痛点并提供针对性的解决方案等等，但其中的一个比较直接的方式就是“让我们的产品用起来比别人的用起来爽”，说白了也就是提升用户体验。浏览器的性能提升以及对CSS3和HTML5规范的支持，为用户带来了多种多样前所未有的互联网产品体验，动画就是其中一个。</p><p>动画给用户带来的体验提升是非常直接的，添加了动画后，信息的展现不再是冰冷冷的文字和图片，变得更加生动、直观，各种模仿现实的动画效果也使得页面元素的展现更加自然、亲切。在页面上实现动画比较常见的有三种方法：</p><ol><li>CSS动画</li><li>JavaScript动画</li><li>Canvas、WebGL动画</li></ol><p>这里就说说这三种动画</p><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>CSS3可以很方便的通过修改页面元素的样式来实现动画，主要是两种：<code>transition</code>和<code>animation</code>：</p><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><code>transition</code>为状态的转变提供了过渡动画，比如<code>transition: width 1s linear</code>，如果当前宽度为200，修改其宽度为400，那么就会发生一个时长为1s的动画，在这个动画过程中宽度逐渐增加转变为400。具体的转变方式由linear这种缓动函数来指定，linear就是线性的变化</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p><code>animation</code>则是通过定义<code>keyframes</code>关键帧来实现动画，一个典型的keyframes大致是这个样子的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myAnime &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">200px</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在通过在元素样式中定义<code>animation</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ele</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: myAnime <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方法就可以让元素动起来，具体每个参数有什么作用，可以去看看W3C或是MDN的介绍</p><h3 id="优势和缺陷"><a href="#优势和缺陷" class="headerlink" title="优势和缺陷"></a>优势和缺陷</h3><p>CSS动画有很多优点：</p><ol><li>写起来很简单，也比较直观，非常适合实现一些元素动效</li><li>在绝大部分时间CSS动画的性能都比较好（不触发重布局和重绘，还能使用上GPU加速）</li></ol><p>但缺陷也很多：</p><ol><li>动画过程控制能力较弱，逐帧控制不可行</li><li>部分浏览器不兼容，现在大部分都可以，尤其是移动端</li><li>若触发重布局和重绘，会大幅度降低性能</li><li>由于是CSS实现因此有不少局限性（页面滚动动画等）</li><li>基于页面元素，不可能实现像素级的渲染控制</li></ol><h2 id="JavaScript动画"><a href="#JavaScript动画" class="headerlink" title="JavaScript动画"></a>JavaScript动画</h2><p>JavaScript的动画本质上和CSS动画相似，同样是构建在页面元素的基础之上，比如jQuery的<code>$.fn.animate</code>就实现了JavaScript动画。</p><p>JavaScript动画本质上就是通过每隔一小段时间修改一次元素的CSS样式来实现动画。由于每一帧元素的样式都需要计算当前时间点所需要展现的样式属性值，因此只要修改计算的方式就能干预动画过程。这种逐帧绘制的方式有很多好处：由于每一帧都能进行干预，因此拥有极强的控制能力，可以单帧的控制、变换，写得好完全可以兼容IE6，并且像页面滚动这样的效果也可以实现。但由于计算过程需要自己实现，因此JavaScript动画往往较为复杂，所以性能上很容易出现问题，而且一般需要依赖外部动画库（不久之后就不需要了）。另外JavaScript动画和CSS动画同样是基于页面元素和CSS样式，因此有自己的局限性，像素级的控制无法实现。</p><p>JavaScript动画往往用于CSS动画无法完成动画的场景，比如兼容低级浏览器、实现一些细粒度动画等等</p><h2 id="Canvas、WebGL动画"><a href="#Canvas、WebGL动画" class="headerlink" title="Canvas、WebGL动画"></a>Canvas、WebGL动画</h2><p>Canvas和WebGL分别提供了2D和3D的画布进行绘制，这种绘制脱离元素和CSS，因此可以随心所欲定义绘制方案。这里就以Canvas为主，因为WebGL我不会哈哈。</p><p>Canvas本身提供了一系列的绘制方法，但同样需要JavaScript来控制，与JavaScript动画类似。Canvas本质上可以看做一叠白纸，并且提供了一些圆规直尺的工具，然后画一个动画的过程就是：画一帧，然后把换下一张白纸再画下一帧，和童年在书上画翻页动画原理一样。因此Canvas动画的好处有：</p><ol><li>拥有JavaScript动画的控制能力</li><li>完全脱离CSS和元素，绘制的方式和结果完全由自己控制，可以实现像素级别的控制</li><li>能够利用GPU加速，性能不错</li><li>可以进行画布控制，导入图像或导出图像</li><li>可以进行图像分析</li></ol><p>但是这些好处也是需要付出代价的：</p><ol><li>所有的绘制细节都要自己去控制，需要大量代码</li><li>不再基于CSS和DOM，因此在交互上很麻烦，只能在canvas上监听然后再计算位置投射到对应的元素上</li></ol><p>由于这种像素级别的控制能力，往往会使用Canvas做游戏和像音频可视化这样的复杂视觉效果</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今天先写到这里，下一篇写一写Canvas动画里的一些基础知识</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Canvas/">Canvas</category>
      
      <category domain="http://lingyu.life/tags/%E5%8A%A8%E7%94%BB/">动画</category>
      
      <category domain="http://lingyu.life/tags/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      
      <comments>http://lingyu.life/2015/04/18/learn-canvas-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RisingStack的Node.js风格指南</title>
      <link>https://lingyu.life/#/post/2014/11/24/risingstack-nodejs-style-guide</link>
      <guid>https://lingyu.life/#/post/2014/11/24/risingstack-nodejs-style-guide</guid>
      <pubDate>Sun, 23 Nov 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;本文翻译自&lt;a href=&quot;https://github.com/RisingStack/node-style-guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RisingStack/node-style-guide&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本文翻译自<a href="https://github.com/RisingStack/node-style-guide" target="_blank" rel="noopener">RisingStack/node-style-guide</a></p><a id="more"></a><h2 id="RisingStack-的Node-js-风格指南"><a href="#RisingStack-的Node-js-风格指南" class="headerlink" title="RisingStack 的Node.js 风格指南() {"></a><a href="http://risingstack.com" target="_blank" rel="noopener">RisingStack</a> 的Node.js 风格指南() {</h2><h3 id="文章的大部分内容来自-Airbnb-stlyeguide"><a href="#文章的大部分内容来自-Airbnb-stlyeguide" class="headerlink" title="文章的大部分内容来自 Airbnb stlyeguide"></a>文章的大部分内容来自 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb stlyeguide</a></h3><p>以下风格指南对此指南有很大影响:</p><ul><li>@caolan’s <a href="http://caolanmcmahon.com/posts/nodejs_style_and_structure" target="_blank" rel="noopener">Node.js stlyeguide</a></li><li>@felixge’s <a href="https://github.com/felixge/node-style-guide" target="_blank" rel="noopener">Node.js stlyeguide</a></li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li><p><strong>原生类型</strong>: 当访问一个原生类型时直接对其值进行操作</p><ul><li><code>string</code></li><li><code>number</code></li><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"></span><br><span class="line">bar = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo, bar); <span class="comment">// =&gt; 1, 9</span></span><br></pre></td></tr></table></figure></li><li><p><strong>复杂类型</strong>: 当访问一个复杂类型时，将对其值的引用上进行操作</p><ul><li><code>object</code></li><li><code>array</code></li><li><code>function</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"></span><br><span class="line">bar[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>], bar[<span class="number">0</span>]); <span class="comment">// =&gt; 9, 9</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>使用字面量创建对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> item = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用可读的同义单词来代替JavaScript的保留字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐，class是保留字</span></span><br><span class="line"><span class="keyword">var</span> superman = &#123;</span><br><span class="line">  class: 'alien'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐，klass不具备可读性</span></span><br><span class="line"><span class="keyword">var</span> superman = &#123;</span><br><span class="line">  klass: <span class="string">'alien'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> superman = &#123;</span><br><span class="line">  type: <span class="string">'alien'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>使用字面量创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> items = [];</span><br></pre></td></tr></table></figure></li><li><p>如果不知道数组的长度，使用Array#push方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someStack = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">someStack[someStack.length] = <span class="string">'abracadabra'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">someStack.push(<span class="string">'abracadabra'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用Array#slice来拷贝数组，这样性能较好，详见<a href="http://jsperf.com/converting-arguments-to-an-array/7" target="_blank" rel="noopener">jsPerf</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = items.length;</span><br><span class="line"><span class="keyword">var</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐，遍历性能较低</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure></li><li><p>将类数组对象转变为数组时，使用Array#slice方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><ul><li><p>对字符串使用单引号<code>&#39;&#39;</code>包裹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob Parr"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob Parr'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">"Bob "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">'Bob '</span> + <span class="keyword">this</span>.lastName;</span><br></pre></td></tr></table></figure></li><li><p>字符串长度超过80个字符时，应当将字符串写成多行并通过加号进行拼接</p></li><li><p>注意：如果过度使用长字符串拼接方式将影响性能，详见<a href="http://jsperf.com/ya-string-concat" target="_blank" rel="noopener">jsPerf</a> &amp; <a href="https://github.com/airbnb/javascript/issues/40" target="_blank" rel="noopener">Discussion</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because \</span></span><br><span class="line"><span class="string">of Batman. When you stop to think about how Batman had anything to do \</span></span><br><span class="line"><span class="string">with this, you would get nowhere \</span></span><br><span class="line"><span class="string">fast.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because '</span> +</span><br><span class="line">  <span class="string">'of Batman. When you stop to think about how Batman had anything to do '</span> +</span><br><span class="line">  <span class="string">'with this, you would get nowhere fast.'</span>;</span><br></pre></td></tr></table></figure></li><li><p>当以编码的方式构建一个字符串时，使用Array#join方法，而不要拼接字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items;</span><br><span class="line"><span class="keyword">var</span> messages;</span><br><span class="line"><span class="keyword">var</span> length;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line">messages = [&#123;</span><br><span class="line">  state: <span class="string">'success'</span>,</span><br><span class="line">  message: <span class="string">'This one worked.'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  state: <span class="string">'success'</span>,</span><br><span class="line">  message: <span class="string">'This one worked as well.'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  state: <span class="string">'error'</span>,</span><br><span class="line">  message: <span class="string">'This one did not work.'</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">length = messages.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inbox</span>(<span class="params">messages</span>) </span>&#123;</span><br><span class="line">  items = <span class="string">'&lt;ul&gt;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    items += <span class="string">'&lt;li&gt;'</span> + messages[i].message + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> items + <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inbox</span>(<span class="params">messages</span>) </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    items[i] = messages[i].message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;ul&gt;&lt;li&gt;'</span> + items.join(<span class="string">'&lt;/li&gt;&lt;li&gt;'</span>) + <span class="string">'&lt;/li&gt;&lt;/ul&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数表达式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数 (immediately-invoked function expression, IIFE)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>不要在非函数块（if、while等代码块）中声明函数，这种情况下应当将函数赋值给变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Nope.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  test = <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要声明<code>arguments</code>变量，这样将覆盖函数作用域的<code>arguments</code>对象（夺取了优先权，导致无法访问函数作用域的<code>arguments</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nope</span>(<span class="params">name, options, arguments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yup</span>(<span class="params">name, options, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li><p>使用符号<code>.</code>来访问属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luke = &#123;</span><br><span class="line">  jedi: <span class="literal">true</span>,</span><br><span class="line">  age: <span class="number">28</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> isJedi = luke[<span class="string">'jedi'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> isJedi = luke.jedi;</span><br></pre></td></tr></table></figure></li><li><p>在需要通过变量访问属性时使用中括号<code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luke = &#123;</span><br><span class="line">  jedi: <span class="literal">true</span>,</span><br><span class="line">  age: <span class="number">28</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> luke[prop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isJedi = getProp(<span class="string">'jedi'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>使用<code>var</code>来声明变量，这样能避免意外声明全局变量、污染全局命名空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">superPower = <span class="keyword">new</span> SuperPower();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> superPower = <span class="keyword">new</span> SuperPower();</span><br></pre></td></tr></table></figure></li><li><p>每个变量声明新启一行，并在每个声明前面加上<code>var</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"> <span class="keyword">var</span> items = getItems(),</span><br><span class="line">      goSportsTeam = <span class="literal">true</span>,</span><br><span class="line">      dragonball = <span class="string">'z'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"> <span class="keyword">var</span> items = getItems();</span><br><span class="line"> <span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">var</span> dragonball = <span class="string">'z'</span>;</span><br></pre></td></tr></table></figure></li><li><p>先声明需要赋值的变量，后声明不需要赋值的变量。这样后声明的变量能够依靠前面生成变量来生成自己的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> items = getItems(),</span><br><span class="line"><span class="keyword">var</span> dragonball,</span><br><span class="line"><span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,</span><br><span class="line"><span class="keyword">var</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> items = getItems(),</span><br><span class="line"><span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,</span><br><span class="line"><span class="keyword">var</span> dragonball,</span><br><span class="line"><span class="keyword">var</span> length,</span><br><span class="line"><span class="keyword">var</span> i;</span><br></pre></td></tr></table></figure></li><li><p>在作用域的顶部声明所有变量，这样有助于避免变量提升导致的相关问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  test();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..other stuff..</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  test();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..other stuff..</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h2><ul><li><p>按照如下顺序引用模块</p><ul><li>核心模块</li><li>npm上的工具模块</li><li>其他模块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br></pre></td></tr></table></figure></li><li><p>在模块引用时不要加上<code>.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul><li><p>总是在回调函数中检查是否出现错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">database.get(<span class="string">'pokemons'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, pokemons</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pokemons);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>回调函数也需要返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 如果不在这里返回</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这一样依旧会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常捕获（Try-catch）"><a href="#异常捕获（Try-catch）" class="headerlink" title="异常捕获（Try-catch）"></a>异常捕获（Try-catch）</h2><ul><li><p>只在同步函数中使用Try-catch</p><p>Try-catch代码块不能用来包裹异步的代码。Try-catch代码块将冒泡到最顶层，并记录整个冒泡的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>  callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在同步调用中使用Try-catch捕获异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonAsAString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">var</span> data;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  data = <span class="built_in">JSON</span>.parse(jsonAsAString);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误 —— 最好不只是用console.log输出</span></span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li><p>变量声明会提升到作用域顶端，但对这些变量的赋值是不会提升的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如我们所知，这不起作用 （没有同名的全局变量情况下）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(notDefined); <span class="comment">// =&gt; 抛出一个引用错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在引用一个变量之后创建一个变量声明一样能够正常工作</span></span><br><span class="line"><span class="comment">// 这是由于变量会提升。注意：这里赋值`true`并没有被提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></span><br><span class="line">  <span class="keyword">var</span> declaredButNotAssigned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器会将变量声明提升到作用域的顶部</span></span><br><span class="line"><span class="comment">// 这也就意味着上例可以写成如下方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> declaredButNotAssigned;</span><br><span class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></span><br><span class="line">  declaredButNotAssigned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名函数表达式只会提升变量定义，函数赋值语句不会提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(anonymous); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  anonymous(); <span class="comment">// =&gt; TypeError anonymous 不是函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'anonymous function expression'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名函数表达式同样提升变量定义，而不会提升函数名称和函数体</p></li><li><p>Named function expressions hoist the variable name, not the function name or the function body.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span></span><br><span class="line"></span><br><span class="line">  superPower(); <span class="comment">// =&gt; ReferenceError superPower 未定义</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就算函数名称和变量名称相同，也是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'named'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数声明会提升名称和函数体</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  superPower(); <span class="comment">// =&gt; Flying</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更多信息可以查看 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting" target="_blank" rel="noopener">JavaScript Scoping &amp; Hoisting</a> ，作者为 <a href="http://www.adequatelygood.com" target="_blank" rel="noopener">Ben Cherry</a></p></li></ul><h2 id="条件表达式和相等判断"><a href="#条件表达式和相等判断" class="headerlink" title="条件表达式和相等判断"></a>条件表达式和相等判断</h2><ul><li><p>使用 <code>===</code> 和 <code>!==</code> ，不要用 <code>==</code> 和 <code>!=</code></p></li><li><p>条件表达式计算时会强迫使用<code>ToBoolean</code>方法，并遵循如下规则：</p><ul><li><strong>Objects</strong> 判定为 <strong>true</strong></li><li><strong>Undefined</strong> 判定为 <strong>false</strong></li><li><strong>Null</strong> 判定为 <strong>false</strong></li><li><strong>Booleans</strong> 判定为 <strong>the value of the boolean</strong></li><li><strong>Numbers</strong> 如果为 <strong>+0, -0, or NaN</strong> 判定为 <strong>false</strong>，否则为 <strong>true</strong></li><li><strong>Strings</strong> 如果为 空字符串 <code>&#39;&#39;</code> 判定为 <strong>false</strong> 否则为 <strong>true</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 数组也是对象，对象都判定为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>善于简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (name !== <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (collection.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (collection.length) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更多信息请查看Angus Croll所著的 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" target="_blank" rel="noopener">Truth Equality and JavaScript</a> </p></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li><p>在所有多行代码块时都是用大括号</p></li><li><p>Use braces with all multi-line blocks.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (test)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (test) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p>使用<code>/**....*/</code>包裹多行注释，这种注释包括描述、参数及返回值的类型和值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="comment">// make() returns a new element</span></span><br><span class="line"><span class="comment">// based on the passed in tag name</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// @param &lt;String&gt; tag</span></span><br><span class="line"><span class="comment">// @return &lt;Element&gt; element</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed in tag name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>&lt;String&gt; tag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>&lt;Element&gt; element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单行注释时使用<code>//</code>。每一个单行注释在需要注释的位置上面新启一行。并在注释前加一个空行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> active = <span class="literal">true</span>;  <span class="comment">// is current tab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">var</span> active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</span><br><span class="line">  <span class="comment">// 设定默认值为'no type'</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设定默认值为'no type'</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在注释前增加<code>FIXME</code>或<code>TODO</code>来帮助其他开发者快速理解这里出现了一个问题或是需要提供实现。这种注释和常规的注释不同，它是可操作的。这些操作为<code>FIXME -- 需要弄清楚</code>或是<code>TODO -- 需要添加实现</code></p></li><li><p>使用 <code>// FIXME:</code> 来标注问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> 这里不应该有全局变量</span></span><br><span class="line">  total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>// TODO:</code> 来标注问题的解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> total应该通过参数来配置</span></span><br><span class="line">  <span class="keyword">this</span>.total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li><p>将TAB设置成两个空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙∙∙∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在大括号前加个空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>,&#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>, &#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在操作符旁边加上空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> x=y+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> x = y + <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>以一个换行符结束文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);↵</span><br><span class="line">↵</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);↵</span><br></pre></td></tr></table></figure></li><li></li><li><p>为长的链式方法调用增加缩进</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">$(<span class="string">'#items'</span>).find(<span class="string">'.selected'</span>).highlight().end().find(<span class="string">'.open'</span>).updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">$(<span class="string">'#items'</span>)</span><br><span class="line">  .find(<span class="string">'.selected'</span>)</span><br><span class="line">    .highlight()</span><br><span class="line">    .end()</span><br><span class="line">  .find(<span class="string">'.open'</span>)</span><br><span class="line">    .updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>).data(data).enter().append(<span class="string">'svg:svg'</span>).class(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>).append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>)</span><br><span class="line">    .data(data)</span><br><span class="line">  .enter().append(<span class="string">'svg:svg'</span>)</span><br><span class="line">    .class(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>)</span><br><span class="line">  .append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br></pre></td></tr></table></figure></li></ul><h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><ul><li><p>以逗号启始: <strong>不</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    firstName: <span class="string">'Bob'</span></span><br><span class="line">  , <span class="attr">lastName</span>: <span class="string">'Parr'</span></span><br><span class="line">  , <span class="attr">heroName</span>: <span class="string">'Mr. Incredible'</span></span><br><span class="line">  , <span class="attr">superPower</span>: <span class="string">'strength'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Bob'</span>,</span><br><span class="line">  lastName: <span class="string">'Parr'</span>,</span><br><span class="line">  heroName: <span class="string">'Mr. Incredible'</span>,</span><br><span class="line">  superPower: <span class="string">'strength'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在结尾加上逗号：<em>不</em>。这将在IE6/7和IE9的怪异模式中引发一些问题。而且，如果在数组中这么做，在一些ES3的实现中会增加数组的长度。这在ES5中做了修正(<a href="http://es5.github.io/#D" target="_blank" rel="noopener">source</a>)：</p><blockquote><p>Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Kevin'</span>,</span><br><span class="line">  lastName: <span class="string">'Flynn'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heroes = [</span><br><span class="line">  <span class="string">'Batman'</span>,</span><br><span class="line">  <span class="string">'Superman'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Kevin'</span>,</span><br><span class="line">  lastName: <span class="string">'Flynn'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heroes = [</span><br><span class="line">  <span class="string">'Batman'</span>,</span><br><span class="line">  <span class="string">'Superman'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure></li></ul><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><ul><li><p>永远使用分号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span></span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><h2 id="类型转换和强制类型转换"><a href="#类型转换和强制类型转换" class="headerlink" title="类型转换和强制类型转换"></a>类型转换和强制类型转换</h2><ul><li><p>在声明开头进行强制类型转换</p></li><li><p>字符串:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  =&gt; this.reviewScore = 9;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>parseInt</code> 转换成数字并总是加上进制数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputValue = <span class="string">'4'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="keyword">new</span> <span class="built_in">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = +inputValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果你出于某种原因做一些非常规的需求且<code>parseInt</code>是你性能的瓶颈，必须用位操作<a href="http://jsperf.com/coercion-vs-casting/3" target="_blank" rel="noopener">提升性能</a>时，添加注释来解释为什么这么做、到底做了什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parseInt是性能不佳的原因</span></span><br><span class="line"><span class="comment"> * 位操作强制将一个String转换为Number要快得多</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意:</strong> 使用位操作时需要注意。所有的数字都是<a href="http://es5.github.io/#x4.3.19" target="_blank" rel="noopener">64位浮点型</a>，但位操作经常返回32位整型（<a href="http://es5.github.io/#x11.7" target="_blank" rel="noopener">请看</a>）。位操作会在值大于32位时发生一些问题。<a href="https://github.com/airbnb/javascript/issues/109" target="_blank" rel="noopener">这里有一些关于此的讨论</a>。最大的有符号整型是 2,147,483,647</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2147483647</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; 2147483647</span></span><br><span class="line"><span class="number">2147483648</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483648</span></span><br><span class="line"><span class="number">2147483649</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483647</span></span><br></pre></td></tr></table></figure></li><li><p>布尔类型:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = <span class="keyword">new</span> <span class="built_in">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = <span class="built_in">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = !!age;</span><br></pre></td></tr></table></figure></li></ul><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ul><li><p>避免单字母的命名。命名应该能够自解释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">q</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ..stuff..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在命名对象、函数和实例的时候使用驼峰命名法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> OBJEcttsssss = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> this_is_my_object = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> user(&#123;</span><br><span class="line">  name: <span class="string">'Bob Parr'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> thisIsMyObject = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  name: <span class="string">'Bob Parr'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在命名构造函数和类时使用帕斯卡构造法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bad = <span class="keyword">new</span> user(&#123;</span><br><span class="line">  name: <span class="string">'nope'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> good = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  name: <span class="string">'yup'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>命名私有属性时添加<code>_</code>前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">this</span>.__firstName__ = <span class="string">'Panda'</span>;</span><br><span class="line"><span class="keyword">this</span>.firstName_ = <span class="string">'Panda'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">this</span>._firstName = <span class="string">'Panda'</span>;</span><br></pre></td></tr></table></figure></li><li><p>当需要保存一个<code>this</code>的引用时，使用<code>_this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(that);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总是为函数命名，这样有助于栈的追踪</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h2><ul><li><p>一般不需要属性的访问器函数</p></li><li><p>如果要创造属性的访问器函数，使用 getVal() 和 setVal(‘hello’)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dragon.age();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dragon.getAge();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dragon.age(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dragon.setAge(<span class="number">25</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果属性时布尔类型，使用 isVal() 或 hasVal()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (!dragon.age()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (!dragon.hasAge()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以创建 get() 和 set() 方法，但必须一致</p></li><li><p>It’s okay to create get() and set() functions, but be consistent.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  <span class="keyword">var</span> lightsaber = options.lightsaber || <span class="string">'blue'</span>;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'lightsaber'</span>, lightsaber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[key] = val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><p>给构造函数的prototype对象增加新方法，不要直接给prototype重写一个新的对象。重写prototype对象会导致无法继承：重写prototype将覆盖掉基类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new jedi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">Jedi.prototype = &#123;</span><br><span class="line">  fight: <span class="function"><span class="keyword">function</span> <span class="title">fight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fighting'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  block: <span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'blocking'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Jedi.prototype.fight = <span class="function"><span class="keyword">function</span> <span class="title">fight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fighting'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.block = <span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'blocking'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>可以为方法返回<code>this</code>方便链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();</span><br><span class="line">luke.jump(); <span class="comment">// =&gt; true</span></span><br><span class="line">luke.setHeight(<span class="number">20</span>) <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();</span><br><span class="line"></span><br><span class="line">luke.jump()</span><br><span class="line">  .setHeight(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可以重写toString()方法，只要它能正常工作且不会有副作用就行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  <span class="keyword">this</span>.name = options.name || <span class="string">'no name'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Jedi - '</span> + <span class="keyword">this</span>.getName();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>推荐的书籍</strong></p><ul><li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" target="_blank" rel="noopener">JavaScript语言精粹</a> - Douglas Crockford</li><li><a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752" target="_blank" rel="noopener">JavaScript模式</a> - Stoyan Stefanov</li><li><a href="http://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X" target="_blank" rel="noopener">JavaScript设计模式</a>  - Ross Harmes and Dustin Diaz</li><li><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309" target="_blank" rel="noopener">高性能网站建设指南</a> - Steve Souders</li><li><a href="http://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680" target="_blank" rel="noopener">编写可维护的JavaScript</a> - Nicholas C. Zakas</li><li><a href="http://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X" target="_blank" rel="noopener">JavaScript Web 富应用开发</a> - Alex MacCaw</li><li><a href="http://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273" target="_blank" rel="noopener">Pro JavaScript Techniques</a> - John Resig</li><li><a href="http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595" target="_blank" rel="noopener">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li><li><a href="http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X" target="_blank" rel="noopener">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li><li><a href="http://humanjavascript.com" target="_blank" rel="noopener">Human JavaScript</a> - Henrik Joreteg</li><li><a href="http://superherojs.com" target="_blank" rel="noopener">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li><li><a href="http://jsbooks.revolunet.com" target="_blank" rel="noopener">JSBooks</a></li><li><a href="http://manning.com/vinegar" target="_blank" rel="noopener">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li></ul><p><strong>推荐的博客</strong></p><ul><li><a href="http://dailyjs.com" target="_blank" rel="noopener">DailyJS</a></li><li><a href="http://javascriptweekly.com" target="_blank" rel="noopener">JavaScript Weekly</a></li><li><a href="http://javascriptweblog.wordpress.com" target="_blank" rel="noopener">JavaScript, JavaScript…</a></li><li><a href="http://weblog.bocoup.com" target="_blank" rel="noopener">Bocoup Weblog</a></li><li><a href="http://www.adequatelygood.com" target="_blank" rel="noopener">Adequately Good</a></li><li><a href="http://www.nczonline.net" target="_blank" rel="noopener">NCZOnline</a></li><li><a href="http://perfectionkills.com" target="_blank" rel="noopener">Perfection Kills</a></li><li><a href="http://benalman.com" target="_blank" rel="noopener">Ben Alman</a></li><li><a href="http://dmitry.baranovskiy.com" target="_blank" rel="noopener">Dmitry Baranovskiy</a></li><li><a href="http://dustindiaz.com" target="_blank" rel="noopener">Dustin Diaz</a></li><li><a href="http://net.tutsplus.com/?s=javascript" target="_blank" rel="noopener">nettuts</a></li></ul><h2 id="JavaScript风格指南"><a href="#JavaScript风格指南" class="headerlink" title="JavaScript风格指南"></a>JavaScript风格指南</h2><ul><li><a href="https://github.com/airbnb/javascript/wiki/The-JavaScript-Style-Guide-Guide" target="_blank" rel="noopener">查看</a></li></ul><h2 id="项目贡献者"><a href="#项目贡献者" class="headerlink" title="项目贡献者"></a>项目贡献者</h2><ul><li><a href="https://github.com/airbnb/javascript/graphs/contributors" target="_blank" rel="noopener">查看贡献者</a></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h1 id=""><a href="#" class="headerlink" title="};"></a>};</h1>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      
      <comments>http://lingyu.life/2014/11/24/risingstack-nodejs-style-guide/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Peertc和五子棋</title>
      <link>https://lingyu.life/#/post/2014/11/18/peertc-and-fivechess</link>
      <guid>https://lingyu.life/#/post/2014/11/18/peertc-and-fivechess</guid>
      <pubDate>Mon, 17 Nov 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：&lt;a href=&quot;https://github.com/LingyuCoder/peertc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Peertc&lt;/a&gt;、&lt;a href=&quot;https://github.com/LingyuCoder/FiveChess&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五子棋&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：<a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="noopener">Peertc</a>、<a href="https://github.com/LingyuCoder/FiveChess" target="_blank" rel="noopener">五子棋</a></p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之前我曾经写过好几篇关于WebRTC和DataChannel相关的文章。WebRTC是我毕业设计中非常重要的一部分，因此对它做了不少研究。虽然WebRTC的RTC是real-time communication，但它带来的好处并不只局限在即时通信领域。建立点对点通信并在浏览器之间直接传递数据，光这一点就可以提出非常多有趣的设想。有两个应用的点子我一直想做：</p><ul><li>FC红白机那种双人对战（协作）游戏，配合Canvas和WebGL，这也就是这次五子棋想法的来源。</li><li>在线协作编辑：《黑客与画家》中曾经提到过，说在线协作这种工具很有市场。另外除了文档，我们还可以基于Canvas做协作绘图。</li></ul><p>五子棋就来源一第一个点子。至于第二个，做了一些调研，估计用<a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="noopener">OT.js</a>，只能等有时间的时候去弄了。</p><p>FC那么多牛逼的游戏，我却只是做了一个五子棋。原因很简单，Canvas玩的不够熟练也没有素材。五子棋游戏和其他游戏不同的是，它不需要做循环画面刷新，非常适合Canvas上手。</p><h2 id="Peertc"><a href="#Peertc" class="headerlink" title="Peertc"></a>Peertc</h2><p><a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="noopener">Peertc</a>是我在WebRTC DataChannel基础上实现的一个建立点对点通信，发送数据和文件的一个库。由于WebRTC在建立通信信道上还是无法脱离服务器，所以使用Node.js和<a href="https://www.npmjs.org/package/ws" target="_blank" rel="noopener">ws</a>在后台弄了个WebSocket服务器，同时WebSocket也是很好的退化方案。</p><p>至于Peertc具体如何建立点对点连接，我已经在文章<a href="/#/post/2014/10/21/datachannel">使用WebRTC DataChannel在浏览器间传递数据</a>中通过老姚和老刘的故事介绍过了</p><p>如果图简单的话，只要知道Peertc就是一个在俩浏览器之间传输数据的库就可以了</p><h2 id="五子棋"><a href="#五子棋" class="headerlink" title="五子棋"></a>五子棋</h2><p>我以前没写过五子棋，玩五子棋也玩的比较渣。乘着这个机会，仔细研究了一下五子棋的实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一个棋盘（多大随意，我玩过15*15的，但是也玩过可以无限扩展的）就是一个二维数组，黑白轮流往棋盘上放棋子，也就是往二维数组里赋值。每次放下棋子，判断一下在当前位置的横线、竖线、两条斜线上是否能成五个相连，也就是判断各个方向是否能成5个数字相同。</p><p>状态也只有4个：</p><ol><li>黑色落子</li><li>白色落子</li><li>黑色获胜</li><li>白色获胜</li></ol><p>状态转移：</p><ul><li>初始状态为黑色落子</li><li>黑色落子后judge判断是否获胜，若获胜转黑色获胜，否则转白色落子</li><li>白色落子后judge判断是否获胜，若获胜转白色获胜，否则转黑色落子</li></ul><p>所以，五子棋的核心就是一个judge方法来判断是否连成5子，实现很简单</p><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><p>为什么要写AI？本来只是想实现双人对战的，那就不要AI了，但是觉着如果只能双人对战未免太过无趣，所以就调研了一下五子棋的AI算法。发现它和计算网页内容的readablity一样，通过计算下在各个位置所获得的分值，得分最高的即是最优解。这里需要注意几个地方：</p><ol><li>这是一个对战游戏，自己要下子获胜，也要堵别人子防止别人获胜。因此计算权重时两种情况都要考虑</li><li>下过五子棋的都知道，如果成了一列（无论方向），两头都没有被堵子肯定要比被堵了一头要强，因此这个是否被堵也要加到考虑当中</li><li>连着的越多，越靠近胜利</li><li>放在棋盘较为中间的位置比较好（如果棋盘是固定大小的话）</li></ol><h2 id="双人对战"><a href="#双人对战" class="headerlink" title="双人对战"></a>双人对战</h2><p>既然涉及到双人互动的话，就会涉及到协议了。就算是一个简单的五子棋对战也有协议，这里直接用json好了。由于Peertc帮我们实现了链接和数据传输，A下的子的位置直接传给B就行了。</p><p>这里与AI不同的一个地方就是，AI反应快的一笔，不是玩家下子的时候，不做屏蔽也没太大关系。但是玩家需要思考，网络有延迟，所以在上面的黑色落子和白色落子阶段都需要加上对应的屏蔽，保证不会出现该白色落子，黑色依然能下的情况。</p><p>那么，需要哪些信令呢？</p><h3 id="开一局"><a href="#开一局" class="headerlink" title="开一局"></a>开一局</h3><p>开局，这个开局由一方先行发起，发起的一方将自己所持的颜色保存，并将对方应持的颜色和开局指令交给对方，至于颜色怎么来，可以随机或者固定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selfColor = <span class="string">'black'</span>;</span><br><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'new'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        color: <span class="string">'white'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="落子"><a href="#落子" class="headerlink" title="落子"></a>落子</h3><p>开局之后，双方都将开始游戏，各自会有自己的游戏数据和状态机。他们的状态应当完全同步。其实可以把对方想象成一个有延迟的AI。落子的关键就在于位置和颜色，位置一般不会有太大问题，而颜色如果错误麻烦就大了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'drop'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        color: fiveChess.state,</span><br><span class="line">        x: x,</span><br><span class="line">        y: y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里使用的是五子棋内部的状态表明的颜色，而不是使用当前持有的颜色，就是为了防止状态机不同步导致错误。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>双方在自己或对方落子后可以自行计算是否获胜游戏结束。真正需要传输的游戏结束的信令应当表征有一方认输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'end'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这三个信令，一个对战的五子棋就完成了</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>五子棋属于逻辑比较简单的游戏，因此实现起来很好理解，难度不大。写一个这种基于网络对战游戏，设计好自动机、设计好相互交互的信令是非常重要的。</p><p>希望以后Canvas学好了，能够写出像《魂斗罗》，《雪人兄弟》，《拳皇》这样的游戏。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/">即时通信</category>
      
      
      <category domain="http://lingyu.life/tags/WebIM/">WebIM</category>
      
      <category domain="http://lingyu.life/tags/WebRTC/">WebRTC</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Canvas/">Canvas</category>
      
      <category domain="http://lingyu.life/tags/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      <category domain="http://lingyu.life/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://lingyu.life/2014/11/18/peertc-and-fivechess/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用WebRTC DataChannel在浏览器间传递数据</title>
      <link>https://lingyu.life/#/post/2014/10/21/datachannel</link>
      <guid>https://lingyu.life/#/post/2014/10/21/datachannel</guid>
      <pubDate>Mon, 20 Oct 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p><a id="more"></a><p>如果对WebRTC和DataChannel不太了解的同学，可以先阅读如下文章：</p><ul><li><a href="/#/post/2014/05/22/webrtc-data-channels">WebRTC的RTCDataChannel</a></li><li><a href="/#/post/2014/03/18/webRTC-2">使用WebRTC搭建前端视频聊天室——信令篇</a></li><li><a href="/#/post/2014/03/15/webRTC-1">使用WebRTC搭建前端视频聊天室——入门篇</a></li></ul><h2 id="老刘和老姚"><a href="#老刘和老姚" class="headerlink" title="老刘和老姚"></a>老刘和老姚</h2><p>当然服务器完全不参与其中，显然是不可能的，用户需要通过服务器上存储的信息，才能确定需要和谁建立连接。这里通过一个故事来讲述建立连接的过程：</p><h3 id="不如钓鱼去"><a href="#不如钓鱼去" class="headerlink" title="不如钓鱼去"></a>不如钓鱼去</h3><p>一些背景：</p><ul><li>老刘和老姚都住在同一个小区但不同的片区，小区很破旧，没有电话</li><li>片区相互隔离且片区门口有个保安，保安只认识自己片区的人，遇到不认识的人就需要查询凭证才能通过，而凭证需要找物业才能确定</li><li>门卫老大爷认识小区里的所有人但是不知道都住哪，有什么消息都可以在出入小区的时候代为传达</li></ul><p>现在，老刘听说老姚钓鱼技术高超，想和老姚讨论钓鱼技巧。只要老刘和老姚相互之间知道对方的门牌号以及凭证，就可以串门了:</p><ol><li>门卫老大爷认识老刘和老姚</li><li>老刘找物业确定了自己片区的出入凭证，将凭证、自己的门牌号以及意图告诉门卫老大爷，让其转交给老姚</li><li>老姚买菜归来遇到门卫老大爷，门卫老大爷将老刘的消息传达给老姚。于是老姚知道怎么去老刘家了</li><li>老姚很开心，他也找物业获取了自己小区的凭证，并将凭证、自己的门牌号等信息交给门卫老大爷，希望他传达给老刘</li><li>老刘吃早餐回来遇到门卫老大爷，老大爷把老姚的小区凭证、门牌号等信息告诉老刘，这样老刘就知道了怎么去老姚家了</li></ol><p>老刘和老姚相互之间知道了对方的门牌号和小区出入凭证，他们相互之间有什么需要交流的直接串门就行了，消息不再需要门卫老大爷来代为传达了</p><h3 id="换个角度"><a href="#换个角度" class="headerlink" title="换个角度"></a>换个角度</h3><p>我们把角色做一个映射：</p><ul><li>老刘：浏览器1</li><li>老姚：浏览器2</li><li>片区：不同网段</li><li>保安：防火墙</li><li>片区凭证：ICE candidate</li><li>物业：ICE server</li><li>门牌号：session description</li><li>门卫老大爷：server</li></ul><p>于是乎故事就变成了这样：</p><ol><li>浏览器1和浏览器2在server上注册，并保有连接</li><li>浏览器1从ice server获取ice candidate并发送给server，并生成包含session description的offer，发送给server</li><li>server发送浏览器1的offer和ice candidate给浏览器2</li><li>浏览器2发送包含session description的answer和ice candidate给server</li><li>server发送浏览器2的answer和ice candidate给浏览器1</li></ol><h2 id="礼物"><a href="#礼物" class="headerlink" title="礼物"></a>礼物</h2><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><p>老刘和老姚已经可以相互串门了，经过一段时间的交流感情越来越深。老姚的亲友送了20斤葡萄给老姚，老姚决定送10斤给老刘。老姚毕竟年事已高，不可能一次带10斤。于是乎，老姚将葡萄分成了10份，每次去老刘家串门就送一份过去。</p><p>这里可以做如下类比：</p><ol><li>10斤葡萄：一个文件（尽管文件分片没有意义，葡萄分开还可以单独吃，但是实在找不到啥好的比喻了）</li><li>分成10份：将文件分片，转成多个chunk</li><li>老姚一次只能带一斤：datachannel每次传输的数据量不宜太大（<a href="http://stackoverflow.com/questions/15435121/what-is-the-maximum-size-of-webrtc-data-channel-messages" target="_blank" rel="noopener">找到最合适的大小</a>）</li></ol><p>这其实就是通过datachannel传输文件的方式，首先将文件分片，然后逐个发送，最后再统一的进行组合成一个新的文件</p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>通过HTML5的File API可以将type为file的input选中的文件读取出来，并转换成data url字符串。这也就为我们提供了很方便的分片方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="built_in">window</span>.FileReader(file);</span><br><span class="line">reader.readAsDataURL(file);</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">event, text</span>) </span>&#123;</span><br><span class="line">    chunkify(event.target.result);<span class="comment">//将数据分片</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>通过datachannel发送的分片数据，我们需要将其进行组合，由于是data url字符串，在接收到所有包之后进行拼接就可以了。拼接完成后就得到了一个文件完整的data url字符串，那么我们如何将这个字符串转换成文件呢？</p><h4 id="方案一：直接跳转下载"><a href="#方案一：直接跳转下载" class="headerlink" title="方案一：直接跳转下载"></a>方案一：直接跳转下载</h4><p>既然是个dataurl，我们直接将其赋值给<code>window.location.href</code>自然可以下载，但是这样下载是没法设定下载后的文件名的，这想一想都蛋疼</p><h4 id="方案二：通过a标签下载"><a href="#方案二：通过a标签下载" class="headerlink" title="方案二：通过a标签下载"></a>方案二：通过a标签下载</h4><p>这个原理和跳转下载类似，都是使用dataurl本身的特性，通过创建一个a标签，将dataurl字符串赋值给href属性，然后使用download确定下载后的文件名，就可以完成下载了。但是很快又有新问题了，稍微大一点的文件下载的时候页面崩溃了。这是因为dataurl有<a href="http://stackoverflow.com/questions/695151/data-protocol-url-size-limitations" target="_blank" rel="noopener">大小限制</a></p><h4 id="方案三：blob"><a href="#方案三：blob" class="headerlink" title="方案三：blob"></a>方案三：blob</h4><p>其实可以通过给a标签创建blob url的方式来进行下载，这个没有大小限制。但是我们手上是dataurl，所以需要先进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span>(<span class="params">dataURI, dataTYPE</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> binary = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]),</span><br><span class="line">        array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; binary.length; i++) array.push(binary.charCodeAt(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(array)], &#123;</span><br><span class="line">        type: dataTYPE</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得blob后，我们就可以通过URL API来下载了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">a.style = <span class="string">"display: none"</span>;</span><br><span class="line"><span class="keyword">var</span> blob = dataURItoBlob(data, <span class="string">'octet/stream'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">a.href = url;</span><br><span class="line">a.download = filename;</span><br><span class="line">a.click();</span><br><span class="line">!moz &amp;&amp; <span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br><span class="line">a.parentNode.removeChild(a);</span><br></pre></td></tr></table></figure><p>这里有几个点：</p><ol><li>datachannel其实是可以直接传送blob的，但是只有ff支持，所以传data url</li><li>chrome下载是直接触发的，不会进行询问，firefox会先询问后下载，在询问过程中如果执行了<code>revokeObjectURL</code>，下载就会取消，囧</li></ol><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>如我们所知，WebRTC最有特点的地方其实是可以传输getUserMedia获得的视频、音频流，来实现视频聊天。但事实上我们的使用习惯来看，一般人不会一开始就打开视频聊天，而且视频聊天时很消耗内存的（32位机上一个连接至少20M左右好像，也有可能有出入）。所以常见的需求是，先建立一个包含datachannel的连接用于传输数据，然后在需要时升级成可以传输视频、音频。</p><p>看看我们之前传输的session description，它其实来自<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1" target="_blank" rel="noopener">Session Description Protocol</a>。可以看到wiki上的介绍：</p><blockquote><p>The Session Description Protocol (SDP) is a format for describing streaming media initialization parameters.</p></blockquote><p>这意味着什么呢？我们之前建立datachannel是没有加视频、音频流的，而这个流的描述是写在SDP里面的。现在我们需要传输视频、音频，就需要添加这些描述。所以就得重新获得SDP，然后构建offer和answer再传输一次。传输的流程和之前一样，没什么区别。但这一次，我们不需要传输任何的ice candidate，这里我曾经<a href="http://stackoverflow.com/questions/26469794/webrtc-add-ice-candidate-error-on-established-peerconnection" target="_blank" rel="noopener">遇到了坑</a>，经过国外大大的点拨才明白过来。</p><blockquote><p>from mattm: You do not need to send ICE candidates on an already established peer connection. The ICE candidates are to make sure the two peers can establish a connection through their potential NAT and firewalls. If you can already send data on the peer connection, ICE candidates will not do anything.</p></blockquote><h2 id="Peertc"><a href="#Peertc" class="headerlink" title="Peertc"></a>Peertc</h2><p>我将datachannel和websocket组合，实现了一个构建点对点连接的库Peertc，它提供非常简洁的方式来建立连接和发送数据、文件和视频/音频流，详情见<a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="noopener">github</a>。走过路过的记得star一下哦，有什么bug也非常希望能够提出来。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>WebRTC的点对点方式能够运用在很多场景：</p><ul><li>如web qq这种Web IM工具，这就不说了</li><li>如象棋这种双人对战游戏，每一步的数据服务器时不关心的，所以完全可以点对点发送</li><li>一对一在线面试、在线教育，这其实是即时通信的一个业务方向</li><li>视频裸（），当我没说</li></ul>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/">即时通信</category>
      
      
      <category domain="http://lingyu.life/tags/WebSocket/">WebSocket</category>
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/WebIM/">WebIM</category>
      
      <category domain="http://lingyu.life/tags/WebRTC/">WebRTC</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/DataChannel/">DataChannel</category>
      
      
      <comments>http://lingyu.life/2014/10/21/datachannel/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Gulp思维 —— Gulp高级技巧</title>
      <link>https://lingyu.life/#/post/2014/10/07/getting-gulpy</link>
      <guid>https://lingyu.life/#/post/2014/10/07/getting-gulpy</guid>
      <pubDate>Mon, 06 Oct 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;本文翻译自&lt;a href=&quot;https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Getting gulpy – Advanced tips for using gulp.js&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感受过&lt;a href=&quot;http://gulpjs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gulp.js&lt;/a&gt;带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5" target="_blank" rel="noopener">Getting gulpy – Advanced tips for using gulp.js</a></strong></p><p>感受过<a href="http://gulpjs.com" target="_blank" rel="noopener">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p><a id="more"></a><h2 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务"></a>基本任务</h2><p>gulp的基本设置拥有非常友好的语法，让你能够非常方便的对文件进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./src/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(concat(<span class="string">'all.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方式能够应付绝大多数情况，但如果你需要更多的定制，很快就会遇到麻烦了。这篇将介绍这其中的一些情况并提供解决方案。</p><h2 id="流不兼容？"><a href="#流不兼容？" class="headerlink" title="流不兼容？"></a>流不兼容？</h2><p>使用gulp时，你可能会陷入“流不兼容”的问题。这主要是因为常规流和Vinyl文件对象有差异，或是使用了仅支持buffer（不支持流）库的gulp插件与常规流不兼容。</p><p>比如说，你不能直接将常规流与gulp和（或）gulp插件相连。我们创建一个可读流，并尝试使用<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-rename" target="_blank" rel="noopener">gulp-rename</a>来进行转换，将最后得到的内容交给<code>gulp.dest()</code>。下面就是个错误的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line">gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.createReadStream(<span class="string">'app.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(rename(<span class="string">'bundle.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么我们不能将可读流和一个gulp插件直接相连？gulp难道不就是一个基于流的构建系统吗？是的，但上面的例子忽视了一个事实，gulp插件期望的输入是Vinyl文件对象。你不能直接将一个可读流与一个以Vinyl文件对象作为输入的函数（插件）相连</p><h2 id="Vinyl文件对象"><a href="#Vinyl文件对象" class="headerlink" title="Vinyl文件对象"></a>Vinyl文件对象</h2><p>gulp使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank" rel="noopener">vinyl-fs</a>，它实现了<code>gulp.src()</code>和<code>gulp.dest()</code>方法。vinyl-fs使用<a href="https://github.com/wearefractal/vinyl" target="_blank" rel="noopener">vinyl</a>文件对象——一种“虚拟文件格式”。如果我们需要将gulp和（或）gulp插件与常规的可读流一起使用，我们就需要先把可读流转换为vinyl。</p><p>使用<a href="https://www.npmjs.org/package/vinyl-source-stream" target="_blank" rel="noopener">vinyl-source-stream</a>是个不错的选择，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),</span><br><span class="line">    marked = <span class="built_in">require</span>(<span class="string">'gulp-marked'</span>);</span><br><span class="line">fs.createReadStream(<span class="string">'*.md'</span>)</span><br><span class="line">    .pipe(source())</span><br><span class="line">    .pipe(marked())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure><p>另外一个例子首先通过<a href="http://browserify.org" target="_blank" rel="noopener">browserify</a>封装并最终将其转换为一个vinyl流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);</span><br><span class="line">gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> browserify(<span class="string">'./src/app.js'</span>)</span><br><span class="line">        .bundle()</span><br><span class="line">        .pipe(source(‘bundle.min.js))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>哎呦不错哦。注意我们不再需要使用gulp-rename了，因为vinyl-source-stream创建了一个拥有指定文件名的vinyl文件实例（这样gulp.dest方法将使用这个文件名）</p><h3 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest"></a>gulp.dest</h3><p>这个gulp方法创建了一个可写流，它真的很方便。它重新使用可读流中的文件名，然后在必要时创建文件夹（使用<a href="https://www.npmjs.org/package/mkdirp" target="_blank" rel="noopener">mkdirp</a>）。在写入操作完成后，你能够继续使用这个流（比如：你需要使用gzip压缩数据并写入到其他文件）</p><h2 id="流和buffer"><a href="#流和buffer" class="headerlink" title="流和buffer"></a>流和buffer</h2><p>既然你有兴趣使用gulp，这篇文章假设你已经了解了流的基础知识。无论是buffer还是流，vinyl的虚拟文件都能包含在内。使用常规可读流时，你可以监听data事件来检测数据碎片的到来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; ...</span><br></pre></td></tr></table></figure><p>不同的是，使用<code>gulp.src()</code>会将转换成buffer的vinyl文件对象重新写入到流中。也就是说，你获得的不再是数据碎片，而是将内容转换成buffer后的（虚拟）文件。vinyl文件格式拥有一个属性来表示里面是buffer还是流，gulp默认使用buffer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, file.contents.length);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">2493109</span> bytes <span class="keyword">of</span> data</span><br></pre></td></tr></table></figure><p>这个例子说明了在文件被完整加入到流之前数据会被转换成buffer。</p><h2 id="Gulp默认使用buffer"><a href="#Gulp默认使用buffer" class="headerlink" title="Gulp默认使用buffer"></a>Gulp默认使用buffer</h2><p>尽管更加推荐使用流中的数据，但很多插件的底层库使用的是buffer。有时候必须使用buffer，因为转换需要完整的文件内容。比如文本替换和正则表达式的情形。如果使用数据碎片，将会面临匹配失败的风险。同样，像<a href="http://lisperator.net/uglifyjs" target="_blank" rel="noopener">UglifyJS</a>和<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur Compiler</a>需要输入完整的文件内容（至少需要语法完整的JavaScript字符串）</p><p>这就是为什么gulp默认使用转换成buffer的流，因为这更好处理。</p><p>使用转换成buffer的流也有缺点，处理大文件时将非常低效。文件必须完全读取，然后才能被加入到流中。那么问题来了，文件的尺寸多大才会降低性能？对于普通的文本文件，比如JavaScript、CSS、模板等等，这些使用buffer开销非常小。</p><p>在任何情况下，如果将buffer选项设为false，你可以告诉gulp流中传递的内容究竟是什么。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'/usr/share/dict/words'</span>, &#123;<span class="attr">buffer</span>: <span class="literal">false</span>&#125;).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stream = file.contents;</span><br><span class="line">    stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; ...</span><br></pre></td></tr></table></figure><h2 id="从流到buffer"><a href="#从流到buffer" class="headerlink" title="从流到buffer"></a>从流到buffer</h2><p>由于所需的输入（输出）流和gulp插件不尽相同，你可能需要将流转换成buffer（反之亦然）。之前已经有过介绍，大多数插件使用buffer（尽管他们的一部分也支持流）。比如<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-traceur" target="_blank" rel="noopener">gulp-traceur</a>。你可以通过<a href="https://www.npmjs.org/package/gulp-buffer" target="_blank" rel="noopener">gulp-buffer</a>来转换成buffer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),</span><br><span class="line">    buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">fs.createReadStream(<span class="string">'./src/app.js'</span>)</span><br><span class="line">    .pipe(source(<span class="string">'app.min.js'</span>))</span><br><span class="line">    .pipe(buffer())</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure><p>或者另一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),</span><br><span class="line">    traceur = <span class="built_in">require</span>(<span class="string">'gulp-traceur'</span>);</span><br><span class="line">gulp.src(<span class="string">'app.js'</span>, &#123;<span class="attr">buffer</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">    .pipe(buffer())</span><br><span class="line">    .pipe(traceur())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure><h2 id="将buffer转换为流"><a href="#将buffer转换为流" class="headerlink" title="将buffer转换为流"></a>将buffer转换为流</h2><p>你也可以使用<a href="https://www.npmjs.org/package/gulp-streamify" target="_blank" rel="noopener">gulp-streamify</a>或<a href="https://www.npmjs.org/package/gulp-stream" target="_blank" rel="noopener">gulp-stream</a>将一个使用buffer的插件的输出转化为一个可读流。这样处理之后，跟在使用buffer的插件后面的（只能）使用流的插件也能正常工作了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wrap = <span class="built_in">require</span>(<span class="string">'gulp-wrap'</span>),</span><br><span class="line">    streamify = <span class="built_in">require</span>(<span class="string">'gulp-streamify'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    gzip = <span class="built_in">require</span>(<span class="string">'gulp-gzip'</span>);</span><br><span class="line">gulp.src(<span class="string">'app.js'</span>, &#123;<span class="attr">buffer</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">    .pipe(wrap(<span class="string">'(function()&#123;&lt;%= contents %&gt;&#125;());'</span>))</span><br><span class="line">    .pipe(streamify(uglify()))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>))</span><br><span class="line">    .pipe(gzip())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br></pre></td></tr></table></figure><h2 id="不是所有事都需要插件"><a href="#不是所有事都需要插件" class="headerlink" title="不是所有事都需要插件"></a>不是所有事都需要插件</h2><p>虽然已经有很多使用且方便的插件，很多任务以及转换可以不使用插件而轻易完成。插件会带来一些问题，你需要依赖一个额外的npm模块，一个插件接口和（反应迟钝？）的维护者，等等。如果一个任务可以不使用插件而使用原生模块就能轻易完成，绝大多数情况下，都建议不要使用插件。能够理解上面所说的概念，并能够在所处的情况下做出正确的决定，这点非常重要。下面来看一些例子：</p><h3 id="vinyl-source-stream"><a href="#vinyl-source-stream" class="headerlink" title="vinyl-source-stream"></a>vinyl-source-stream</h3><p>之前的例子中，我们已经直接使用了browserify，而不是使用（现已加入黑名单）<a href="https://www.npmjs.org/package/gulp-browserify" target="_blank" rel="noopener">gulp-browserify</a>插件。这里的关键是使用vinyl-source-stream（或类似的库）进行加工，来将常规的可读流输入使用vinyl的插件。</p><h3 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h3><p>另一个例子就是基于字符串的变换。这里有一个非常基础的插件，直接使用了vinyl的buffer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">modifier</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> through2.obj(<span class="function"><span class="keyword">function</span>(<span class="params">file, encoding, done</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = modifier(<span class="built_in">String</span>(file.contents));</span><br><span class="line">        file.contents = <span class="keyword">new</span> Buffer(content);</span><br><span class="line">        <span class="keyword">this</span>.push(file);</span><br><span class="line">        done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像这样使用这个插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'modify'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'app.js'</span>)</span><br><span class="line">        .pipe(modify(version))</span><br><span class="line">        .pipe(modify(swapStuff))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">version</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.replace(<span class="regexp">/__VERSION__/</span>, pkg.version);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapStuff</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2, $1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个插件并没有完成，而且也不能处理流（<a href="https://gist.github.com/webpro/a9a9e14d291c021894b3" target="_blank" rel="noopener">完整版本</a>）。然而，这个例子说明，可以很轻易地通过一些基本函数来创建新的变换。<a href="https://www.npmjs.org/package/through2" target="_blank" rel="noopener">through2</a>库提供了非常优秀的Node流封装，并且允许像上面那样使用转换函数。</p><h2 id="任务流程"><a href="#任务流程" class="headerlink" title="任务流程"></a>任务流程</h2><p>如果你需要去运行一些定制化或动态的任务，了解gulp所使用的<a href="https://www.npmjs.org/package/orchestrator" target="_blank" rel="noopener">Orchestrator</a>模块会很有帮助。<code>gulp.add</code>方法其实就是<code>Orchestrator.add</code>方法（事实上所有的方法都是从Orchestrator继承而来的）。但为什么你需要这个？</p><ul><li>你不想“私有任务”（比如：不暴露给命令行工具）弄乱gulp任务列表。</li><li>你需要更多的动态的和（或）可重用的子任务。</li></ul><h2 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h2><p>请注意，gulp（或grunt）并不总是当前情境下的最佳工具。比如说，如果你需要拼接并使用uglify压缩一系列的JavaScript文件，又或者你需要编译一些SASS文件，你可能需要考虑使用makefile或npm run，通过命令行来实现。减少依赖，减少配置，才是正解。</p><p>阅读<a href="http://substack.net/task_automation_with_npm_run" target="_blank" rel="noopener">通过npm run来实现任务自动化</a>来了解更多信息。你需要明确通过一系列的“自定义构建”后需要得到什么，而哪个工具最合适。</p><p>不过，我觉得gulp是一个伟大的构建系统，我很喜欢使用它，它展现了Node.js中流的强大。</p><p>希望这些能够帮到你！如果你有任何反馈或其他提议，请在评论中告诉我，或者加我的twitter：<a href="https://twitter.com/webprolific" target="_blank" rel="noopener">@webprolific</a></p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Gulp/">Gulp</category>
      
      
      <comments>http://lingyu.life/2014/10/07/getting-gulpy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Gulp -- 项目的愿景、过去和将来</title>
      <link>https://lingyu.life/#/post/2014/10/06/gulp-vision-history-future</link>
      <guid>https://lingyu.life/#/post/2014/10/06/gulp-vision-history-future</guid>
      <pubDate>Sun, 05 Oct 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;本文翻译自&lt;a href=&quot;https://medium.com/@contrahacks/gulp-3828e8126466&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gulp – The vision, history, and future of the project&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466" target="_blank" rel="noopener">gulp – The vision, history, and future of the project</a></strong></p><p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p><a id="more"></a><p>下面我们就来介绍gulp背后的各个部分以及它们所起到的作用。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是一种将多个小的变换操作进行组合，连接成管道的一种方式。你将数据丢入管道顶部，它将下落并穿过所有的变换，最后在底部得到你想要的内容。流系统的灵活性能够很好地解决文件变换需求。</p><p>想获得更多关于流的信息，请查阅substack的<a href="https://github.com/substack/stream-handbook" target="_blank" rel="noopener">流操作手册</a></p><h2 id="Vinyl"><a href="#Vinyl" class="headerlink" title="Vinyl"></a>Vinyl</h2><p><a href="https://github.com/wearefractal/vinyl" target="_blank" rel="noopener">Vinyl</a>是一个用来描述文件的简单元数据对象。当你想要使用一个文件时，首先映入脑海的是文件的两个属性：<a href="https://github.com/wearefractal/vinyl/blob/master/index.js#L18-L25" target="_blank" rel="noopener">路径和内容</a>。这两个属性就是一个Vinyl对象的主要属性。这里的文件并不一定是指你的文件系统里的文件。你在S3、FTP、Dropbox、Box、CloudThingly.io或者其他服务上的文件，一样可以使用Vinyl来描述。</p><h2 id="Vinyl-Adapters（Vinyl适配器）"><a href="#Vinyl-Adapters（Vinyl适配器）" class="headerlink" title="Vinyl Adapters（Vinyl适配器）"></a>Vinyl Adapters（Vinyl适配器）</h2><p>既然Vinyl提供了一个清晰的方法用来描述文件，我们现在还需要找到访问这些文件的方式。每一种文件源我们都需要一个“Vinyl适配器”。一个Vinyl适配器只需要暴露三个方法：<code>.src(globs)</code>、<code>.dest(folder)</code>、和一个<code>.watch(globs, fn)</code>。src流负责产生文件对象，而dest流负责消费这些文件对象。</p><p>表面上看人们已经理解了“gulp插件”(一个transform形式的流)的概念，但Vinyl适配器的理念却没有被广泛传播。除非自己开发一些适配器，否则无法得知适配器是如何引用文件源中的内容。。通过Vinyl适配器来实现gulp，并将其作为一个开发工具的想法非常奇妙。</p><h3 id="vinyl-fs"><a href="#vinyl-fs" class="headerlink" title="vinyl-fs"></a>vinyl-fs</h3><p>如果你使用gulp，你已经使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank" rel="noopener">vinyl-fs</a>模块。它是用来适配本地文件系统的适配器。</p><h3 id="vinyl-s3"><a href="#vinyl-s3" class="headerlink" title="vinyl-s3"></a>vinyl-s3</h3><p>vinyl-s3尚不存在，但<a href="https://github.com/nkostelnik/gulp-s3" target="_blank" rel="noopener">gulp-s3</a>已经实现了。它无法提供所有的功能，但它是了一个不错的权宜方案。</p><h2 id="Orchestrator"><a href="#Orchestrator" class="headerlink" title="Orchestrator"></a>Orchestrator</h2><p>在写这篇文章时，目前的任务系统是<a href="https://github.com/orchestrator/orchestrator" target="_blank" rel="noopener">Orchestrator</a> 0.3。Orchestrator提供了简单的方式去定义任务和依赖，并能够在依赖树为基础的前提下以最大并发数去与并发执行这些任务。Orchestrator虽然工作良好，但它复杂的依赖管理给用户带来不小的麻烦。Orchestrator为了配合gulp的理念而做了巨大的调整：更加轻量、低复杂度，以及可组合的功能性API。</p><p>这里简要介绍一下gulp 4带来的变化：</p><ol><li>你可以任意指定任务顺序，并行/串行的任意组合都随心所欲。只有想不到，没有做不到</li><li>API将非常流畅和友好</li><li>代码更加简洁</li></ol><p>非常感谢Blaine Bublitz在这方面积极的努力。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>实话告诉你：gulp现在的错误处理很烂。我从不期望能从报错信息中获得一点有用的信息。使用gulp的过程中，你可能会遭遇两种错误：</p><h3 id="任务失败"><a href="#任务失败" class="headerlink" title="任务失败"></a>任务失败</h3><p>watch时出现任务失败，内部将会一团糟，然后线程会退出，具体的退出方式要取决你如何启动这个任务。这种情况非常糟糕，完全不应该发生，在新的任务系统中将对这些进行修复。</p><h3 id="管道失败"><a href="#管道失败" class="headerlink" title="管道失败"></a>管道失败</h3><p>标准的流在遭遇错误时仅仅会停止工作。而像linter（代码风格检测）这样的任务，问题就来了。我想看到所有的代码风格提示，而不只是第一个文件里的那些。技术上其实是因为unpipe事件。本质上看，当一个流遇到错误，它将会触发<strong>unpipe</strong>事件，这个事件将告诉其他流不再向它写入数据。目前有一些hack的解决方法如gulp-plumber，可以作为权宜之计，但我很高兴的说，我将会把这些集成到gulp核心之中去。</p><p>这些问题我会在下个release版本最优先解决。</p><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><p>从一个局外人的角度来看，人们都能参与到这场文件转换工具的战斗之中，实在有些疯狂。虽然外人看来可能有些无趣，但成为这个激情小组的一部分绝对令人振奋。我很自豪社区能够接纳这个工具并对人们的日常生活带来帮助。</p><h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>想要跟踪gulp 4的进展，你可以在github上查看<a href="https://github.com/gulpjs/gulp/issues?milestone=1&state=open" target="_blank" rel="noopener">里程碑</a></p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Gulp/">Gulp</category>
      
      
      <comments>http://lingyu.life/2014/10/06/gulp-vision-history-future/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>koa-anywhere</title>
      <link>https://lingyu.life/#/post/2014/09/24/koa-anywhere</link>
      <guid>https://lingyu.life/#/post/2014/09/24/koa-anywhere</guid>
      <pubDate>Tue, 23 Sep 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近写了一个快速启动静态文件服务器的NodeJs包&lt;a href=&quot;https://github.com/LingyuCoder/koa-anywhere&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;koa-anywhere&lt;/a&gt;，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere" target="_blank" rel="noopener">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p><a id="more"></a><h1 id="koa-anywhere"><a href="#koa-anywhere" class="headerlink" title="koa-anywhere"></a>koa-anywhere</h1><p>通过一条命令，将当前目录变成一个静态文件服务器</p><p>需要Node版本：&gt;= 0.11.13</p><h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g koa-anywhere</span><br></pre></td></tr></table></figure><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>只需一条简单的命令<code>ka</code>就可以启动一个静态文件服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;想要共享的目录&gt;</span><br><span class="line">$ ka</span><br></pre></td></tr></table></figure><h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>通过<code>-p &lt;端口号&gt;</code>或者<code>--port &lt;端口号&gt;</code>来指定静态文件服务器的端口</p><p>默认端口为<code>3000</code></p><h3 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h3><p>通过<code>-d &lt;层级数&gt;</code>或者<code>--deep &lt;层级数&gt;</code>来确定静态文件需要显示的文件层级，超过层级的文件不显示</p><p>默认层级数为<code>3</code></p><h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h3><p>通过<code>-s</code>或者<code>--silent</code>来决定是否显示日志</p><p>默认为<code>false</code>，也就是显示日志</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/NodeJs/">NodeJs</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/ES6/">ES6</category>
      
      <category domain="http://lingyu.life/tags/koa/">koa</category>
      
      
      <comments>http://lingyu.life/2014/09/24/koa-anywhere/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>学前端的一点总结</title>
      <link>https://lingyu.life/#/post/2014/09/22/learn-fe</link>
      <guid>https://lingyu.life/#/post/2014/09/22/learn-fe</guid>
      <pubDate>Sun, 21 Sep 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近&lt;a href=&quot;https://github.com/qiu-deqing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qiu&lt;/a&gt;开了一个&lt;a href=&quot;https://github.com/qiu-deqing/FE-learning/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FE学习经验介绍&lt;/a&gt;，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近<a href="https://github.com/qiu-deqing" target="_blank" rel="noopener">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md" target="_blank" rel="noopener">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p><a id="more"></a><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li>chrome dev tools：前端开发调试利器，着重注意几个功能：<ul><li>console（废话）</li><li>elements:元素样式调整，很常用</li><li>sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象<ul><li>watch expression：通过表达式查看当前内存中的值</li><li>call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候）</li><li>scope variables：作用域链上的变量，非常有用</li></ul></li><li>network：抓包查看每个请求，非常重要，前后端联调必备</li><li>timeline：分析渲染、js执行等等各个阶段，性能优化利器</li><li>emulation：模拟移动端环境，mobile页面开发必备</li><li>一些插件:<ul><li>liveload: 修改页面后自动刷新，不用按F5</li><li>dimensions：直接在页面上测量的利器</li><li>livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中</li><li>image tool：测量，取色</li><li>UC二维码：移动端调试扫码必备</li><li>pagespeed，YSlow：页面性能分析和优化插件</li><li>马克飞象：优秀的在线markdown编辑器，快速写周报，做记录</li></ul></li></ul></li><li>sublime text2：编码方便，插件多，速度快，性能好<ul><li>emmet：提升html编码速度必备</li><li>sublimelinter + 各种语言的lint和hint：代码纠错</li><li>一些snippets：自动补全，提升开发效率</li></ul></li><li>Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能</li><li>Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件</li><li>GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子</li><li>iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备</li><li>Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用</li><li>Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便</li></ul><h4 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h4><p>前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说</p><h5 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h5><p>JavaScript：</p><ul><li>作用域链、闭包、运行时上下文、this</li><li>原型链、继承</li><li>NodeJS基础和常用API</li></ul><p>CSS：</p><ul><li>选择器</li><li>浏览器兼容性及常见的hack处理</li><li>CSS布局的方式和原理（盒子模型、BFC、IFC等等）</li><li>CSS 3，如animation、gradient、等等</li></ul><p>HTML：</p><ul><li>语义化标签</li></ul><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>JavaScript:</p><ul><li>异步控制（Promise、ES6 generator、Async）</li><li>模块化的开发方式（AMD、CMD、KMD等等）</li><li>JavaScript解释器的一些相关知识<ul><li>异步IO实现</li><li>垃圾回收</li><li>事件队列</li></ul></li><li>常用框架使用及其原理<ul><li>jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研</li><li>AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦</li><li>underscore：优秀的工具库，方便的理解常用工具代码片段的实现</li><li>polymer/React: 组件化开发，面向未来，理解组件化开发的原理</li></ul></li></ul><p>CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理</p><ul><li>DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程</li><li>解析HTML、CSS、JavaScript时造成的阻塞</li><li>HTML5相关<ul><li>SVG及矢量图原理</li><li>Canvas开发及动画原理（帧动画）</li><li>Video和Audio</li></ul></li><li>flex box布局方式</li><li>icon fonts的使用</li></ul><p>常用NodeJs的package：</p><ul><li>koa</li><li>express</li><li>underscore</li><li>async</li><li>gulp</li><li>grunt</li><li>connect</li><li>request</li></ul><p>一些理念：</p><ul><li>响应式Web</li><li>优雅降级、渐进增强</li><li>don`t make me think</li><li>网页可用性、可访问性、其中的意义</li><li>SEO搜索引擎优化，了解搜索引擎的原理</li><li>SPA的好处和问题</li></ul><p>性能优化：</p><ul><li>减少请求数量（sprite、combo）</li><li>善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式）</li><li>减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离）</li><li>CSS的回流与重绘</li></ul><h5 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h5><ul><li>版本管理：首推Git，用过Git都不会想用SVN了<ul><li>Git：本地版本管理的机制</li><li>SVN：远程中心的版本管理机制</li></ul></li><li>自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并<ul><li>Gulp：基于流构建，速度快、模块质量好</li><li>Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高</li></ul></li><li>预处理和模板引擎<ul><li>less：语法简单，但功能有限</li><li>jade、ejs、velocity等模板引擎，各有各的长处</li><li>coffee：python工程师最爱，我没用过</li></ul></li><li>环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了<ul><li>本地代理：ihosts</li></ul></li><li>自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果<ul><li>jasmine</li><li>mocha</li></ul></li><li>生态系统<ul><li>npm</li><li>bower</li><li>spm</li></ul></li><li>搭建一个属于自己的博客<ul><li>git pages</li><li>hexo</li><li>jekyll</li></ul></li></ul><h5 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h5><ul><li>Web Componets：面向未来的组件化开发方式<ul><li>HTML模板</li><li>Shadow DOM</li><li>Custom Elements</li><li>HTML Import</li></ul></li><li>移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方</p><ul><li><strong>对于业务的思考</strong>：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务</li><li>交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目</li><li>知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录</li><li>对新技术的渴望，以及敢于尝试</li></ul><h4 id="入门书"><a href="#入门书" class="headerlink" title="入门书"></a>入门书</h4><p>入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书：</p><ul><li>《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看</li><li>《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助</li><li>《编写可维护的JavaScript》和：</li><li>《Node.js开发指南》：不错的Nodejs入门书籍</li><li>《深入浅出Node.js》：Nodejs进阶书籍，必备</li><li>《JavaScript异步编程》：理解JS异步的编程理念</li><li>《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书</li><li>《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西</li><li>《Don`t make me think》：网页设计的理念，了解用户行为，非常不错</li><li>《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题</li><li>《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习</li><li>《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助</li><li>《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识</li><li>《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想</li><li>《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门</li></ul><h4 id="一些不错的网站"><a href="#一些不错的网站" class="headerlink" title="一些不错的网站"></a>一些不错的网站</h4><ul><li><a href="https://github.com" target="_blank" rel="noopener">github</a>：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习</li><li><a href="http://codepen.io" target="_blank" rel="noopener">codepen</a>：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件</li><li><a href="http://www.echojs.com" target="_blank" rel="noopener">echojs</a>：快速了解js新资讯的网站</li><li><a href="http://stackoverflow.com" target="_blank" rel="noopener">stackoverflow</a>和<a href="segmentfault.com">segmentfault</a>：基本上各种问题都能在上面获得解答</li><li><a href="https://developers.google.com/web/fundamentals" target="_blank" rel="noopener">google web fundamentals</a>：每篇文章都适合仔细阅读</li><li><a href="http://www.staticfile.org" target="_blank" rel="noopener">static files</a>：开放的CDN，很好用</li><li><a href="http://www.iconfont.cn" target="_blank" rel="noopener">iconfont</a>：阿里的矢量图标库，非常不错，支持CDN而且支持项目</li><li><a href="http://www.html5rocks.com" target="_blank" rel="noopener">html5 rocks</a>: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章</li><li><a href="http://css-tricks.com" target="_blank" rel="noopener">css tricks</a>：如何活用CSS，以及了解CSS新特性，这里可以满足你</li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.general" target="_blank" rel="noopener">JavaScript 秘密花园</a> JavaScript初学必看，非常不错</li><li><a href="http://www.w3cplus.com" target="_blank" rel="noopener">w3cplus</a>：一个前端学习的网站，里面的文章质量都挺不错的</li><li><a href="http://nodeschool.io" target="_blank" rel="noopener">node school</a>：一个不错的node学习网站</li><li><a href="http://pcottle.github.io/learnGitBranching/?demo" target="_blank" rel="noopener">learn git branch</a>：一个git学习网站，交互很棒</li><li><a href="http://www.html-js.com" target="_blank" rel="noopener">前端乱炖</a>：一个前端文章分享的社区，有很多优秀文章</li><li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式</a>：一个正则表达式入门教程，非常值得一看</li><li><a href="http://www.ruanyifeng.com/blog" target="_blank" rel="noopener">阮一峰的博客</a>和<a href="http://www.zhangxinxu.com/wordpress" target="_blank" rel="noopener">张鑫旭的博客</a>：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源</li><li>各路大牛的博客：这个太多了，就不贴了，知乎上有很全的</li><li>各种规范的官方网站，不懂得时候读规范</li></ul><h4 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h4><p>以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和<a href="http://www.w3school.com.cn" target="_blank" rel="noopener">W3C School</a>上的教程，以及一些前端博客，如<a href="http://www.cnblogs.com/TomXu" target="_blank" rel="noopener">汤姆大叔的博客</a>。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了…</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/">思考总结</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      <category domain="http://lingyu.life/tags/%E6%80%9D%E8%80%83/">思考</category>
      
      
      <comments>http://lingyu.life/2014/09/22/learn-fe/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>细说Generator</title>
      <link>https://lingyu.life/#/post/2014/07/29/generator</link>
      <guid>https://lingyu.life/#/post/2014/07/29/generator</guid>
      <pubDate>Mon, 28 Jul 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p><a id="more"></a><p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="/#/post/post/2014/3/28/js-basis">JavaScript一些基础知识简介</a></p><h1 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h1><p>generator函数执行的时候，会进行如下动作：</p><ol><li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li><li>创建一个generator对象，其有如下值：<ul><li>Scope：新建的作用域链</li><li>Code：generator function内部的代码</li><li>ExecutionContext：EC，目前值为null</li><li>State：”newborn”</li><li>Handler：默认的generator的处理器</li></ul></li></ol><p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p><h1 id="yield的行为"><a href="#yield的行为" class="headerlink" title="yield的行为"></a>yield的行为</h1><p>当执行到<code>yield e</code>时：</p><ol><li>计算出表达式e的值</li><li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li><li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li><li>从EC栈弹出当前的EC</li><li>返回(normal, 1中的结果值, null)</li></ol><p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p><p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p><h1 id="return行为"><a href="#return行为" class="headerlink" title="return行为"></a>return行为</h1><p>当执行到<code>return e</code>时：</p><ol><li>计算出表达式e的值</li><li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li><li>将这个generator对象的状态修改为closed</li><li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li><li>throw这个对象</li></ol><p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p><h1 id="Generator对象的私有属性"><a href="#Generator对象的私有属性" class="headerlink" title="Generator对象的私有属性"></a>Generator对象的私有属性</h1><ul><li>prototype：Object.prototype</li><li>code：generator函数的函数体</li><li>ExecutionContext：内部代码运行使用的EC</li><li>Scope：作用域链</li><li>Handler：标准的generator句柄</li><li>State：newborn、executing、suspended、closed</li><li>Send：看内部方法部分</li><li>Throw：看内部方法部分</li><li>Close：看内部方法部分</li></ul><h1 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h1><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.send，传入一个undefined</li><li>返回结果</li></ol><p>调用私有send方法</p><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><p>send方法允许指定一个值，作为上一次yield的返回值</p><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.send，传入当前第一个参数</li><li>返回结果</li></ol><p>同样是调用私有send方法，不过传入了参数</p><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.throw，传入当前第一个参数</li><li>返回结果</li></ol><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>调用close方法可以直接以当前的value作为Generator的返回值</p><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.close，不传入任何参数</li><li>返回结果</li></ol><h2 id="iterate"><a href="#iterate" class="headerlink" title="iterate"></a>iterate</h2><p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p><h1 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h1><ul><li>newborn：Code不为null，EC为null</li><li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li><li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li><li>closed：Code为null，EC为null</li></ul><p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p><p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p><p>当然也可以通过close方法，手动修改状态为closed</p><h1 id="内部方法"><a href="#内部方法" class="headerlink" title="内部方法"></a>内部方法</h1><h2 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h2><ol><li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li><li>如果state为newborn<ol><li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li><li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li><li>将这个EC压入EC栈中</li><li>执行generator中的代码，并返回或得到的结果</li></ol></li><li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li></ol><p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p><p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p><p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p><h2 id="throw-1"><a href="#throw-1" class="headerlink" title="throw"></a>throw</h2><ol><li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li><li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li><li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li></ol><p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p><h2 id="close-1"><a href="#close-1" class="headerlink" title="close"></a>close</h2><ol><li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li><li>如果state已经是closed了，那直接return就好</li><li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li><li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li></ol><p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p><h2 id="Resume-EC-completionType-V"><a href="#Resume-EC-completionType-V" class="headerlink" title="Resume(EC, completionType, V)"></a>Resume(EC, completionType, V)</h2><ol><li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li><li>从EC通过currentGenerator获取单签generator对象</li><li>设置当前作用域链为当前generator对象的作用域链</li><li>继续执行代码，并根据completionType做相应的处理</li></ol><h1 id="NodeJs上的不同"><a href="#NodeJs上的不同" class="headerlink" title="NodeJs上的不同"></a>NodeJs上的不同</h1><p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank" rel="noopener">harmony generators ES Wiki</a></p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/NodeJs/">NodeJs</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/ES6/">ES6</category>
      
      <category domain="http://lingyu.life/tags/Generator/">Generator</category>
      
      
      <comments>http://lingyu.life/2014/07/29/generator/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何写一个KISSY动画插件</title>
      <link>https://lingyu.life/#/post/2014/05/31/kissy-anime-plugin</link>
      <guid>https://lingyu.life/#/post/2014/05/31/kissy-anime-plugin</guid>
      <pubDate>Fri, 30 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做&lt;a href=&quot;http://docs.kissyui.com/1.4/docs/html/api/anim/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;anim&lt;/a&gt;，这里前辈的意思就是让我再造一个轮子，&lt;a href=&quot;http://lingyucoder.github.io/kissy-anime-plugin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DEMO页面&lt;/a&gt;，&lt;a href=&quot;https://github.com/LingyuCoder/kissy-anime-plugin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github页面&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank" rel="noopener">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin" target="_blank" rel="noopener">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank" rel="noopener">Github页面</a></p><a id="more"></a><p>目前已经有很多比较优秀的JavaScript动画实现了，比如<a href="https://github.com/sole/tween.js" target="_blank" rel="noopener">Tween.js</a>，jQuery中的animate就是在Tween的基础上做了一层封装（2.0版本是Tween，老版本的jQuery则是自己实现的动画）。这里多多少少参照了优秀动画模块的思想和内容（比如缓动函数）。</p><h2 id="CSS与JavaScript动画对比"><a href="#CSS与JavaScript动画对比" class="headerlink" title="CSS与JavaScript动画对比"></a>CSS与JavaScript动画对比</h2><p>首先需要确定为什么要开发JavaScript的动画模块，毕竟现在已经有CSS3动画了。这里先对比一下CSS动画和JavaScript动画的区别，并从中提炼出我们需要的信息</p><h3 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h3><h4 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h4><p>CSS3新增了一个<code>animation</code>属性，可以定义动画，相关的属性如下：</p><ol><li>animation-name：动画的名称，也就是定义的keyframes关键帧的名称</li><li>animation-duration：一次动画的时长</li><li>animation-timing-funciton：缓动函数，这个后面会有详细介绍</li><li>animation-delay：动画延迟时间</li><li>animation-iteration-count：动画的播放次数</li><li>animation-direction：动画时正向播放还是倒着播放</li><li>animation-play-state：动画的状态，暂停还是播放</li><li>animation-fill-mode：动画播放时间之外的状态，是否重回动画初始</li><li>animation：复合属性，上面属性合在一起的写法</li></ol><p>可以看到，这里定义了一个动画的整体属性，但并没有定义具体的样式改变。这个任务交给了<code>keyframes</code>去做。也即是说，<code>animation</code>不会单独存在，它总是通过<code>animation-name</code>关联到某个<code>keyframes</code>，这是一个多对一的关系。在<code>keyframes</code>中，具体定义了这个动画哪些样式需要改变，改变多少。</p><h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><p>另外，还有一个<code>transition</code>属性，可以定义过渡效果，相关属性如下：</p><ol><li>transition-property：需要参与过渡的属性</li><li>transition-duration 过渡的时长</li><li>transition-timing-function：过渡的缓动函数</li><li>transition-delay：过渡的延时</li></ol><p><code>transtion</code>定义的是过渡效果，所谓过渡，就是当某个样式改变时，浏览器不会立即赋予这个改变后的值，而是从初始值逐渐改变，平滑的转变成改变后的值。这样也能形成很优秀的动画效果。同时不需要与<code>keyframes</code>结合，可以自己独立存在。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>先来说说优点，CSS3的动画的效率要比JavaScript要高，这不是通过优化JavaScript代码就能逆转的。由于CSS3动画作为浏览器渲染引擎实现的一部分，相对于JavaScript动画而言，省去了JavaScript部分，直接由底层语言实现，并且其内部可由浏览器做一系列相关的优化。比如webkit，它可以专门为动画元素创建一个图层，然后将这个元素的样式转变在主线程之外运行。</p><p>但是，CSS3动画缺乏足够的控制能力，同时，如果我们动画改变的不是CSS属性（比如滚动，这也是视差滚动必须通过JavaScript实现的原因），CSS3的动画就没辙了。另外，其浏览器的兼容性也是很大问题。毕竟IE从9开始才逐渐开始实现CSS3，如果要在IE6~8中做动画效果，就得另寻他法了</p><h3 id="JavaScript动画"><a href="#JavaScript动画" class="headerlink" title="JavaScript动画"></a>JavaScript动画</h3><p>JavaScript的动画，说白了就是每隔一小段时间修改元素的CSS样式。这个间隔时间一般是1000/60ms，也就是说，每秒钟该60次，达到一秒60帧的效果。每次修改，大致需要经过如下流程：</p><ol><li>计算当前元素样式</li><li>修改元素样式</li><li>重绘元素</li></ol><p>前两部都是通过JavaScript完成，这也意味着，它不精确。如我们所知，JavaScript的定时函数<code>setTimeout</code>和<code>setInterval</code>本来就不是很精确（现在可以使用requestAnimationFrame，但老版本IE不兼容），而JavaScript运行在主线程——UI线程上，上面运行的其他任务（样式计算、布局、绘制、其他JavaScript代码等）都可能造成线程的阻塞。这也是JavaScript动画的最大弊病。</p><p>但JavaScript本身，拥有强大的控制能力，它可以随心所欲的控制动画，开始、暂停、倒放、中止、回放、单帧等等，这些JavaScript都能搞定。而像CSS动画无法做的滚动效果，JavaScript也可以轻松实现。而且，我们可以将动画扩展到IE 6~8上（当然transform还是不兼容）。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h3><p>通过参考CSS动画实现，我们也可以很容易的确定，通过实现JavaScript实现动画时，动画应该具备的属性：</p><ol><li>涉及的元素（elems）</li><li>需要改变的样式（styles）</li><li>时长（duration）</li><li>缓动函数（easing-function）</li><li>播放次数（times）</li></ol><h3 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h3><p>而控制上，我们应该实现的功能：</p><ol><li>开始（run）</li><li>暂停（pause）</li><li>暂停恢复（resume）</li><li>中止（stop）</li><li>倒放（reverse）</li><li>单帧（go）</li></ol><h3 id="动画能够改变的内容"><a href="#动画能够改变的内容" class="headerlink" title="动画能够改变的内容"></a>动画能够改变的内容</h3><p>需要能够改变的内容有：</p><ol><li>CSS样式</li><li>滚动</li></ol><h2 id="动画对象"><a href="#动画对象" class="headerlink" title="动画对象"></a>动画对象</h2><p>如之前所说，JavaScript动画，实际上就是每隔一小段时间改变元素的样式。我们可以把动画看做一个对象，其内部有这个动画相关的元素、动画的属性，并提供一系列的接口控制这个动画</p><p>所以，动画的对象大致上是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Anime</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Anime.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.resume = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.go = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>而倒放是事先定义好的，我们可以作为动画属性传入</p><p>动画最终要的，就是参与动画的元素，和需要被改变的样式及其目标值。这两者，我们是没办法通过给默认值的形式来省略的。其他的，我们可以通过给一些默认值来简化API，所以将接口设计成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Anime</span>(<span class="params">elems, styles, config</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>conifg是一个对象，剩下的可选属性都在其中定义，通过mixin的方式加入到动画对象中，还可以提供一些默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultConfig = &#123;</span><br><span class="line">    callback: noop,</span><br><span class="line">    duration: <span class="number">1500</span>,</span><br><span class="line">    reverse: <span class="literal">false</span>,</span><br><span class="line">    easing: <span class="string">"linear"</span>,</span><br><span class="line">    times: <span class="number">1</span>,</span><br><span class="line">    spend: <span class="number">0</span>,</span><br><span class="line">    state: <span class="string">"running"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里还加了一些其他属性，比如spend和state，spend实际上就是当前动画运行了多长时间，state则是动画对象当前的状态，是播放中（running），还是暂停（paused），还是结束（ended）。state结合控制来做的话，就是一个状态机：</p><ul><li>running为初始状态，可以通过pause方法，转到paused状态，也可以通过stop方法，转到ended状态</li><li>paused为暂停状态，通过resume方法，转到running状态，也可以通过stop转到ended状态</li><li>ended为终止状态，可以通过run放法进行重放，转到running状态</li></ul><h2 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h2><p>光有动画对象是不够的，我们需要对所有的动画对象进行处理，获取其中running状态的对象，每隔一小段时间，修改其状态，并绘制到页面上。这里就需要一个动画队列了，实际上也就是一个数组，里面的每个元素都是状态为running的动画对象。每隔1000/60ms就遍历一遍这个数组，更新每一个动画对象的状态，并进行绘制。</p><p>需要注意的地方是，队列中只有running状态的对象，也就是说，如果队列中没有元素，那么就不需要每隔一段时间去遍历了。另外，如果有动画运行结束，变成不是running状态，那么需要从动画队列中移除</p><p>所以，队列首先得实现相关的添加删除操作，注意去重：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animeQueue = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAnime</span>(<span class="params">anime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.indexOf(anime, animeQueue) === <span class="number">-1</span>) &#123;</span><br><span class="line">        animeQueue.push(anime);</span><br><span class="line">        checkRunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteAnime</span>(<span class="params">anime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = S.indexOf(anime, animeQueue);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        animeQueue.splice(index, <span class="number">1</span>);</span><br><span class="line">        checkRunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，还有一个心跳函数，用于每隔一段时间遍历动画队列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pulse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deleteIndex = [],</span><br><span class="line">        i, m, tmp;</span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        S.each(animeQueue, <span class="function"><span class="keyword">function</span>(<span class="params">anime, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (anime.state === <span class="string">"running"</span>) &#123;</span><br><span class="line">                anime.go();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deleteIndex.push(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (i = deleteIndex.length; i--;) &#123;</span><br><span class="line">            animeQueue.splice(deleteIndex[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dealing = <span class="literal">false</span>;</span><br><span class="line">        checkRunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkRunning函数，来决定下一帧，是否需要运行，如果队列中没有动画对象了，自然不需要运行了，否则就要继续遍历动画队列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkRunning</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animeQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        running = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dealing) &#123;</span><br><span class="line">            dealing = <span class="literal">true</span>;</span><br><span class="line">            requestAnimationFrame(pulse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">        dealing = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓动函数"><a href="#缓动函数" class="headerlink" title="缓动函数"></a>缓动函数</h2><p>缓动函数的说明和教程网上还是比较多的，说白了就是一个进度的映射。一般都是使用一些现有的缓动函数，我直接从Tween中把它的缓动函数扒了出来…</p><h2 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h2><p>动画可以理解为三个问题，从什么地方开始，经过什么样的过程，到什么地方去。我们可以通过构建动画对象时传入的styles来确定需要修改的样式，以及样式动画最终的目标值。这个目标值可以是绝对的，比如<code>width: 400px</code>，就是要修改宽度到400像素，但也可以相对的，比如<code>width: +=200px</code>，在原有基础上增大200像素的宽度。我们需要确定元素样式的起始值、绝对的目标值，才能算出某个时间点的中间值，并将中间值赋予给元素。所以，样式的处理应该包括四个部分：</p><ol><li>从元素获取样式的起始值（从什么地方开始）</li><li>获取样式的绝对目标值，如果传入的是相对值，那么需要通过起始值来计算的处绝对目标值（到什么地方去）</li><li>计算当前时间点的中间值（经过怎样的过程）</li><li>向元素赋予计算出来的中间值（经过怎样的过程）</li></ol><p>后两个一个是计算，一个是展示，都属于过程内容。可以把这四个部分抽象成四个方法，分别是获取、解析、计算、赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCSS</span>(<span class="params">elem, style</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].get) &#123;</span><br><span class="line">        val = hooks[style].get(elem, style);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = hooks._default.get(elem, style);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parseCSS(val, style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseCSS</span>(<span class="params">val, style, from</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].parse) &#123;</span><br><span class="line">        <span class="keyword">return</span> hooks[style].parse(val, <span class="keyword">from</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hooks._default.parse(val, <span class="keyword">from</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeCSS</span>(<span class="params">style, from, to, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].compute) &#123;</span><br><span class="line">        <span class="keyword">return</span> hooks[style].compute(<span class="keyword">from</span>, to, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hooks._default.compute(<span class="keyword">from</span>, to, pos);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignCSS</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].assign) &#123;</span><br><span class="line">        <span class="keyword">return</span> hooks[style].assign(elem, style, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hooks._default.assign(elem, style, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，可以看到很多hooks，阅读过jQuery源码的不会对这种方式陌生。钩子是为特别样式提供特别处理，如果不需要通过钩子进行处理，直接使用_default提供的默认处理方式就行了</p><h2 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h2><p>一般的属性，可以通过<code>Dom.css</code>很轻松的获取起始值并计算出绝对目标值，但有一些则不然，这里列三个特例</p><h3 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h3><p>如color、background等，这些我们应该为其提供渐变，但无论是用户传入的目标值，还是获取到的值，都有好几个形式：</p><ol><li>HEX：<code>#fff</code>或<code>#f0f0f0</code></li><li>RGB：<code>rgb(245, 28, 33)</code></li><li>RGBA：<code>rgba(245, 28, 33, .6)</code></li><li>直接名称：<code>red</code>、<code>white</code>等等</li><li>HSL和HSLA，这里不做实现</li></ol><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>获取和一般CSS属性没差， 直接使用默认方式了</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>一般，是统一将其解析成RGBA的形式来做，如果不支持RGBA的浏览器，解析成RGB。这样我们就拥有了两个三个元素（RGB）或四个元素的数组（RGBA），一个数组为起始值，一个数组为目标值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseColor</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    val = val.replace(rClearSpace, <span class="string">""</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (normalColors[val]) &#123;</span><br><span class="line">        <span class="keyword">return</span> normalColors[val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> color = [];</span><br><span class="line">    <span class="keyword">var</span> tmp;</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">if</span> (rHexColor.test(val)) &#123;</span><br><span class="line">        tmp = [];</span><br><span class="line">        <span class="keyword">if</span> (val.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">                tmp[i] = val.charAt(i + <span class="number">1</span>);</span><br><span class="line">                tmp[i] += tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val.length === <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">                tmp[i] = val.substr(<span class="number">1</span> + i * <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">            color[i] = <span class="built_in">parseInt</span>(tmp[i], <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        color[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGB))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">            color[i] = <span class="built_in">parseInt</span>(tmp[i + <span class="number">1</span>], <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        color[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGBA))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i--;) &#123;</span><br><span class="line">            color[i] = <span class="built_in">Number</span>(tmp[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>计算中间值的过程则是对颜色数组中的每一个元素（R或G或B或A）计算一下中间值就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeColor</span>(<span class="params">from, to, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _default = hooks._default,</span><br><span class="line">        result = [],</span><br><span class="line">        i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">        result.push(<span class="built_in">parseInt</span>(_default.compute(<span class="keyword">from</span>[i], to[i], pos), <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(_default.compute(<span class="keyword">from</span>[<span class="number">3</span>], to[<span class="number">3</span>], pos));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>赋值的时候，我们需要将数组恢复成CSS中的方式，也就是恢复成RGB或RGBA的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignColor</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(KISSY.Features.isIELessThan(<span class="number">9</span>))&#123;</span><br><span class="line">        Dom.css(elem, style, <span class="string">"rgb("</span> + val.slice(<span class="number">0</span>, <span class="number">3</span>).join(<span class="string">","</span>) + <span class="string">")"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Dom.css(elem, style, <span class="string">"rgba("</span> + val.join(<span class="string">","</span>) + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><h4 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h4><p>滚动并不属于CSS属性，但我们经常会使用，比如滚动到页首。KISSY本身提供了包装，可以获取当前滚动的高度</p><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>通过KISSY获取的滚动属性值无需解析，可以使用默认解析</p><h4 id="计算-1"><a href="#计算-1" class="headerlink" title="计算"></a>计算</h4><p>计算过程也是，使用默认计算即可</p><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><p>赋值过程就和一般的CSS属性不一样了，使用KISSY提供的接口进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S.each(<span class="string">"scrollTop scrollLeft"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _default = hooks._default;</span><br><span class="line">    hooks[type] = &#123;</span><br><span class="line">        assign: <span class="function"><span class="keyword">function</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">            Dom[type](elem, val);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>: function(elem, style) &#123;</span><br><span class="line">            <span class="keyword">return</span> Dom[type](elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p><strong>这里只处理了2D的transform</strong></p><p>transform的值也有很多不同的形式：</p><ol><li>matrix</li><li>rotate</li><li>translate、translateX、translateY</li><li>scale、scaleX、scaleY</li><li>skew、skewX、skewY</li></ol><h4 id="获取-2"><a href="#获取-2" class="headerlink" title="获取"></a>获取</h4><p>获取的过程和一般CSS元素获取的过程没有差别，使用默认的方式就好</p><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p>这里就比较麻烦了，需要处理所有的情况，我们将所有的情况转变成如下的结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = &#123;</span><br><span class="line">    translateX: <span class="number">0</span>,</span><br><span class="line">    translateY: <span class="number">0</span>,</span><br><span class="line">    rotate: <span class="number">0</span>,</span><br><span class="line">    skewX: <span class="number">0</span>,</span><br><span class="line">    skewY: <span class="number">0</span>,</span><br><span class="line">    scaleX: <span class="number">1</span>,</span><br><span class="line">    scaleY: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码较长</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decomposeMatrix</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scaleX, scaleY, skew,</span><br><span class="line">        A = matrix[<span class="number">0</span>],</span><br><span class="line">        B = matrix[<span class="number">1</span>],</span><br><span class="line">        C = matrix[<span class="number">2</span>],</span><br><span class="line">        D = matrix[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure matrix is not singular</span></span><br><span class="line">    <span class="keyword">if</span> (A * D - B * C) &#123;</span><br><span class="line">        scaleX = <span class="built_in">Math</span>.sqrt(A * A + B * B);</span><br><span class="line">        skew = (A * C + B * D) / (A * D - C * B);</span><br><span class="line">        scaleY = (A * D - B * C) / scaleX;</span><br><span class="line">        <span class="comment">// step (6)</span></span><br><span class="line">        <span class="keyword">if</span> (A * D &lt; B * C) &#123;</span><br><span class="line">            skew = -skew;</span><br><span class="line">            scaleX = -scaleX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// matrix is singular and cannot be interpolated</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// In this case the elem shouldn't be rendered, hence scale == 0</span></span><br><span class="line">        scaleX = scaleY = skew = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The recomposition order is very important</span></span><br><span class="line">    <span class="comment">// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        translateX: myParse(matrix[<span class="number">4</span>]),</span><br><span class="line">        translateY: myParse(matrix[<span class="number">5</span>]),</span><br><span class="line">        rotate: myParse(<span class="built_in">Math</span>.atan2(B, A) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),</span><br><span class="line">        skewX: myParse(<span class="built_in">Math</span>.atan(skew) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),</span><br><span class="line">        skewY: <span class="number">0</span>,</span><br><span class="line">        scaleX: myParse(scaleX),</span><br><span class="line">        scaleY: myParse(scaleY)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueStringToArray</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = val.split(<span class="string">","</span>);</span><br><span class="line">    result = S.map(result, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myParse(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseTransform</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;</span><br><span class="line">        translateX: <span class="number">0</span>,</span><br><span class="line">        translateY: <span class="number">0</span>,</span><br><span class="line">        rotate: <span class="number">0</span>,</span><br><span class="line">        skewX: <span class="number">0</span>,</span><br><span class="line">        skewY: <span class="number">0</span>,</span><br><span class="line">        scaleX: <span class="number">1</span>,</span><br><span class="line">        scaleY: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> regResult;</span><br><span class="line">    <span class="keyword">var</span> i, j, m;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">var</span> strs;</span><br><span class="line">    strs = val.replace(rClearSpace, <span class="string">""</span>).split(<span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, m = strs.length; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs[i] || strs[i] === <span class="string">"none"</span>) <span class="keyword">continue</span>;</span><br><span class="line">        regResult = strs[i].split(<span class="string">"("</span>);</span><br><span class="line">        name = regResult[<span class="number">0</span>];</span><br><span class="line">        value = valueStringToArray(regResult[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"matrix"</span>:</span><br><span class="line">                result = decomposeMatrix(value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"translate"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skew"</span>:</span><br><span class="line">                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"scale"</span>:</span><br><span class="line">                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || result[name + <span class="string">"X"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"translateX"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"translateY"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"scaleX"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"scaleY"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skewX"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skewY"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"rotate"</span>:</span><br><span class="line">                result[name] = value[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中decomposeMatrix函数来自KISSY，将matrix转换成变换属性的形式。</p><h4 id="计算-2"><a href="#计算-2" class="headerlink" title="计算"></a>计算</h4><p>获取到上面的结构后，只需要对其中的每一项计算中间值就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeTransform</span>(<span class="params">from, to, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _default = hooks._default;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    S.each(to, <span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">        result[key] = _default.compute(<span class="keyword">from</span>[key], to[key], pos);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值-2"><a href="#赋值-2" class="headerlink" title="赋值"></a>赋值</h3><p>赋值也是一样，将上面的结构一一提取合并，组成一个字符串，另外需要注意添加上相应的单位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignTransform</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> valueArray = [];</span><br><span class="line">    S.each(val, <span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((key.indexOf(<span class="string">"scale"</span>) &gt; <span class="number">-1</span> &amp;&amp; value === <span class="number">1</span>) || (key.indexOf(<span class="string">"scale"</span>) === <span class="number">-1</span> &amp;&amp; value === <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">"rotate"</span> || key.indexOf(<span class="string">"skew"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            value += <span class="string">"deg"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.indexOf(<span class="string">"translate"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            value += <span class="string">"px"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        valueArray.push(key + <span class="string">"("</span> + value + <span class="string">")"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Dom.css(elem, style, valueArray.join(<span class="string">" "</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一次造轮子实验，效果还是出来了，基本的动画都能完成，且兼容IE 6，transform部分兼容到IE 9，虽然不可能直接替代KISSY的anim模块，但用起来也不算差，毕竟兼容问题都让KISSY去做了。毕竟这只是个作业，中间搞搞停停弄了3天，之后就是写DEMO之类的。后面打算优化一下代码</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/">前端综合</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      <category domain="http://lingyu.life/tags/%E5%8A%A8%E7%94%BB/">动画</category>
      
      <category domain="http://lingyu.life/tags/Kissy/">Kissy</category>
      
      
      <comments>http://lingyu.life/2014/05/31/kissy-anime-plugin/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebRTC的RTCDataChannel</title>
      <link>https://lingyu.life/#/post/2014/05/22/webrtc-data-channels</link>
      <guid>https://lingyu.life/#/post/2014/05/22/webrtc-data-channels</guid>
      <pubDate>Wed, 21 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。&lt;/p&gt;
&lt;p&gt;这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p><p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p><a id="more"></a><blockquote><p>为了充分理解这篇文章，你可能需要去了解一些RTCPeerConnection API的相关知识，以及STUN，TURN、信道如何工作。强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics" target="_blank" rel="noopener">Getting Started With WebRTC</a>这篇文章</p></blockquote><h3 id="为什么我们需要另外一个数据通道"><a href="#为什么我们需要另外一个数据通道" class="headerlink" title="为什么我们需要另外一个数据通道"></a>为什么我们需要另外一个数据通道</h3><p>我们已经有<a href="http://www.html5rocks.com/en/tutorials/websockets/basics" target="_blank" rel="noopener">WebSocket</a>、<a href="http://www.html5rocks.com/en/tutorials/file/xhr2" target="_blank" rel="noopener">AJAX</a>和<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics" target="_blank" rel="noopener">服务器发送事件</a>了，为什么我们需要另外一个通信信道？WebSocket是全双工的，但这些技术的设计都是让浏览器与服务器之间进行通信。</p><p>RTCDataChannel则是一个完全不同的途径：</p><ul><li>它通过RTCPeerConnection API，可以建立点对点互联。由于不需要中介服务器，中间的“跳数”减少，延迟更低。</li><li>RTCDataChannel使用<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol#Features" target="_blank" rel="noopener">Stream Control Transmission Protocol</a>(SCTP)协议，允许我们配置传递语义：我们可以配置包传输的顺序并提供重传时的一些配置。</li></ul><p>基于SCTP的支持的RTCDataChannel已经能够在桌面的Chrome、Opera和Firefox中使用，移动端则有Android支持。</p><h3 id="一个警告：信令、STUN和TURN"><a href="#一个警告：信令、STUN和TURN" class="headerlink" title="一个警告：信令、STUN和TURN"></a>一个警告：信令、STUN和TURN</h3><p>尽管WebRTC允许点对点的通信，但它依然需要服务器：</p><ul><li>信令传输：建立点对点的连接需要传输一些媒体和网络相关的元数据信息，需要通过服务器</li><li>NAT和防火墙穿透：我们需要通过ICE框架来建立点与点之间的网络路径。可以使用STUN服务器（确定双方的可公开访问你的IP地址和端口）以及TURN服务器（如果直接连接失败，就必须数据中继了）</li></ul><p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure" target="_blank" rel="noopener">WebRTC in the real world: STUN, TURN, and signaling</a> 文章详细介绍了WebRTC如何与这两种服务器进行交互</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>RTCDataChannel API支持灵活的数据类型。它的API是模仿WebSocket设计的，并且支持JavaScript中的二进制类型如Blob、ArrayBuffer和ArrayBufferView，另外还支持字符串。这些类型对于文件传输和多玩家的游戏来说意义重大。</p><p><img src="/img/WebRTC/4.png" alt="TCP、UDP、SCTP提供的功能"><br>以上来自<a href="http://www.igvita.com" target="_blank" rel="noopener">Ilya Grigorik</a>的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html" target="_blank" rel="noopener">High Performance Browser Networking</a></p><p>RTCDataChannel在不可靠模式（类似于UDP）或可靠模式（类似于TCP）下都能够正常工作。但这两种模式有一些不同：</p><ul><li>可靠模式：保证消息传输一定成功，并保证按序到达。这自然需要一定量的开销，速度也更慢</li><li>不可靠模式：不保证消息传输一定成功，也不保证按序到达。这消除了那些开销，速度也更快</li></ul><p>在不会丢包的情况下，这两种模式的效率差不多。然而，可靠模式下，丢包将造成后续的所有包阻塞，丢失的数据包也将重传直至其成功到达。当然，我们能在同一个应用中使用多个数据通道，每一个有他们自己的可靠性</p><p>下面将说明如何去配置可靠模式或不可靠模式的RTCDataChannel</p><h3 id="配置数据通道"><a href="#配置数据通道" class="headerlink" title="配置数据通道"></a>配置数据通道</h3><p>网上已经有很多RTCDataChannel的例子了：</p><ul><li><a href="http://simpl.info/dc" target="_blank" rel="noopener">simpl.info/dc</a></li><li><a href="http://googlechrome.github.io/webrtc/dc1.html" target="_blank" rel="noopener">googlechrome.github.io/webrtc/dc1.html</a>(SCTP或者RTP)</li><li><a href="http://pubnub.github.io/webrtc" target="_blank" rel="noopener">pubnub.github.io/webrtc</a>(两个PubNub用户)</li></ul><p>ps：PubBub是一个实时信息通讯应用开发公司</p><p>在这个例子中，浏览器创建了一个对等连接连接到自己。然后在这个对等连接n上创建了一个数据通道，发送了一些消息。最后，消息成功抵达并显示在页面上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peerConnection = <span class="keyword">new</span> RTCPeerConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用信令传输信道创建对等连接</span></span><br><span class="line"><span class="keyword">var</span> dataChannel =</span><br><span class="line">  peerConnection.createDataChannel(<span class="string">"myLabel"</span>, dataChannelOptions);</span><br><span class="line"></span><br><span class="line">dataChannel.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Data Channel Error:"</span>, error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dataChannel.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Got Data Channel Message:"</span>, event.data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dataChannel.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  dataChannel.send(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dataChannel.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The Data Channel is Closed"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>dataChannel</code>对象建立在一个已经创建完毕的对等连接之上。它可以创建在信令传输前后。另外，可以赋予一个label来作区分，并提供一系列的配置选项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataChannelOptions = &#123;</span><br><span class="line">  ordered: <span class="literal">false</span>, <span class="comment">//不保证到达顺序</span></span><br><span class="line">  maxRetransmitTime: <span class="number">3000</span>, <span class="comment">//最大重传时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以加入一个<code>maxRetransimits</code>选项（最大重传次数），但<code>maxRetransimitTime</code>或<code>maxRetransimits</code>只能设定一个，不能两个懂事设定。如果想使用UDP的方式，设定<code>maxRetransmits</code>为0，<code>ordered</code>为<code>false</code>。如果想要获取更多信息，请查看<a href="http://tools.ietf.org/html/rfc4960" target="_blank" rel="noopener">RFC 4960</a>（SCTP）和<a href="http://tools.ietf.org/html/rfc3758" target="_blank" rel="noopener">RFC 3758</a>（SCTP部分可靠性）</p><ul><li>ordered: 数据通道是否保证按序传输数据</li><li>maxRetrasmitTime：在信息失败前的最大重传时间（强迫进入不可靠模式）</li><li>maxRetransmits：在信息失败前的最大重传次数（强迫进入不可靠模式）</li><li>protocol：允许使用一个自协议，但如果协议不支持，将会失败</li><li>negotiated：如果设为true，将一处对方的数据通道的自动设置，也就是说，将使用相同的id以自己配置的方式与对方建立数据通道</li><li>id：为数据通道提供一个自己定义的ID</li></ul><h3 id="它安全吗？"><a href="#它安全吗？" class="headerlink" title="它安全吗？"></a>它安全吗？</h3><p>在WebRTC所有的组件中，都会强制进行加密。在RTCDataChannel中，所有的数据都使用<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" target="_blank" rel="noopener">数据报传输层安全性</a>（DTLS）。DTLS是SSL的衍生，也就是说，你的数据将和使用基于SSL的连接一样安全。DTLS已经被标准化，并内置于所有支持WebRTC的浏览器中。如果需要更多关于DTLS信息，请访问<a href="http://wiki.wireshark.org/DTLS" target="_blank" rel="noopener">Wireshark的维基</a></p><h3 id="改变你考虑数据的方式"><a href="#改变你考虑数据的方式" class="headerlink" title="改变你考虑数据的方式"></a>改变你考虑数据的方式</h3><p>处理大批量的数据，一直是JavaScript的一个难点。正如<a href="http://www.sharefest.me" target="_blank" rel="noopener">Sharefest</a>所提出的观点，我们需要用一种新的方式来考虑数据。如果你需要传输一个比你当前可用内存更大的文件，就必须考虑新的保存信息的方式了。这也就是像<a href="http://www.html5rocks.com/en/tutorials/file/filesystem" target="_blank" rel="noopener">FileSystem API</a>等技术存在的意义。我们将在下面进行介绍</p><h3 id="搭建一个文件共享应用"><a href="#搭建一个文件共享应用" class="headerlink" title="搭建一个文件共享应用"></a>搭建一个文件共享应用</h3><p>现在我们可以通过RTCDataChannel来创建文件共享应用。将应用建立在RTCDataChannel智商也意味着传输的文件数据都将加密，而且不会经过应用的服务器端。通过这个功能，我们能够实现多用户之间的互联，进行文件共享。</p><p>需要成功传输一个文件，我们需要如下几步：</p><ol><li><a href="http://www.html5rocks.com/en/tutorials/file/dndfiles" target="_blank" rel="noopener">通过JavaScript的File API读取文件数据</a></li><li>使用RTCPeerConnection在用户间创建一个对等连接</li><li>使用RTCDataChannel在用户间创建一个数据通道</li></ol><p>在使用RTCDataChannel时，还有一些其他问题需要考虑：</p><ul><li><strong>文件大小</strong>：如果文件很小，能够直接通过一个Blob进行存储和读取，那么我们可以直接使用File API将其读进内存，并通过可靠的数据通道发送（但是需要注意的是，浏览器有最大传输大小的限制）。随着文件变大的话，就不那么简单了。我们需要一个分块机制：文件将分成多个碎片，称为文件块。我们不再直接发送整个文件，而是一次发送一个文件块。当然文件块上会有一些元数据如块的ID，方便对方能够识别。接收到文件块之后，首先将这些文件块保存在离线存储中（例如，使用FileSystem API），只有当所有块都接收完毕，才将其拼合起来成为完整的文件，保存到用户的硬盘。</li><li><strong>速度</strong>：文件传输更适合使用可靠模式（像TCP）还是非可靠模式（像UDP）还有待商榷。如果应用知识简单的一对一文件传输，使用不可靠的数据通道将需要设计一定的响应/重传协议。你必须自己来实现它，就算你非常优秀，它仍然不会比使用可靠的数据传输快多少。可靠而无序的数据通道将会更加合适，但是如果是多方文件传输，结果可能会有所不同。</li><li><strong>块大小</strong>：这些是你的应用中的最小的“原子”数据。目前有传输大小限制（尽管以后可能不会有限制），所以必须要进行分块。目前建议的最大块大小为16KB。</li></ul><p>如果文件已经被完全传输，就可以使用一个a标签提供下载了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveFile</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  link.href = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">  link.download = <span class="string">'File Name'</span>;</span><br><span class="line">  link.click();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前已经有两个文件共享的应用使用了这种方式：<a href="http://pubnub.github.io/rtc-pubnub-fileshare" target="_blank" rel="noopener">pubnub.github.io/rtc-pubnub-fileshare</a>和<a href="https://github.com/Peer5/ShareFest" target="_blank" rel="noopener">github.com/Peer5/ShareFest</a>，这两个应用都是开源的，并提供了基于RTCDataChannel的文件共享</p><h3 id="那么我们能做什么？"><a href="#那么我们能做什么？" class="headerlink" title="那么我们能做什么？"></a>那么我们能做什么？</h3><p>RTCDataChannel为文件共享、多人游戏以及内容交付应用提供了全新的实现思路：</p><ul><li>上面已经提到了点对点的文件传输了</li><li>多人游戏，与诸如WebGL等其他技术相结合，比如Mozilla的<a href="https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer" target="_blank" rel="noopener">Banana Bread</a></li><li>内容交付：由<a href="https://peercdn.com" target="_blank" rel="noopener">PeerCDN</a>重新改造的一个用于提供点对点通信提供资源的框架</li></ul><h3 id="改变你构建应用的方式"><a href="#改变你构建应用的方式" class="headerlink" title="改变你构建应用的方式"></a>改变你构建应用的方式</h3><p>现在我们可使用高新能、低延迟的RTCDataChannel来创建更优秀的应用了。一些框架，诸如<a href="http://peerjs.com" target="_blank" rel="noopener">PeerJS</a>和<a href="https://github.com/pubnub/webrtc" target="_blank" rel="noopener">PubNub WebRTC SDK</a>，使得RTCDataChannel更加易于使用，其API也被各个平台所支持</p><p>RTCDataChannel所带来的优势能够改变你在浏览器中传输数据的观念。</p><h3 id="更多资讯"><a href="#更多资讯" class="headerlink" title="更多资讯"></a>更多资讯</h3><ul><li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics" target="_blank" rel="noopener">Getting started with WebRTC</a></li><li><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure" target="_blank" rel="noopener">WebRTC in the real world: STUN, TURN and signaling</a></li><li><a href="http://bit.ly/webrtcwebaudio" target="_blank" rel="noopener">WebRTC resources</a></li><li><a href="http://www.w3.org/TR/webrtc/#peer-to-peer-data-api" target="_blank" rel="noopener">W3C Working Draft</a></li><li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-04" target="_blank" rel="noopener">IETF WebRTC Data Channel Protocol Draft</a></li><li><a href="http://bloggeek.me/send-file-webrtc-data-api" target="_blank" rel="noopener">How to send a File Using WebRTC Data API</a></li><li><a href="http://bloggeek.me/webrtc-data-channel-uses" target="_blank" rel="noopener">7 Creative Uses of WebRTC’s Data Channel</a></li><li><a href="https://developer.mozilla.org/en/demos/detail/bananabread" target="_blank" rel="noopener">Banana Bread</a> 3D first person shooter game compiled to JS+WebGL, using WebRTC data channels in multiplayer mode</li></ul>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/">即时通信</category>
      
      
      <category domain="http://lingyu.life/tags/WebSocket/">WebSocket</category>
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/WebIM/">WebIM</category>
      
      <category domain="http://lingyu.life/tags/WebRTC/">WebRTC</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      
      <comments>http://lingyu.life/2014/05/22/webrtc-data-channels/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用导航计时监测渲染关键路径</title>
      <link>https://lingyu.life/#/post/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing</link>
      <guid>https://lingyu.life/#/post/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing</guid>
      <pubDate>Tue, 20 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）</p><a id="more"></a><h3 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h3><ul><li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li><li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li></ul><h3 id="用于监测的时间戳"><a href="#用于监测的时间戳" class="headerlink" title="用于监测的时间戳"></a>用于监测的时间戳</h3><p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p><p><img src="/img/google-translate/11.png" alt="导航计时接口提供的API"></p><p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p><p>那么，这些时间戳代表着什么？</p><ul><li>domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间</li><li>domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间</li><li>domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点<ul><li>许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间</li></ul></li><li>domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了</li><li>loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</li></ul><h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：</p><ul><li>domIneractive：说明DOM构建完毕</li><li>domContentLoaded：当DOM和CSSOM都完成后触发<ul><li>如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发</li></ul></li><li>domComplete：当页面及其所有资源全部完毕时触发</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t = <span class="built_in">window</span>.performance.timing,</span></span><br><span class="line">          interactive = t.domInteractive - t.domLoading,</span><br><span class="line">          dcl = t.domContentLoadedEventStart - t.domLoading,</span><br><span class="line">          complete = t.domComplete - t.domLoading;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> stats = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span></span><br><span class="line"><span class="actionscript">        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +</span></span><br><span class="line"><span class="actionscript">            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(stats);</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"measureCRP()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p><p><img src="/img/google-translate/12.png" alt="时间戳检测结果"></p><p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      
      <comments>http://lingyu.life/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>通过JavaScript增加交互性</title>
      <link>https://lingyu.life/#/post/2014/05/21/google-adding-interactivity-with-javaScript</link>
      <guid>https://lingyu.life/#/post/2014/05/21/google-adding-interactivity-with-javaScript</guid>
      <pubDate>Tue, 20 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p><a id="more"></a><h3 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h3><ul><li>JavaScript可以对DOM和CSSOM进行查询和修改</li><li>JavaScript的执行会阻塞CSSOM的构建</li><li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li></ul><h3 id="JavaScript造成的阻塞"><a href="#JavaScript造成的阻塞" class="headerlink" title="JavaScript造成的阻塞"></a>JavaScript造成的阻塞</h3><p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path: Script<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">      span.textContent = <span class="string">'interactive'</span>; <span class="comment">// change DOM text content</span></span></span><br><span class="line"><span class="actionscript">      span.style.display = <span class="string">'inline'</span>;  <span class="comment">// change CSSOM property</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// create a new element, style it, and append it to the DOM</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> loadTime = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="javascript">      loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">      loadTime.style.color = <span class="string">'blue'</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.appendChild(loadTime);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li><li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li></ul><p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p><p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p><p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName(&#39;span&#39;)</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p><p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p><p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p><p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p><p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：</p><ol><li>脚本在文档中的位置很重要</li><li>发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续</li><li>JavaScript能够查询和修改DOM和CSSOM</li><li>JavaScript只有在CSSOM被构建完毕之后才会执行</li></ol><p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p><h3 id="解析器的阻塞和异步JavaScript"><a href="#解析器的阻塞和异步JavaScript" class="headerlink" title="解析器的阻塞和异步JavaScript"></a>解析器的阻塞和异步JavaScript</h3><p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p><p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path: Script External<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</span><br><span class="line">span.textContent = <span class="string">'interactive'</span>; <span class="comment">// 改变DOM中的文本</span></span><br><span class="line">span.style.display = <span class="string">'inline'</span>;  <span class="comment">// 改变CSSOM属性</span></span><br><span class="line"><span class="comment">// 创建一个新元素，为其添加样式，并将其加入到DOM中</span></span><br><span class="line"><span class="keyword">var</span> loadTime = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">loadTime.style.color = <span class="string">'blue'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(loadTime);</span><br></pre></td></tr></table></figure><p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p><p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p><p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path: Script Async<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      
      <comments>http://lingyu.life/2014/05/21/google-adding-interactivity-with-javaScript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSS的渲染阻塞</title>
      <link>https://lingyu.life/#/post/2014/05/21/google-render-blocking-css</link>
      <guid>https://lingyu.life/#/post/2014/05/21/google-render-blocking-css</guid>
      <pubDate>Tue, 20 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p><a id="more"></a><p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p><h3 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h3><ul><li>默认情况下CSS是渲染阻塞资源</li><li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li><li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li></ul><h3 id="CSS是渲染阻塞资源"><a href="#CSS是渲染阻塞资源" class="headerlink" title="CSS是渲染阻塞资源"></a>CSS是渲染阻塞资源</h3><p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p><p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p><p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p><h3 id="媒体类型和媒体查询"><a href="#媒体类型和媒体查询" class="headerlink" title="媒体类型和媒体查询"></a>媒体类型和媒体查询</h3><p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(min-width: 40em)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p><p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p><p>让我们考虑如下例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span>    <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span>    <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"portrait.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"orientation:portrait"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span>    <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li><li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li><li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li><li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li></ol><h3 id="浏览器下载"><a href="#浏览器下载" class="headerlink" title="浏览器下载"></a>浏览器下载</h3><p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      
      <comments>http://lingyu.life/2014/05/21/google-render-blocking-css/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>渲染树的构建，布局和绘制</title>
      <link>https://lingyu.life/#/post/2014/05/20/google-render-tree-construction-layout-and-paint</link>
      <guid>https://lingyu.life/#/post/2014/05/20/google-render-tree-construction-layout-and-paint</guid>
      <pubDate>Mon, 19 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p><a id="more"></a><p>上一章节介绍了如何构建对象模型。我们从HTML和CSS构建出了DOM树和CSSOM树。但是，他们描述的是文档的不同方面：DOM树描述的是页面内容，而CSSOM树则描述的是需要被使用到页面内容上的样式规则，由此可见，他们是相互独立的数据结构。那么我们应当如何去合并这两棵树来让浏览器渲染像素到屏幕呢？</p><h3 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h3><ul><li>DOM树和CSSOM树结合组成了渲染树</li><li>渲染树（Render tree）只会包含需要绘制到页面上的节点</li><li>布局（Layout）会计算出每一个对象的具体位置和大小</li><li>绘制（Paint）是最后异步，将会将渲染树渲染成像素，显示到屏幕上</li></ul><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>浏览器首先需要结合DOM树和CSSOM树到渲染树，渲染树获取所有页面上可见的DOM内容，再吧CSSOM中的样式信息附着到每一个节点上</p><p><img src="/img/google-translate/7.png" alt="组合DOM树和CSSOM树，生成渲染树"></p><p>为了构建渲染树，浏览器所做的工作大致如下：</p><ol><li>从DOM树的根节点开始，遍历每个可见的节点<ul><li>有些节点本身不可见（比如script、meta等等）</li><li>有些节点被CSS隐藏了，这些节点也会被渲染树忽略</li></ul></li><li>对于每一个可见节点，会从CSSOM中找并应用到其对应的样式信息</li><li>提交可见的节点和他们的内容和样式</li></ol><p><strong>需要注意的是，<code>visibility:hidden</code>和<code>display:none</code>是不同的。前者会将元素隐藏，但元素依旧在页面中占据空间（会被绘制成空的盒子），所以需要递交给布局阶段进行处理。而后者会从渲染树中移除元素及所有子元素，他们被递交给布局阶段</strong></p><p>这个阶段完毕后，会生成一个包含所有可见节点的内容和样式信息的渲染树。接下来可以进行布局阶段了</p><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>目前为止，我们已经获取了可见节点的计算样式，但我们还没有计算元素在设备视口中的最终的位置和尺寸——计算这些就是布局阶段的工作，它还有另外一个我们熟知的名称：回流（reflow）</p><p>为了计算每个节点的最终位置和尺寸，需要从根节点开始遍历渲染树，计算渲染树中每个对象在页面上的几何图形。比如如下例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critial Path: Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 50%"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 50%"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的页面的body元素包含两个嵌套的div，第一个div（父元素）其节点的宽度为视口宽度的50%，第二个div在第一个div之中，宽度是第一个元素的50%，也就是视口宽的的50%。</p><p>布局阶段输出的是一个盒子模型，它精确地描述了元素在视口中的确切位置和尺寸：所有相对单位都会被转变为屏幕上的绝对像素值，等等</p><p>现在我们知道了哪些元素可见，他们的计算样式，以及他们的几何图形，我们终于能够将这些信息传递给最终阶段。这个阶段将渲染树中的每个节点绘制成屏幕上像素。通常这个阶段叫做绘制阶段（painting）或是光栅化（rasterizing）</p><h3 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h3><p>这里面每个步骤都需要浏览器惊醒一定量的工作，也就说会花费一定的时间。我们可以通过Chrome开发者工具看我们上面所说到的三个阶段。</p><p><img src="/img/google-translate/8.png" alt="开发者工具中查看布局阶段"></p><ul><li>Timeline中的Layout事件包含渲染树的构建阶段和位置尺寸的计算阶段</li><li>一旦布局阶段完成，浏览器会开启“Paint Setup”和“Paint”事件，用来将渲染树转变成屏幕上的像素</li></ul><p>上面所说的渲染树构建、布局阶段、绘制阶段所需要的事件会根据文档的大小、样式的多少、设备的配置有关。文档越大，浏览器需要做更多的工作。样式越复杂，浏览器需要考虑更多的绘制（绘制一个固定颜色代价很低，但绘制一个阴影代价很大）。</p><p>这些都完成后，我们的页面终于展示在视口里了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们来重温一下所有的步骤：</p><ol><li>处理HTML标记，构建DOM树</li><li>处理CSS标记，构建CSSOM树</li><li>合并DOM树和CSSOM树，构建渲染树</li><li>在渲染树上运行布局阶段，计算每个可见节点的几何图形</li><li>绘制每个独立的节点到屏幕上</li></ol><p>考虑如果DOM或CSSOM发生改变时，会发生些什么？我们需要重复这些工作来确定如何回执到屏幕上</p><p>优化渲染的关键就是减少这5步所花费的时间。减少这5步所花费的事件能够让页面尽可能快的展示到页面上。在首次页面渲染之后，每次更新后的渲染效率也会提高。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      
      <comments>http://lingyu.life/2014/05/20/google-render-tree-construction-layout-and-paint/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>构建对象模型</title>
      <link>https://lingyu.life/#/post/2014/05/20/google-constructing-the-object-model</link>
      <guid>https://lingyu.life/#/post/2014/05/20/google-constructing-the-object-model</guid>
      <pubDate>Mon, 19 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;浏览器渲染页面之前会构建DOM树和CSSOM树&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>浏览器渲染页面之前会构建DOM树和CSSOM树</p><a id="more"></a><h2 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h2><ul><li>字节(bytes) → 字符(characters) → 标记(tokens) → 节点(nodes) → 对象模型(object model)</li><li>HTML标记将会被转化为一个文档对象模型（Document Object<code>enter code here</code> Module，以下简称DOM），而CSS标记将会被转化成一个CSS对象模型（CSSOM）</li><li>DOM和CSSOM是互相独立的数据结构</li><li>Chrome的开发者工具的Timeline里面可以捕捉到DOM和CSSOM的构建和处理</li></ul><h2 id="DOM树构建"><a href="#DOM树构建" class="headerlink" title="DOM树构建"></a>DOM树构建</h2><p>比如一段如下HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其从字节到DOM树的过程如下图所示：</p><p><img src="/img/google-translate/1.png" alt="从字节到DOM树的过程"></p><p>具体的过程分为如下几步：</p><ol><li>转换（Conversion）：浏览器从网络或硬盘中读取原始的字节，并根据其编码方式转换为独立的字符</li><li>标记化（Tokenizing）：浏览器根据W3C的html5标准解析出尖括号内的字符串，每一个标记有自己的意义和规则</li><li>对象化（Lexing）：将标记转变为对象，对象内定义了他们的值和规则</li><li>DOM构建（DOM construction）：由于HTML标记定义了节点之间的关系，且这个关系是树型结构的（某个节点包含多个节点），所以通过一个树来保存</li></ol><p><img src="/img/google-translate/2.png" alt="DOM树的树状结构"></p><p>整个过程输出的是一个DOM，它是网页的DOM树，后面的处理都会用到DOM树</p><p>每一次浏览器要讲HTML标记转换成DOM树，都需要经过这些过程：从字节转换到字符，获取其中的标记，转换标记到节点，通过节点构建DOM树，这些过程需要消耗一定的时间</p><p><img src="/img/google-translate/3.png" alt="Chrome DevTools中的DOM树构建过程"></p><p>如果打开Chrome开发者工具，并在页面加载时记录Timeline，你讲看到这些步骤的具体时间。在上例中，浏览器花费了约5ms将一个HTML碎片从字节转换到DOM树，当然，如果页面较大，这个时间会更长。在接下来的创建流畅动画的章节中，如果浏览器需要处理大量的HTML，这里很容易成为瓶颈。</p><p>DOM树构建好后，我们还需要将其渲染到屏幕上。DOM树中并没有告诉浏览器应该如何渲染这些节点，而完成这个职责的就是下面的CSSOM树了</p><h2 id="CSSOM树构建"><a href="#CSSOM树构建" class="headerlink" title="CSSOM树构建"></a>CSSOM树构建</h2><p>当浏览器为页面构建DOM树的时候，它会统计head部分的link标签，指向外部CSS样式文件。浏览器需要这些文件来渲染页面，它会直接发送请求来获取文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以在HTML标记中声明CSS样式（内联样式），但保持CSS和HTML的独立使得我们能够将设计与内容分离：设计者基于CSS工作，而开发者则专注于HTML，等等</p><p>和HTML一样，我们将CSS样式转换到某种浏览器能够理解且使用的结构。其大致过程如下：</p><p><img src="/img/google-translate/4.png" alt="浏览器将CSS字节转换到CSSOM"></p><p>浏览器将CSS字节转换成字符，然后构建标记和节点，最后练级到一个叫做CSS对象模型（CSSOM）的树型数据结构</p><p><img src="/img/google-translate/5.png" alt="树状CSSOM"></p><p>HTML是树状结构很好理解，那么为什么CSSOM也是树状结构呢？在计算页面上对象的需要使用的样式集时，浏览器首先将最常规的样式赋给节点（如果是body元素的孩子，那么会使用body的所有样式），然后递归细化，逐步添加上特殊的规则，这也就是级联样式表中“级联”的意思</p><p>上面的树并不是完整的CSSOM树，目前只是展示了样式表中的样式如何互相覆盖。么一个浏览器都提供了一套自己的样式，也就是“用户代理样式（user agent styles）”，在我们不提供任何样式的时候，就会使用这些央视。如果在Chrome开发者工具里面查看“计算后样式（computed styles）”，可以看到所有节点中样式的来源</p><p>如果想知道CSS处理花费多长时间，可以在开发者工具中记录Timeline，并查看“Resalcuate”事件：与DOM解析不同的是，这里不会分开的“Parse CSS”各个阶段，解析、CSSOM树构建以及样式的递归计算都放在这一个事件之中</p><p><img src="/img/google-translate/6.png" alt="通过开发者工具查看样式处理"></p><p>这里可以看到，这次样式处理花费了约0.6ms，涉及页面上的8个元素。那这8个元素从哪儿来？CSSOM和DOM是完全独立的数据结构，浏览器隐藏了很重要的一步，通过渲染树（render tree）将CSSOM和DOM连接起来，下一章就将介绍这个渲染树</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      
      <comments>http://lingyu.life/2014/05/20/google-constructing-the-object-model/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>响应式Web设计基础</title>
      <link>https://lingyu.life/#/post/2014/05/19/google-responsive-design-fundamentals</link>
      <guid>https://lingyu.life/#/post/2014/05/19/google-responsive-design-fundamentals</guid>
      <pubDate>Sun, 18 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;本文所有内容来自&lt;a href=&quot;https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Responsive Web Design Fundamentals&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals" target="_blank" rel="noopener">Responsive Web Design Fundamentals</a></p><p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p><a id="more"></a><p>响应式Web设计，最初的定义（<a href="http://alistapart.com/article/responsive-web-design" target="_blank" rel="noopener">Ethan Marcotte in A List Apart</a>）是让网页响应用户及其所用设备的需求。在响应式设计中，布局将会随着设备的屏幕尺寸和显示能力而改变。比如，在手机上，用户只看到包含内容的单列视图，而在平板电脑中则能看到两列</p><h2 id="设置视口信息"><a href="#设置视口信息" class="headerlink" title="设置视口信息"></a>设置视口信息</h2><p>网页若需要适配不同的设备，在其文档的head元素中，需要包含一个meta元素，这个meta元素视口控制信息。这个meta元素告诉浏览器如何控制页面的尺寸缩放</p><h3 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h3><ol><li>使用meta元素，里面包含视口控制信息去控制浏览器视口的宽度和缩放</li><li>写入<code>width=device-width</code>去使用设备的像素去匹配屏幕的宽度</li><li>写入<code>initial-scale=1</code>去建立CSS像素与设备像素的1:1对等关系</li><li>保证你的页面在用户缩放的时候依旧可用</li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了提供最佳的用户体验，手机浏览器一般以980px（这个值会可能在不同设备中略有不同）的宽度渲染页面，然后会尝试去减少文字大小以及缩放内容到屏幕大小来让内容看起来更加适于阅读。对于用户来说，这也意味着字体的大小可能会不一致，用户需要通过双击或手势缩放来放大网页，这样才能看到内容并与之交互</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用meta标签来指定viewport信息，这里<code>width=device-width</code>表明页面将会以设备的像素大小来适配屏幕宽度。这样无论是在小屏幕手机上还是大屏幕显示器上，页面都可以为不同的屏幕尺寸进行内容的回流</p><p>有一些浏览器会在横竖屏切换时保持页面宽度不变，他们仅仅会进行缩放，而不会让内容回流来适应屏幕。增加属性<code>initial-scale=1</code>告诉浏览器去建立CSS像素和设备像素的1:1对等关系，而无视设备的方向，这样网页就能适应横竖屏的宽度变化了</p><p><strong>使用一个逗号去区分属性保持老式浏览器也能获取到值</strong></p><h3 id="确定一个可访问的视口"><a href="#确定一个可访问的视口" class="headerlink" title="确定一个可访问的视口"></a>确定一个可访问的视口</h3><p>除了使用<code>initial-scale</code>，也可以在视口控制信息中加入<code>minimum-scale</code>,<code>maximum-scale</code>和<code>user-scalable</code>等属性。这些值将限制用户缩放视口的比例，可能会降低网页的可访问性</p><h2 id="使得内容适配视口"><a href="#使得内容适配视口" class="headerlink" title="使得内容适配视口"></a>使得内容适配视口</h2><p>无论是手机还是桌面电脑，用户通常是垂直滚动页。也就是说，强迫用户水平滚动页面或者必须缩放才能看到整个页面，都会降低用户体验</p><h3 id="长话短说-1"><a href="#长话短说-1" class="headerlink" title="长话短说"></a>长话短说</h3><ol><li>不要为元素设定大且固定的尺寸</li><li>内容的展现不应该依赖于一个特定的视口宽度</li><li>使用CSS的媒体查询来为不同的屏幕尺寸提供不同的样式</li></ol><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>在开发手机网页中使用<code>meta viewport</code>元素进行开发时，很容易导致页面内容无法匹配某些特定的视口。比如，一张图片能够在较宽呃视口中完全显示，但在较窄的视口中则必须要水平滚动才能看到右边的部分。我们需要调整页面内容来适应视口的宽度，这样它们就不需要水平滚动了</p><p>由于不同设备基于CSS像素的尺寸和宽度不同（手机和平板之间不同，甚至不同的手机之间也不同），所以页面内容不能只依赖于一个特定的视口宽度。</p><p>如果元素设定了较大的绝对宽度，元素在窄设备中将由于太宽而只能显示一部分。取而代之，考虑使用相对宽度（如<code>width: 100%</code>）</p><h2 id="为响应式使用CSS的媒体查询"><a href="#为响应式使用CSS的媒体查询" class="headerlink" title="为响应式使用CSS的媒体查询"></a>为响应式使用CSS的媒体查询</h2><p>媒体查询其实能在CSS样式中使用的过滤器，他们能够很轻易的根据设备的特点来改变渲染网页内容的CSS样式，这些特点包括设备的显示类型，宽高，横竖屏甚至是分辨率</p><h3 id="长话短说-2"><a href="#长话短说-2" class="headerlink" title="长话短说"></a>长话短说</h3><ol><li>媒体查询可以根据设备特点来应用样式</li><li>使用<code>min-width</code>而不是<code>min-device-width</code>来保证更多情况下能有好的体验</li><li>为元素使用相对大小防止破坏布局</li></ol><h3 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>比如，我们可以通过这样的方式加入打印时需要的样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了在样式的link元素中增加<code>media</code>属性，还有两种其他方法在CSS文件在中使用媒体查询：<code>@media</code>和<code>@import</code>。处于效率考虑，推荐使用前两种方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">  <span class="comment">/* print style sheets go here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> url(print.css) print;</span><br></pre></td></tr></table></figure><p>媒体查询中的逻辑不会互相冲突，并且符合媒体查询条件而引入的CSS样式也会根据CSS优先级标准作用与页面中</p><h3 id="根据视口大小使用媒体查询"><a href="#根据视口大小使用媒体查询" class="headerlink" title="根据视口大小使用媒体查询"></a>根据视口大小使用媒体查询</h3><p>媒体查询为创建响应式的体验成为可能，通过媒体查询，我们能为小屏幕，大屏幕，或者两者之间来提供特定的样式表。媒体查询的语法允许我们根据设备的特点来创建匹配规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (query) &#123;</span><br><span class="line">  <span class="comment">/* CSS Rules used when query matches */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>媒体查询提供了很多查询条件供我们使用，其中我们在响应式web设计中用的最多是<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></p><ul><li>min-width: 匹配所有宽度大于设定值的浏览器</li><li>max-width: 匹配所有宽度小于设定值的浏览器</li><li>min-height: 匹配所有高度大于设定值的浏览器</li><li>max-height: 匹配所有高度小于设定值的浏览器</li><li>orientation=portrait: 匹配竖屏，也就是高度大于或等于宽度</li><li>orientation=landscape: 匹配横屏，也就是宽度大于或等于高度</li></ul><h3 id="关于min-device-width"><a href="#关于min-device-width" class="headerlink" title="关于min-device-width"></a>关于min-device-width</h3><p>除了<code>*-width</code>，我们也可以在媒体查询中使用<code>*-device-width</code>，这两者有微妙且重要的差异。<code>min-width</code>检测的是浏览器的窗口的尺寸，而<code>min-device-width</code>检测的则是屏幕的尺寸</p><p>在手机上，这个差异一般不会有什么影响，毕竟用户不能自由调整窗口的尺寸。但在桌面上，用户能够自由控制窗口尺寸并希望网页内容能够很自然的适应窗口，所以，应当尽量避免使用<code>*-device-width</code>，否则网页将无法响应桌面浏览器窗口的缩放</p><h3 id="使用相对单位"><a href="#使用相对单位" class="headerlink" title="使用相对单位"></a>使用相对单位</h3><p>响应式设计的一个关键概念就是流动性和比例性，而不是使用固定宽度进行布局。计量时使用相对单位能够简化布局，并防止出现创建的组件对于视口过大的情况。</p><p>比如，将顶层宽度设为100%，使其宽度撑开到整个视口大小，它的宽度永远不会大于或小于视口大小。这个div无论在iPhone的320px、黑莓Z10的342px还是Nexus 5的360px下，都能横向填满屏幕</p><p>另外使用相对单位允许浏览器在用户缩放网页时重新渲染整个页面，而不会增加一个水平滚动条。</p><h2 id="如何选择断点"><a href="#如何选择断点" class="headerlink" title="如何选择断点"></a>如何选择断点</h2><p>尽管哦我们可以考虑基于设备类型来定义断点，但需要谨慎使用这种方式。基于特定的的设备、产品、品牌名称或操作系统定义断点，就算今天能正常使用，以后也会出现维护上的噩梦。取而代之的是，网页内容应该根据其自身来决定如何在容器中进行布局。</p><h3 id="长话短说-3"><a href="#长话短说-3" class="headerlink" title="长话短说"></a>长话短说</h3><ol><li>基于网页内容创建断点，永远不要基于特定的设备、产品或品牌</li><li>以移动先行的思想设计网页，然后随着屏幕可用大小增加而渐进增强用户体验</li><li>保持每一行文字的最大宽度在70到80个字符左右</li></ol><h3 id="从小到大来挑选主要断点"><a href="#从小到大来挑选主要断点" class="headerlink" title="从小到大来挑选主要断点"></a>从小到大来挑选主要断点</h3><p>首先，在较小的屏幕尺寸上设计网页，然后主键扩大屏幕大小直到必须要增加断点。这样断点的选取是基于网页内容，并且断点会尽可能的少。</p><h3 id="必要时添加次要断点"><a href="#必要时添加次要断点" class="headerlink" title="必要时添加次要断点"></a>必要时添加次要断点</h3><p>除了显著影响布局的主要断点外，用于小范围调整的次要断点也非常有用。比如在主要断点中间，增加一些次要断点来调整元素的margin或padding，或者增加文本大小让他们在布局中显得更加自然</p><h3 id="优化文本阅读"><a href="#优化文本阅读" class="headerlink" title="优化文本阅读"></a>优化文本阅读</h3><p>传统的可读性理论建议一个理想的列每一行应该包含70到80个字符(8~10个英文单词)，也就是说，每当一行单词数量增加到10个时，我们就应该就应该加一个断点了</p><h3 id="不要完全隐藏内容"><a href="#不要完全隐藏内容" class="headerlink" title="不要完全隐藏内容"></a>不要完全隐藏内容</h3><p>当需要根据屏幕大小选择行的显示内容时，需要注意。不要简单的由于其无法适应屏幕就将其隐藏。屏幕的大小并不能说明用户想要什么。比如，在天气预报中移除了花粉浓度对于一个不外出或没有花粉过敏症呃人来说可能没什么，但对于患有花粉过敏症的人来说就很致命了</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BF%BB%E8%AF%91/">翻译</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      
      <comments>http://lingyu.life/2014/05/19/google-responsive-design-fundamentals/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>jQuery的异步控制</title>
      <link>https://lingyu.life/#/post/2014/05/17/read-jq-src-5</link>
      <guid>https://lingyu.life/#/post/2014/05/17/read-jq-src-5</guid>
      <pubDate>Fri, 16 May 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是&lt;code&gt;jQuery.Callbacks&lt;/code&gt;实例&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p><h2 id="jQuery-Callbacks"><a href="#jQuery-Callbacks" class="headerlink" title="jQuery.Callbacks"></a>jQuery.Callbacks</h2><p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p><h3 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h3><p>创建一个回调函数列表可能会用到如下参数：</p><ol><li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li><li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li><li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li><li>unique：决定了回调函数列表中的函数能否重复</li><li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li></ol><p>接下来看看构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?</span><br><span class="line">    ( optionsCache[ options ] || createOptions( options ) ) :</span><br><span class="line">    jQuery.extend( &#123;&#125;, options );</span><br></pre></td></tr></table></figure><p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="comment">// Last fire value (for non-forgettable lists)</span></span><br><span class="line">    <span class="comment">/*用于存放运行结果*/</span></span><br><span class="line">    memory,</span><br><span class="line">    <span class="comment">/*标志所有回调函数列表是否被触发过*/</span></span><br><span class="line">    fired,</span><br><span class="line">    <span class="comment">/*标志当前正在执行回调函数列表中的函数*/</span></span><br><span class="line">    firing,</span><br><span class="line">    <span class="comment">/*第一个被执行的回调函数*/</span></span><br><span class="line">    firingStart,</span><br><span class="line">    <span class="comment">/*回调函数列表的长度*/</span></span><br><span class="line">    firingLength,</span><br><span class="line">    <span class="comment">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span></span><br><span class="line">    firingIndex,</span><br><span class="line">    <span class="comment">/*保存回调函数的列表*/</span></span><br><span class="line">    list = [],</span><br><span class="line">    <span class="comment">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span></span><br><span class="line">    stack = !options.once &amp;&amp; [],</span><br></pre></td></tr></table></figure><p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p><h3 id="触发函数fire"><a href="#触发函数fire" class="headerlink" title="触发函数fire"></a>触发函数fire</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">fire = <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*如果使用了memory配置，data会先被保存在memory中*/</span></span><br><span class="line">    memory = options.memory &amp;&amp; data;</span><br><span class="line">    <span class="comment">/*表明这个回调函数列表已经被触发过了*/</span></span><br><span class="line">    fired = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*确定当前执行的回调函数在回调函数列表中的位置*/</span></span><br><span class="line">    firingIndex = firingStart || <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*将起始设为0*/</span></span><br><span class="line">    firingStart = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*获取回调函数列表的总长度*/</span></span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    <span class="comment">/*修改状态为正在执行*/</span></span><br><span class="line">    firing = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*依次执行回调函数*/</span></span><br><span class="line">    <span class="keyword">for</span> ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) &#123;</span><br><span class="line">        <span class="comment">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span></span><br><span class="line">        <span class="keyword">if</span> ( list[ firingIndex ].apply( data[ <span class="number">0</span> ], data[ <span class="number">1</span> ] ) === <span class="literal">false</span> &amp;&amp; options.stopOnFalse ) &#123;</span><br><span class="line">            memory = <span class="literal">false</span>; <span class="comment">// To prevent further calls using add</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*修改正在执行状态为false*/</span></span><br><span class="line">    firing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span></span><br><span class="line">    <span class="keyword">if</span> ( list ) &#123;</span><br><span class="line">        <span class="comment">/*多次执行的话，stack是个数组*/</span></span><br><span class="line">        <span class="keyword">if</span> ( stack ) &#123;</span><br><span class="line">            <span class="comment">/*从等待队列中弹出数据再次执行*/</span></span><br><span class="line">            <span class="keyword">if</span> ( stack.length ) &#123;</span><br><span class="line">                fire( stack.shift() );</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) &#123;</span><br><span class="line">            list = [];</span><br><span class="line">        <span class="comment">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            self.disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( list ) &#123;</span><br><span class="line">        <span class="comment">//首先保存当前列表长度</span></span><br><span class="line">        <span class="keyword">var</span> start = list.length;</span><br><span class="line">        <span class="comment">/*使用jQuery.each方法遍历深度遍历arguments：</span></span><br><span class="line"><span class="comment">        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重</span></span><br><span class="line"><span class="comment">        2. 如果值为对象那么遍历这个对象进行添加 */</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"> args </span>) </span>&#123;</span><br><span class="line">            jQuery.each( args, <span class="function"><span class="keyword">function</span>(<span class="params"> _, arg </span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> type = jQuery.type( arg );</span><br><span class="line">                <span class="keyword">if</span> ( type === <span class="string">"function"</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( !options.unique || !self.has( arg ) ) &#123;</span><br><span class="line">                    list.push( arg );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( arg &amp;&amp; arg.length &amp;&amp; type !== <span class="string">"string"</span> ) &#123;</span><br><span class="line">                    <span class="comment">// Inspect recursively</span></span><br><span class="line">                    add( arg );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)( <span class="built_in">arguments</span> );</span><br><span class="line">        <span class="comment">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span></span><br><span class="line">        <span class="keyword">if</span> ( firing ) &#123;</span><br><span class="line">            firingLength = list.length;</span><br><span class="line">        <span class="comment">/*如果memory中已经有值，执行所有新增加的回调函数*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) &#123;</span><br><span class="line">            firingStart = start;</span><br><span class="line">            fire( memory );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回this方便链式操作*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( list ) &#123;</span><br><span class="line">        <span class="comment">/*遍历arguments，对每个函数分执行删除操作*/</span></span><br><span class="line">        jQuery.each( <span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> _, arg </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> index;</span><br><span class="line">            <span class="comment">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span></span><br><span class="line">            <span class="keyword">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; <span class="number">-1</span> ) &#123;</span><br><span class="line">                <span class="comment">/*删除掉这个函数*/</span></span><br><span class="line">                list.splice( index, <span class="number">1</span> );</span><br><span class="line">                <span class="comment">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span></span><br><span class="line">                <span class="keyword">if</span> ( firing ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( index &lt;= firingLength ) &#123;</span><br><span class="line">                        firingLength--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ( index &lt;= firingIndex ) &#123;</span><br><span class="line">                        firingIndex--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回this方便链式操作*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p><h4 id="has-fn"><a href="#has-fn" class="headerlink" title="has (fn)"></a>has (fn)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">has: <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn ? jQuery.inArray( fn, list ) &gt; <span class="number">-1</span> : !!( list &amp;&amp; list.length );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p><ol><li>若有fn，直接用inArray判定</li><li>若无fn，直接判断列表是否有长度不为0的list列表</li></ol><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">empty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    list = [];</span><br><span class="line">    firingLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p><h4 id="disable和disabled"><a href="#disable和disabled" class="headerlink" title="disable和disabled"></a>disable和disabled</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">disabled: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    list = stack = memory = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br><span class="line">disabled: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p><h4 id="lock和locked"><a href="#lock和locked" class="headerlink" title="lock和locked"></a>lock和locked</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lock: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stack = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !memory ) &#123;</span><br><span class="line">        self.disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br><span class="line">locked: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !stack;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p><h4 id="fireWith和fire"><a href="#fireWith和fire" class="headerlink" title="fireWith和fire"></a>fireWith和fire</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fireWith: <span class="function"><span class="keyword">function</span>(<span class="params"> context, args </span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span></span><br><span class="line">    <span class="keyword">if</span> ( list &amp;&amp; ( !fired || stack ) ) &#123;</span><br><span class="line">        args = args || [];</span><br><span class="line">        args = [ context, args.slice ? args.slice() : args ];</span><br><span class="line">        <span class="comment">/*如果正在出发，就放到等待队列中*/</span></span><br><span class="line">        <span class="comment">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span></span><br><span class="line">        <span class="keyword">if</span> ( firing ) &#123;</span><br><span class="line">            stack.push( args );</span><br><span class="line">        <span class="comment">/*否则直接触发*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fire( args );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br><span class="line">fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.fireWith( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;,</span><br><span class="line">fired: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!fired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p><p>fired没啥好说的，判断回调函数列表是否被触发过</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p><h2 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h2><p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="三个状态，三个操作，三个列表"><a href="#三个状态，三个操作，三个列表" class="headerlink" title="三个状态，三个操作，三个列表"></a>三个状态，三个操作，三个列表</h4><p>Deferred有三个状态：</p><ol><li>pending</li><li>resolved</li><li>rejected</li></ol><p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p><p>事实上，每个操作对应着一系列的回调函数，看一下定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuples = [</span><br><span class="line">    [ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],</span><br><span class="line">    [ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],</span><br><span class="line">    [ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p><ol><li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li><li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li><li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li></ol><p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*针对三个操作分别进行加工*/</span></span><br><span class="line">jQuery.each( tuples, <span class="function"><span class="keyword">function</span>(<span class="params"> i, tuple </span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*获取操作的回调函数列表*/</span></span><br><span class="line">    <span class="keyword">var</span> list = tuple[ <span class="number">2</span> ],</span><br><span class="line">        <span class="comment">/*获取操作执行后的状态*/</span></span><br><span class="line">        stateString = tuple[ <span class="number">3</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// promise[ done | fail | progress ] = list.add</span></span><br><span class="line">    <span class="comment">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span></span><br><span class="line">    promise[ tuple[<span class="number">1</span>] ] = list.add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle state</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果状态会改变，说明是resolve方法或reject方法，</span></span><br><span class="line"><span class="comment">    由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，</span></span><br><span class="line"><span class="comment">    分别用于状态修改、使回调函数列表无效、将回调函数列表锁住</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ( stateString ) &#123;</span><br><span class="line">        list.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// state = [ resolved | rejected ]</span></span><br><span class="line">            state = stateString;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span></span><br><span class="line">        &#125;, tuples[ i ^ <span class="number">1</span> ][ <span class="number">2</span> ].disable, tuples[ <span class="number">2</span> ][ <span class="number">2</span> ].lock );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deferred[ resolve | reject | notify ]</span></span><br><span class="line">    <span class="comment">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span></span><br><span class="line">    deferred[ tuple[<span class="number">0</span>] ] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span></span><br><span class="line">    deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ] = list.fireWith;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p><ol><li>resolve</li><li>reject</li><li>notify</li><li>resolveWith</li><li>rejectWith</li><li>notifyWith</li></ol><p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p><p>同时，这里还会为promise增加三个方法：</p><ol><li>done</li><li>fail</li><li>progress</li></ol><p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p><p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p><h3 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h3><p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">promise = &#123;</span><br><span class="line">    <span class="comment">/*获得当前状态的方法*/</span></span><br><span class="line">    state: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*无论执行成功与否，都执行参数中的回调*/</span></span><br><span class="line">    always: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferred.done( <span class="built_in">arguments</span> ).fail( <span class="built_in">arguments</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span></span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params"> <span class="regexp">/* fnDone, fnFail, fnProgress */</span> </span>) </span>&#123;</span><br><span class="line">        <span class="comment">/*then的代码*/</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Get a promise for this deferred</span></span><br><span class="line">    <span class="comment">// If obj is provided, the promise aspect is added to the object</span></span><br><span class="line">    <span class="comment">/*获取promise对象*/</span></span><br><span class="line">    promise: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend( obj, promise ) : promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">deferred = &#123;&#125;;</span><br><span class="line"><span class="comment">/*pipe方法，实际上就是then，为了符合标准罢了*/</span></span><br><span class="line">promise.pipe = promise.then;</span><br><span class="line"><span class="comment">/*这里为Promise添加了done、fail、progress方法*/</span></span><br><span class="line"><span class="comment">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span></span><br><span class="line">jQuery.each( tuples, <span class="function"><span class="keyword">function</span>(<span class="params"> i, tuple </span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*上面的代码*/</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*将Promise对象的所有方法拷贝给Deferred对象*/</span></span><br><span class="line">promise.promise( deferred );</span><br></pre></td></tr></table></figure><p>这里可以看到，promise对象提供了几个接口：</p><ol><li>state：获取当前Deferred对象的状态</li><li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li><li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li><li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li><li>pipe：就是then，别名而已</li><li>done，fail，progress：上面介绍过，不赘述了</li></ol><h4 id="Promise和Deferred的区别"><a href="#Promise和Deferred的区别" class="headerlink" title="Promise和Deferred的区别"></a>Promise和Deferred的区别</h4><p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p><h4 id="then和pipe"><a href="#then和pipe" class="headerlink" title="then和pipe"></a>then和pipe</h4><p>上面略过了then方法，这里单独拉出来说一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">then: <span class="function"><span class="keyword">function</span>(<span class="params"> <span class="regexp">/* fnDone, fnFail, fnProgress */</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链</span></span><br><span class="line"><span class="comment">    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发</span></span><br><span class="line"><span class="comment">    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，</span></span><br><span class="line"><span class="comment">    用于触发链的下一个Deferred对象的相对应的回调函数列表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params"> newDefer </span>) </span>&#123;</span><br><span class="line">        <span class="comment">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span></span><br><span class="line">        jQuery.each( tuples, <span class="function"><span class="keyword">function</span>(<span class="params"> i, tuple </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];</span><br><span class="line">            <span class="comment">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span></span><br><span class="line">            deferred[ tuple[<span class="number">1</span>] ](<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> returned = fn &amp;&amp; fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">                <span class="comment">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span></span><br><span class="line">                <span class="keyword">if</span> ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) &#123;</span><br><span class="line">                    returned.promise()</span><br><span class="line">                        .done( newDefer.resolve )</span><br><span class="line">                        .fail( newDefer.reject )</span><br><span class="line">                        .progress( newDefer.notify );</span><br><span class="line">                <span class="comment">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    newDefer[ tuple[ <span class="number">0</span> ] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : <span class="built_in">arguments</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        fns = <span class="literal">null</span>;</span><br><span class="line">    &#125;).promise();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p><p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">when: <span class="function"><span class="keyword">function</span>(<span class="params"> subordinate <span class="regexp">/* , ..., subordinateN */</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">        <span class="comment">/*切分参数到数组*/</span></span><br><span class="line">        resolveValues = slice.call( <span class="built_in">arguments</span> ),</span><br><span class="line">        <span class="comment">/*数组长度*/</span></span><br><span class="line">        length = resolveValues.length,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 未完成的需要监听的Deferred对象的个数 */</span></span><br><span class="line">        remaining = length !== <span class="number">1</span> || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : <span class="number">0</span>,</span><br><span class="line">        <span class="comment">/*新建一个Deferred对象用于管理所有的Deferred对象结果，</span></span><br><span class="line"><span class="comment">        不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了</span></span><br><span class="line"><span class="comment">        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，</span></span><br><span class="line"><span class="comment">        每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，</span></span><br><span class="line"><span class="comment">        就触发新建的Deferred的resolve。</span></span><br><span class="line"><span class="comment">        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        updateFunc = <span class="function"><span class="keyword">function</span>(<span class="params"> i, contexts, values </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>&#123;</span><br><span class="line">                contexts[ i ] = <span class="keyword">this</span>;</span><br><span class="line">                values[ i ] = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ? slice.call( <span class="built_in">arguments</span> ) : value;</span><br><span class="line">                <span class="keyword">if</span> ( values === progressValues ) &#123;</span><br><span class="line">                    deferred.notifyWith( contexts, values );</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !( --remaining ) ) &#123;</span><br><span class="line">                    deferred.resolveWith( contexts, values );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        progressValues, progressContexts, resolveContexts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span></span><br><span class="line">    <span class="keyword">if</span> ( length &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        progressValues = <span class="keyword">new</span> <span class="built_in">Array</span>( length );</span><br><span class="line">        progressContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );</span><br><span class="line">        resolveContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class="line">            <span class="comment">/*这里只处理Deferred/Promise，其他不考虑*/</span></span><br><span class="line">            <span class="keyword">if</span> ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) &#123;</span><br><span class="line">                resolveValues[ i ].promise()</span><br><span class="line">                    .done( updateFunc( i, resolveContexts, resolveValues ) )</span><br><span class="line">                    .fail( deferred.reject )</span><br><span class="line">                    .progress( updateFunc( i, progressContexts, progressValues ) );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span></span><br><span class="line">    <span class="keyword">if</span> ( !remaining ) &#123;</span><br><span class="line">        deferred.resolveWith( resolveContexts, resolveValues );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将这个管理Deferred对象返回*/</span></span><br><span class="line">    <span class="keyword">return</span> deferred.promise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p><p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p><p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p><p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/JS%E6%8A%80%E6%9C%AF/">JS技术</category>
      
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      
      <comments>http://lingyu.life/2014/05/17/read-jq-src-5/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>