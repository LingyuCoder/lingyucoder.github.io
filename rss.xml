<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>天镶的博客</title>
    <link>http://lingyu.life/</link>
    
    <image>
      <url>http://lingyu.life/img/favicon-32x32.png</url>
      <title>天镶的博客</title>
      <link>http://lingyu.life/</link>
    </image>
    
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 25 Mar 2020 08:22:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>聊一聊前端研发流程</title>
      <link>https://lingyu.life/#/post/2020/03/25/new/fedevprocess</link>
      <guid>https://lingyu.life/#/post/2020/03/25/new/fedevprocess</guid>
      <pubDate>Tue, 24 Mar 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近也没写什么文章，在这里谈谈我对前端研发流程的一些理解。这里不涉及到具体技术，只是谈一谈每个步骤的能力及方案。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近也没写什么文章，在这里谈谈我对前端研发流程的一些理解。这里不涉及到具体技术，只是谈一谈每个步骤的能力及方案。</p><a id="more"></a><p>平常还写代码切模块的人，很容易发现，其实页面or模块的研发流程上大体分为如下几步：</p><ul><li>项目初始化</li><li>项目代码开发</li><li>项目构建编译</li><li>项目自动化测试</li><li>项目集成测试</li><li>项目资源发布</li><li>项目线上调试</li></ul><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>使用一个针对场景定制过的脚手架（boilerplate），填入一些新仓库的信息来生成<strong>可运行</strong>的最简项目代码。典型的开源方案如yeoman，create-react-app啥的都是干的这个。一般脚手架会定义如下内容：</p><ul><li>目录结构</li><li>编码风格</li><li>通用依赖方案</li><li>构建编译方案</li><li>本地调试方案</li><li>单元测试方案</li><li>…</li></ul><p>脚手架是架构的直观体现，一般会清晰的定义模块、页面、应用之间的关系，以及落地规范和指导原则。一般情况下应该由架构师来开发脚手架，而业务落地的同学使用脚手架来初始化业务仓库进行代码开发，在开发过程中提炼出提效需求反馈给架构师，架构师将提效的功能集成到脚手架中。而脚手架最好能有一套自动化升级机制来保证提效的功能能够惠及到每个业务开发同学，而不是需要每个仓库手动升级。</p><h2 id="项目代码开发"><a href="#项目代码开发" class="headerlink" title="项目代码开发"></a>项目代码开发</h2><p>有了基础项目代码，然后就开始往里面塞入各种内容，模块、页面、工具类等等。这个过程中，需要的最重要能力是<strong>所见即所得</strong>，也就是要求有符合代码研发流程的配套工具。常见场景及需求能力如下</p><ul><li>应用开发：容器模拟、配置下发模拟</li><li>页面开发：本地接口模拟、模板渲染模拟</li><li>模块开发：模块运行环境模拟，模块交互模拟</li><li>工具开发：针对不同的工具类型有不同的模拟能力要求</li></ul><p>由于代码研发的流程非常长，对整个研发体验至关重要。因此一个优秀的本地研发工具必须要做到如下几点：</p><ul><li>高可用：尽量降低对相关系统的依赖，防止出现依赖系统无法访问阻塞代码开发的情况</li><li>高性能：每个人都不喜欢等待，构建要快、生效要快，这也是为什么要做构建优化、要做HMR</li><li>可调试：代码报错了能够快速发现，对应的sourcemap必须要有，统一的日志工具也是不错的选择。另外如果移动端调试也应该有轻松简单的抓包方案</li></ul><h2 id="项目构建编译"><a href="#项目构建编译" class="headerlink" title="项目构建编译"></a>项目构建编译</h2><p>过去前端嘲笑服务端，说他们天天编译浪费太多时间。但现在前端自己也离不开编译了。不管是ts、babel、sass什么的，谁不喜欢用更方便的特性来写代码呢？前端构建编译也在不断地演化推进，而大的模式不外乎本地构建和云端构建两种，针对这两个的区别主要有如下的考虑：</p><ul><li>构建效率和成本：本地构建的成本是非常低的，而且构建速度一般都较快。云构建需要在机器上启动docker然后安装依赖再进行构建，成本和构建时间都比较高</li><li>构建产物的一致性：本地构建情况下，由于大多数情况下安装的资源都是semver规范下的一个版本范围，加之很多依赖资源没有很好地遵守semver版本规范，导致很容易出现版本号不一致（甚至魔改依赖资源）从而产出构建产物不一致问题，而云构建则相对较为稳定</li><li>团队规范遵守：本地构建的情况下，由于交付的是构建产物而不是源码，而生成这些构建产物的过程又是在本地，因此团队规范的遵守就更需要团队成员的自觉，云构建则相对更好去做规范的卡口</li><li>构建能力的动态升级：本地构建的一个问题就是构建器安装在本地，而大多数情况是不会去升级的。这里就意味着若构建能力变化是无法感知的，若要享受这个能力需要一个个仓库推动升级，对于模块化开发的场景是非常痛苦的。而云构建则能做到一次性升级，对于落地一些全局能力非常有帮助。</li></ul><p>构建产物其实除了可运行代码，还有很多其他的内容，这里随便举两个例子：</p><ul><li>文档构建：基于代码生成文档有很多方案，比如格式化注释，亦或是直接基于AST对源码做分析。比较典型的就是React的PropTypes，非常适合直接分析源码生成文档</li><li>埋点构建：通过分析代码和注释的方式自动化生成埋点，以及埋点对应的相互关系，方便后续数据分析</li></ul><p>对应构建还需要对构建结果进行分析，典型的分析有：</p><ul><li>构建耗时分析：哪些资源构建较为复杂，是否可以针对性的做一些缓存提效</li><li>依赖大小分析：哪些资源较大，是否做了tree shaking，是否可以更换成更加精细化的加载方式</li><li>依赖关系分析：对于较大的项目，通过构建直观的展现模块之间的依赖关系对于快速理解应用架构是非常有帮助的</li></ul><h2 id="项目自动化测试-amp-集成测试"><a href="#项目自动化测试-amp-集成测试" class="headerlink" title="项目自动化测试&amp;集成测试"></a>项目自动化测试&amp;集成测试</h2><p>自动化测试对于功能稳定明确的场景是非常必要的。毕竟维护测试用例也是一个庞大的工程，在快速迭代的场景下，<strong>投入产出比</strong>可能较低。在快速变化的项目中，只对其中不变的核心链路进行自动化测试。自动化测试的核心问题有如下几个：</p><ul><li>自动化测试的触发与卡口：触发机制保证项目的流程严格经过测试，本地触发时非常不合理的。最好是能做到发布流程中，比如代码push后的git钩子中。而自动化测试应该成为严格的卡口，测试用例没有通过、测试覆盖率没有达标，应回退到开发流程中，不应进行集成测试，更别提资源发布了。</li><li>测试用例的管理：在快速奔跑的互联网环境下，考虑投入产出比是非常重要的，从99%覆盖率到100%覆盖率会额外花费非常大的成本，由于前端并非像服务端那样中心式，小部分用户出问题，并不会影响其他正常的用户。因此找到一个测试用例维护成本与业务高可用要求之间的平衡是测试用例管理最重要的部分</li><li>测试环境模拟：由于大多数情况下我们开发的页面都会存在外部依赖，典型的比如依赖客户端运行容器的jsbridge能力、依赖服务端数据、依赖其他页面上的资源、依赖浏览器BOM能力等等，因此模拟这些环境能力是自动化测试重要部分。而这其中这些能力失效时的破坏性测试也是非常有必要的。</li></ul><p>代码自动化测试完成后，就需要和真实的上下游链路进行真实的集成测试，在真实的环境下，与依赖方一起进行完整的链路测试。在这期间，前端可能只是其中的一小部分，那么我们要做的就有:</p><ul><li>保证自己负责的部分尽可能的稳定</li><li>明确上下游依赖以及出现问题时的排查链路</li><li>阻塞式问题优先响应，非阻塞式问题定好处理节奏</li></ul><h2 id="项目资源发布"><a href="#项目资源发布" class="headerlink" title="项目资源发布"></a>项目资源发布</h2><p>构建产物的发布有很多种方式，针对不同的使用场景可以有不同的发布方式，有很多时候会有多个发布流程。典型的比如一个工具类，它既可以发布到CDN供页面加载使用，也可以发布到NPM供Nodejs环境使用。发布的关注点主要有如下几个：</p><ul><li>发布渠道<ul><li>CDN：通常符合特定的路径规范，供模块加载器异步加载</li><li>NPM：供代码打包的方式使用</li><li>服务器：在一些系统里面是前端资源放在服务端机器上</li></ul></li><li>发布环境<ul><li>研发环境：供研发环境使用，方便多模块联调、回归测试</li><li>线上环境：发布到线上可供用户使用，具体使用方式需要根据版本管理方式而定</li></ul></li><li>校验能力<ul><li>可用性校验：依赖资源是否已经发上线，依赖的功能容器是否已经具备</li><li>易用性校验：通常是性能校验，比较常见的是页面性能评分</li><li>安全性校验：是否有代码级别的安全漏洞及不规范实践等等</li></ul></li><li>版本管理<ul><li>覆盖式发布：同一个资源URI，发布新的，老的就会被替换。需要很好地灰度方案防止出现大规模bug</li><li>非覆盖式发布：根据版本生成不同的URI，需要使用资源的页面指定版本，对应服务端或者页面渲染侧要有版本控制能力</li></ul></li><li>灰度能力<ul><li>流量灰度：基于流量灰度，最粗暴的灰度方式，容易出现一个用户多次访问结果不一致的情况</li><li>用户灰度：基于用户灰度，相对温和的灰度方式，一个用户多次访问看到内容相同。最简单的方式就是用户ID进行Hash</li><li>协同灰度：当服务端也需要灰度时，前端的灰度需要配合服务端灰度，防止前后端版本不一致导致功能bug</li></ul></li><li>回滚能力<ul><li>版本切换：当非覆盖式发布式，能快速切换版本实现回滚。而覆盖式发布则需要一个模拟的版本切换功能</li><li>协同回滚：服务端回滚时，前端如何与服务端配合回滚且协同生效</li></ul></li></ul><h2 id="项目线上调试"><a href="#项目线上调试" class="headerlink" title="项目线上调试"></a>项目线上调试</h2><p>前端也是很容易出现线上问题的，而且由于前端分布式的特点，因此排查问题会非常痛苦，项目线上调试非常必要，毕竟不管怎么模拟，线上用户真实的环境总是与模拟环境不同的。因此当项目发布到线上用户反馈问题时，应当建立起对应的调试机制，而对于前端而言主要关注如下几点：</p><ul><li>问题发现：首先需要有可靠的问题发现机制，这里就涉及到前端稳定性相关的服务化方案，主要是通过日志上报、实时计算、算法分析告警来实现，这可以单独写一整篇文章，就不展开讨论了</li><li>问题定位：遇到问题时，能够精确定位并实现问题场景的复现。这看起来很简单，但实际上在如今大数据、个性化的算法能力影响下，其实想要实现场景的复现是非常困难的，因此合理的日志上报能力便非常重要，将关键数据上报以实现场景复现定位问题</li><li>问题排查：在线上遇到问题时，若无法本地复现场景，那么就应当找到线上场景并实现访问资源替换到本地功能，这种情况下可能会需要用户+技术支持配合，采用资源代理的方式将用户访问的资源代理到本机通过debug来找到真正问题所在</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>目前大多数情况下的本地开发流程大体就这些了，当然其实还有很多其他东西也可以列入到研发流程中，比前端云开发以及WebIDE，这种模式现在还在快速发展期，后续我会写一篇文章谈一谈我对WebIDE的看法。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</category>
      
      
      <category domain="http://lingyu.life/tags/%E5%B7%A5%E5%85%B7/">工具</category>
      
      
      <comments>http://lingyu.life/2020/03/25/new/fedevprocess/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>聊一聊前端工具链</title>
      <link>https://lingyu.life/#/post/2020/03/25/new/fetoolchain</link>
      <guid>https://lingyu.life/#/post/2020/03/25/new/fetoolchain</guid>
      <pubDate>Tue, 24 Mar 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近主要开发流程的构建工具被要求进行升级，从平台化的方案修改到npm提供的CLI命令行工具，这个修改本人是非常不赞同的，是历史的倒退，在这里说一下自己的看法。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近主要开发流程的构建工具被要求进行升级，从平台化的方案修改到npm提供的CLI命令行工具，这个修改本人是非常不赞同的，是历史的倒退，在这里说一下自己的看法。</p><a id="more"></a><h3 id="CLI工具链"><a href="#CLI工具链" class="headerlink" title="CLI工具链"></a>CLI工具链</h3><p>CLI工具链本质上就是注册一个全局bin文件，命令行运行命令时系统查找到bin文件后执行其中的逻辑，并将后续的参数放入process.argv中，程序解析argv后基于自己对于命令行参数的定义来决定运行什么了子逻辑。通常我们都会基于开源界通用的命令行规范进行argv的解析，比较火的库比如tj的commander就以描述的方式对参数进行解析并对应到各个子逻辑的action。</p><p>对于子逻辑，通常也就是子命令，决定了工具链所能提供的能力，我之前在<a href="https://lingyu.life/#/post/2020/3/25/new/fedevprocess">聊一聊前端研发流程</a>这篇文章中介绍过前端研发流程，对应的各个步骤都会体现在子命令上，比如：</p><ul><li>项目初始化：init</li><li>项目代码开发：dev</li><li>项目构建编译：build</li><li>项目自动化测试：test</li><li>项目资源发布：publish</li></ul><p>而这仅仅是前端研发流程本地部分的核心链路，其实还有很多周边的链路，比如coverge、doc等等都可以封装成CLI工具。这对于工具链本身就需要很好地扩展性，也就是将CLI工具从宏内核向微内核转变。</p><h4 id="宏内核的工具链"><a href="#宏内核的工具链" class="headerlink" title="宏内核的工具链"></a>宏内核的工具链</h4><p>宏内核的工具链很好理解，将所有的研发流程的需求都放在一个CLI工具中，形成一站式本地研发解决方案。</p><p>这种模式一般常见于开源的一些工具，以及规模较小的团队，或者团队早期。由于负责的业务形态较为单一，研发流程相对固定，因此一个定制化的CLI工具就能解决所有的问题。</p><p>但随着业务、团队的发展场景逐渐复杂，各个业务场景对研发流程的需求逐渐增加，因此首先想到的是，增加配置文件来干预工具链的运行流程。但继续发展下去，很快就会发现配置文件其实很难满足所有需求，而且配置文件的维护会变得很痛苦，因此会转而考虑通过增加命令来实现研发流程的扩展。这就需要微内核的工具链方案了</p><h4 id="微内核的工具链"><a href="#微内核的工具链" class="headerlink" title="微内核的工具链"></a>微内核的工具链</h4><p>微内核与宏内核工具链的差距主要就是在于插件机制。通常我们会抽离出一个core模块，来做以下工作：</p><ul><li>插件加载</li><li>argv解析</li><li>配置读取</li><li>插件运行</li><li>日志管理</li><li>临时文件管理</li></ul><h5 id="插件加载"><a href="#插件加载" class="headerlink" title="插件加载"></a>插件加载</h5><p>运行后，内核首先会去查找插件，通过遍历如下文件夹，根据名称或package.json中的标识来定位插件，通过require加载并注册：</p><ul><li>内置插件：内核自身的node_modules</li><li>全局插件：<code>npm root -g</code>的全局安装位置</li><li>仓库本地插件：<code>${cwd}/node_modules</code>的本地node_modules</li></ul><h5 id="argv解析"><a href="#argv解析" class="headerlink" title="argv解析"></a>argv解析</h5><p>argv解析过程主要是确定子命令查找对应插件，若找到对应插件，则需要读取本地配置并将配置与当前命令参数一起交给插件运行。而找不到插件的情况下，应当给与插件不存在的提示并给出插件安装的推荐方案。</p><h5 id="配置读取"><a href="#配置读取" class="headerlink" title="配置读取"></a>配置读取</h5><p>通常一个CLI工具链只会有一个配置文件，因此若找到了需要运行的插件，那么内核应该读取配置文件，并找到该插件所对应的配置内容，交由插件执行。这里配置读取的过程其实是有两个，一个是内置的默认配置，一个是仓库本地配置。在仓库本地没有配置的情况下使用默认配置。</p><h5 id="插件运行"><a href="#插件运行" class="headerlink" title="插件运行"></a>插件运行</h5><p>插件运行也有两种模式，一种是直接以函数的方式运行，另外一种是通过<code>child_process</code>开启子进程来运行。子进程的方式可以做到更好的运行环境隔离，而且对于一些非node技术栈很友好。而函数方式运行则可以更好的做管控，比如日志注入。</p><h5 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h5><p>插件运行过程中的日志管理其实还是挺重要的，在提升用户体验的同时，也方便开发者在插件运行出现问题的时候进行排查。毕竟工具链安装在每个用户的电脑上，他们的环境多多少少有些不同，node版本、系统版本、网络环境等等。</p><p>日志管理其实蛮复杂的，比如构建插件，它自己并不是真的去构建代码，而是使用webpack等等工具来进行构建，因此如何将这些工具输出的日志也能统一起来，就有点蛋疼了。而且同时也需要将这些日志输出到临时文件中，来方便排查问题。一般会采用拦截stdout和stderr两个输出流的方式来实现，对应child_process创建的子进程也需要用inherit来处理。</p><p>而日志一般都会定义等级，verbose、info、success、warn、error、debug，对应不同的输出颜色。这里就如果需要子命令也按照对应等级输出，一种是开发时基于统一的log模块，另一种由内核进行log模块的注入。</p><h5 id="临时文件管理"><a href="#临时文件管理" class="headerlink" title="临时文件管理"></a>临时文件管理</h5><p>很多插件在运行环境下都会产生一些临时文件，比如资源代理时防止重复请求、比如构建流程的中间产物等等，如果这些插件都乱输出临时文件，那么很容易搞得项目目录乱七八糟，因此核心模块应当将插件的临时文件目录传入插件，并提供临时文件目录的一键删除能力</p><h5 id="微内核的问题"><a href="#微内核的问题" class="headerlink" title="微内核的问题"></a>微内核的问题</h5><p>微内核的方案能够实现命令级别的扩展，主要针对研发流程的补充。但随着业务的发展我们发现很多时候流程大体相似，但只是构建的流程会做一些小的扩展，比如有的同学想在当前的构建流程上增加TypeScript、有些同学想修改一下本地调试的渲染模板。在宏内核与微内核的CLI命令中，这些能力要么是通过脚手架初始化生成到仓库本地，亦或是是现在build的子命令中。生成到本地无法动态升级和复用，实现在build中则缺乏扩展性。因此需要将将构建的流程单独抽离出来进行管理。</p><h4 id="脚手架和构建器"><a href="#脚手架和构建器" class="headerlink" title="脚手架和构建器"></a>脚手架和构建器</h4><p>当我们将构建流程从脚手架和子命令中剥离，形成单独的构建器。构建器内包含构建流程以及构建所需要的依赖工具，构建流程大体相同，唯一额外要处理的就是需要同时处理好构建器自身的依赖以及仓库本地的依赖，保证两边都能正常加载。</p><p>而剥离了构建器的脚手架，基本上就只剩源码、源码的运行依赖及源码开发相关的配置了。剥离了构建器的构建命令，则主要是负责构建器的加载，检测构建器的版本并提示构建器升级。比较通用的方式就是将构建器发布到npm，通过访问npm的开放API拿到最新版本，与本地版本匹配后下载tar包解压安装。加载构建器过程与加载插件本质上差不多，可以理解为构建子命令自身也是一个微内核。</p><p>这种方式其实本质上是一种SaaS模式，其中的软件也就是构建器，而软件下发就是npm + 子命令的构建器升级机制，用户无需持有、也无需关心构建器，只需要知道有这么个东西在帮助他们构建即可。</p><h4 id="从SaaS到SaaS"><a href="#从SaaS到SaaS" class="headerlink" title="从SaaS到SaaS"></a>从SaaS到SaaS</h4><p>而这种软件即服务的方式，可以进一步进化到解决方案即服务，也就是Solution as a Service。这两者的区别主要在于，软件即服务下，使用者还是会感知到构建器的存在并去手动使用它，虽然它能够动态的更新和维护，但使用者并没有专注在自己的工作中，还是有一些额外的工作。</p><p>实际上代码开发者完全无需感知构建流程的存在，他们只是订阅了构建服务，这个服务于帮他们处理构建这个事情。但对于构建的流程是完全无感知的，他们无需升级，无需安装，无需运行，这就是云构建的模式。使用者只关心本地的代码开发，也就是自己的本职工作，除此之外不再有感知，这是最好的方案。这种方案未来也可以向WebIDE进行转变。也非常适合做开放化，引入三方能力进行开发。</p><h4 id="前端工具链的演化"><a href="#前端工具链的演化" class="headerlink" title="前端工具链的演化"></a>前端工具链的演化</h4><p>其实前端的工具链完全可以全部转变成解决方案即服务，用户编码的同时，代码会发送到云端，生成实时的渲染结果返回。整个工具链都跑在云端，代码编辑也确实能放在云端，但我认为未来代码编辑也就是WebIDE本身还是会受到网速与Webkit渲染能力的限制，如果WASM能够突破Webkit的渲染限制，同时网速能够更加快速，WebIDE加一直整套的云端工具链方式将会成为主流。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</category>
      
      
      <category domain="http://lingyu.life/tags/%E5%B7%A5%E5%85%B7/">工具</category>
      
      
      <comments>http://lingyu.life/2020/03/25/new/fetoolchain/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>浅谈微前端</title>
      <link>https://lingyu.life/#/post/2020/03/14/new/microfrontend</link>
      <guid>https://lingyu.life/#/post/2020/03/14/new/microfrontend</guid>
      <pubDate>Fri, 13 Mar 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近学习微前端知识，自己也撸了一个微前端玩具库&lt;a href=&quot;https://github.com/harpsealjs/microfe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@harpsealjs/microfe&lt;/a&gt;，这里先把准备周会团队分享的PPT放出来，关于这个库回头单独写篇文章好了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近学习微前端知识，自己也撸了一个微前端玩具库<a href="https://github.com/harpsealjs/microfe" target="_blank" rel="noopener">@harpsealjs/microfe</a>，这里先把准备周会团队分享的PPT放出来，关于这个库回头单独写篇文章好了</p><a id="more"></a><p><strong>多图预警</strong> <a href="/static/ppt/microfrontend/index.html">点击查看PPT</a> </p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/">页面开发</category>
      
      
      <category domain="http://lingyu.life/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/">前端架构</category>
      
      <category domain="http://lingyu.life/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</category>
      
      
      <comments>http://lingyu.life/2020/03/14/new/microfrontend/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>浅谈前端函数式编程</title>
      <link>https://lingyu.life/#/post/2020/03/09/new/functionalfe</link>
      <guid>https://lingyu.life/#/post/2020/03/09/new/functionalfe</guid>
      <pubDate>Sun, 08 Mar 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近学习函数式编程中的各种知识，汇聚成了一个PPT在团队周会分享&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近学习函数式编程中的各种知识，汇聚成了一个PPT在团队周会分享</p><a id="more"></a><p><strong>多图预警</strong> <a href="/static/ppt/functionalfe/index.html">点击查看PPT</a> </p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</category>
      
      
      <category domain="http://lingyu.life/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</category>
      
      
      <comments>http://lingyu.life/2020/03/09/new/functionalfe/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>聊聊前端深水区</title>
      <link>https://lingyu.life/#/post/2020/03/03/new/deepwaterzone</link>
      <guid>https://lingyu.life/#/post/2020/03/03/new/deepwaterzone</guid>
      <pubDate>Mon, 02 Mar 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;去年和不少人聊天，都觉得前端已经进入深水区了。具体表现为以下几点：&lt;br&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想造一些轮子，发现好做的都有兄弟团队在做了，提案被老板分分钟拍死&lt;/li&gt;
&lt;li&gt;找不到技术和个人前进的方向，难以获得机会，更别说突破&lt;/li&gt;
&lt;li&gt;业务也日益增多，完成业务累得半死没有思考的时间，混吃等死&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我在天猫的业务团队负责天猫搜索和手机天猫导购线，也在这个问题上面迷茫过，也一直在思考如何破局。在最近一些思考过程中，我逐渐发现其实我陷入了一个误区：不是前端进入深水区，而是部分页面开发进入深水区。这里首先要明确前端工程师这个概念。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>去年和不少人聊天，都觉得前端已经进入深水区了。具体表现为以下几点：<br>​</p><ul><li>想造一些轮子，发现好做的都有兄弟团队在做了，提案被老板分分钟拍死</li><li>找不到技术和个人前进的方向，难以获得机会，更别说突破</li><li>业务也日益增多，完成业务累得半死没有思考的时间，混吃等死</li></ul><p>我在天猫的业务团队负责天猫搜索和手机天猫导购线，也在这个问题上面迷茫过，也一直在思考如何破局。在最近一些思考过程中，我逐渐发现其实我陷入了一个误区：不是前端进入深水区，而是部分页面开发进入深水区。这里首先要明确前端工程师这个概念。</p><a id="more"></a><blockquote><p>以下内容仅代表个人看法，理解尚浅请多多包涵，欢迎探讨交流<br>​</p></blockquote><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>对于前端工程师，有好几种不同的理解：<br>​</p><ul><li>用HTML+CSS+JS开发页面的研发人员</li><li>在浏览器中开发页面的研发人员</li><li>与后端（服务端）概念对应，在用户侧开发的研发人员</li><li>使用JS开发的研发人员</li><li>…<br>​<br>这几种理解，可以说正确又可以说不正确。在过去刚出现前端工程师岗位的时候，前两种理解好像确实挺准确。但随着RN、Weex等技术发展，好像第三种理解更加符合。而随着Nodejs的发展，最后一种又显得更加合理。随着技术的不断发展，IOT、AI的出现，也许未来又会出现很多不同的理解。而站在我个人角度，我将前端定义为：“<strong>解决用户侧问题的研发人员</strong>”。这里有三个点：1. 站在用户侧 2. 解决问题 3. 研发人员。<br>​<h3 id="站在用户侧"><a href="#站在用户侧" class="headerlink" title="站在用户侧"></a>站在用户侧</h3>首先，前端站在用户测其实是非常好理解的。不管是PC浏览器、移动客户端、可穿戴设备等等都是用户直接感知到的东西，而前端目前为止开发工作中最重要的部分，就是利用这些用户触手可及的软件或硬件作为载体，将用户和背后的商业系统串联起来。在过去PC浏览器作为主要载体的时候，前端大量工作都是在浏览器内或者桌面应用内嵌的Webkit上开发各种页面，甚至是Web OS。而手机的普及和通信技术发展导致流量资费大幅下调，移动互联网大潮席卷全球，各大公司都在争先恐后的将自己的商业产品往移动互联网上搬，Mobile APP成为与用户串联的新载体，前端也就自然而然的转移到移动端进行开发，也涌现出了RN、Weex、Flutter这些与移动端开发技术深度融合的前端技术。而未来也许可穿戴设备会成为主流，那么前端也自然而然会在全新的技术挑战下催生出全新的技术体系。但不管技术怎么发展，前端工程师永远是离用户最近的那拨人。<br>​<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3>其次，前端是在解决问题。解决什么问题？在我个人理解，前端解决的是用户与商业串联时的问题。这里面可以拆分出三层：1. 用户侧的诉求：人性化的用户体验，前端做体验优化、性能优化、做动效、做互动，都是为了让用户用着舒服；2. 商业侧的诉求：准确的商业信息表达，明确将产品能力表达给用户，去为用户带来价值，我们花了大量时间做业务就是在满足这一部分诉求；3. 串联的诉求：快速高效的建立用户与商业的连接渠道，就能让业务跑得更快，前端工程化、可视化搭建都是在快速解决这类诉求；<br>​<h3 id="研发人员"><a href="#研发人员" class="headerlink" title="研发人员"></a>研发人员</h3>最后，前端作为研发人员还是要从技术的角度出发。在解决各种用户侧问题的过程中，明确方案、设计架构、开发工具、研发平台，不断沉淀、丰富自己的工具库使之能应付的问题范围不断扩大，从解决单点的问题，到解决一个特定场景下的问题，到解决一个特定形态的问题，到解决通用的问题。在这之中，除了技术上的沉淀，不断积累形成自己的方法论，以应付未来完全不同形态的问题。这个过程中，也要抬头看看其他技术人沉淀的工具能不能帮到自己，也可以把自己的工具奉献出来给大家，让大家一起完善。<br>​<h2 id="赋能"><a href="#赋能" class="headerlink" title="赋能"></a>赋能</h2>回到前端深水区这个话题，为什么说“不是前端工程师进入深水区，而是部分页面开发人员进入深水区”呢？其实本质就是：经过这几年的前端技术的发展，部分问题已经被很好的被通用方案解决了，而这个通用方案就是“赋能”。<br>​<h3 id="过桥"><a href="#过桥" class="headerlink" title="过桥"></a>过桥</h3>村子旁边有条河，很多司机开车想过河，村长只得造桥，造桥就需要找一堆木匠铁匠做材料，还要有专业造桥师傅把材料组装成桥。辛辛苦苦终于桥造好过河了。过两天回来，还是同一条河，也许是桥塌了，也许是过河位置不同了，想要再次过河，就需要再造一座桥。久而久之，河上一座座桥，当再次开车到来，看到这些桥也很犹豫，有些桥宽度不对上不去，有些桥年久失修，怕开上去走一半就掉河里了。<br>​<br>于是村长组织下开发了一座钢铁大桥，让大家都走这条大桥。但终究河流很长，想要过河只能绕路。大桥走的车不断增多，铁匠、木匠、造桥师傅觉着每天干着同样的事情没啥意思，也是走一波又来一波，钢铁大桥维护也愈发困难，毕竟还有很多车在上面跑也不可能把桥封了做一次完整的检修。<br>​<br>终于村长动员村里的高材生，做了一个自动造桥车，能够自动铺设一定宽度范围的桥，待开车过去之后再将桥回收。司机只要从村长这里租一下自动造桥车就能过桥。随着自动造桥车功能不断完善能满足的车型种类不断增多，所有的小车都能过桥了。<br>​<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3>比如上面过桥的故事中村长就是技术TL，司机就是业务，过桥好比业务需求。一开始，业务每次提出需求技术TL都要找团队里成员去开发，这些单页面开发也没有考虑复用性，于是每次来一个需求就开发一个页面，团队成员刚开始会为自己完成工作而自豪，久而久之就会觉着没有成长了；而所谓的钢铁大桥，其实就是一个超级页面，这个超级页面初期能够满足多个相似业务需求，但随着业务不断发展差异化不断增大，超级页面变得愈发臃肿。最终变得不可维护，而由于太多业务依旧在跑，也没人敢动；而自动造桥车其实就是“可视化搭建”，业务根据需要去定制自己的页面，搭建过程全程技术团队基本不需要参与，技术团队只要不断打磨可视化搭建，让其满足更多相对通用的诉求。而当实在无法满足时，别忘了我们还有钢铁大桥。<br>​<h3 id="消除问题"><a href="#消除问题" class="headerlink" title="消除问题"></a>消除问题</h3>一种对赋能的典型曲解就是：“你们前端搞赋能，就是为了转嫁成本给其他岗位”。赋能并不是让他人来我们的领域替我们做事，而是让他人能做他们想做的事而不用深入到我们的领域之中。在这里，司机不再需要找村长要工匠，不再需要关注造桥的进度和流程，他只需要将自己需要的桥的一些信息告诉自动造桥车就行了。到了业务上，业务想上线一个页面，不再需要召集开发资源，不再需要关注页面开发流程，只需要将页面信息告诉可视化搭建平台，就能实现页面的上线。<br>​<br>前端的赋能将前端的研发投入从业务需求的投入转向赋能工具的投入，这前提肯定是对于这个业务领域有很深的理解和沉淀，能归纳其中大部分业务需求的本质，从中提炼出通用的工具化技术方案。通过前端赋能的方式，消除掉了这个业务域下的问题。而目前，在集团内有相当多的产品都在做着这样的事情，只不过它们关注的问题种类不同。有些关注页面的渲染——用户侧的诉求（imgcook、fusion等等），有些关注页面和数据的绑定——商业的诉求（投放系统等等），有些关注页面的快速上线——串联的诉求（斑马、方舟、千叶等等），这些产品汇聚到一起，将一部分业务形态的问题彻底消除。<br>​<h2 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h2><h3 id="金字塔结构"><a href="#金字塔结构" class="headerlink" title="金字塔结构"></a>金字塔结构</h3>当一个域的问题被工具彻底消除的时候，问题不再存在，就意味着除了开发这些工具的人以外，之前解决这些问题的人将无法产生价值，必将遭到淘汰。前端是金字塔结构，金字塔顶端的人虽然人不多但是找到了问题的本质并持续探求消除问题的方案。而金字塔的腰部则是一些深入业务并利用顶部人员给出的方案与业务深度结合在业务上创造价值的人。而金字塔的底部则是完成业务需求的工具人，这一部分人终将遭到淘汰。<br>​<h3 id="深水区"><a href="#深水区" class="headerlink" title="深水区"></a>深水区</h3>所以说不是前端进入深水区，而是部分页面开发进入深水区，如会场页面、列表、表单等部分页面开发的问题已经大体上被解决，因此必然会有一部分人遭到淘汰。而随着工具的能力不断增强，赋能的强度不断增大，业务和工具之间的距离被逐渐缩短，被淘汰的人也会逐渐增多。最终这些人需要继续创造价值，只有三个方向：1. 足够理解业务并能决策业务，利用业务创造价值。2. 利用自己在业务中摸爬滚打的经验沉淀，提升工具的覆盖范围。3. 跳出当前的领域，去其他没有被工具化的领域创造价值。<br>​<h2 id="跳出深水区"><a href="#跳出深水区" class="headerlink" title="跳出深水区"></a>跳出深水区</h2><h3 id="理解业务"><a href="#理解业务" class="headerlink" title="理解业务"></a>理解业务</h3>前端很多时候不是单独负责一个业务，而是一个人负责多个业务，而且还经常拥抱变化。而与业务接触久了，就会发现一些业务上的问题，自己也会产生一些想法。这些想法可能是单纯业务上，也可能会结合技术。之前在我毕业没多久有人教育我说，要抬头做技术，低头做业务：多吸取其他技术方案，深入业务了解业务。但这个方式一开始没问题，但一段时间之后要做到低头做技术，抬头做业务：将吸取到的技术深入结合到业务之中，还需要吸取其他业务的思路，防止在一个业务之中陷入思维定式。<br>​<h3 id="提升工具"><a href="#提升工具" class="headerlink" title="提升工具"></a>提升工具</h3>现在大多数消除问题的工具，都只能消除一些特定的业务形态。而产生价值的另外一个方式，还是需要找到自己、 团队所负责业务的形态，如果它们不能被通用的工具消除，需要思考为什么，是做不到，还是不想做，然后思考怎样才能做到消除。只要有诉求，而工具无法解决，那就存在机会。当然这里还是要考虑投入产出比的。<br>​<h3 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h3>而前端工程师作为用户侧解决问题的研发人员，跳出已经被消除问题的业务形态，我们会发现其实还有很多目前很难被解决的问题值得我们去探索，而这些探索需要我们跳出传统的页面开发技术领域，与其他的技术领域进行结合，才有机会成为金字塔顶端的人：<br>​</li><li>与图形学结合：2D、3D互动</li><li>与机器学习结合：智能UI</li><li>与客户端结合：Flutter</li><li>与服务端结合：Serverless、Faas</li><li>与硬件集合：IOT<br>​<br>技术终究是产生价值的工具，前端工程师应该站在解决用户侧问题的角度来找到问题、选用合适的工具、解决问题并沉淀不断完善工具库。不应将自己限制在手头上仅有的几个工具之中，做一个只有工具四处找问题的工具人。<br>​<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2>本来这篇文章是想放在2019个人总结里的，但是发现有一定篇幅就单独拿出来了，只是个人过去一年看到的一些事情带来的思考，都是讲大道理没什么干货。我也在扩展自己的技术领域，给自己定的目标是2020年至少一半以上书籍是非前端技术书籍。还是希望有朝一日自己能成为金字塔顶端的人，而不是站在底端待在舒适区里等着被淘汰。<br>​<br>​</li></ul>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <category domain="http://lingyu.life/tags/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <comments>http://lingyu.life/2020/03/03/new/deepwaterzone/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2019年游戏总结</title>
      <link>https://lingyu.life/#/post/2020/03/03/new/2019review</link>
      <guid>https://lingyu.life/#/post/2020/03/03/new/2019review</guid>
      <pubDate>Mon, 02 Mar 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;2019年已经接近尾声，而12月也没啥特别想玩的游戏而且事情比较多，所以差不多可以总结下今年的玩的游戏了。总计玩超过20小时的21个，白金奖杯9个，离预计的目标10个白金差一点，但是由于存在像神界原罪2和怪物猎人冰原这样的达成率1%以下的高难度白金，总体也算达成KPI。以下是对游戏的主观评分。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>2019年已经接近尾声，而12月也没啥特别想玩的游戏而且事情比较多，所以差不多可以总结下今年的玩的游戏了。总计玩超过20小时的21个，白金奖杯9个，离预计的目标10个白金差一点，但是由于存在像神界原罪2和怪物猎人冰原这样的达成率1%以下的高难度白金，总体也算达成KPI。以下是对游戏的主观评分。</p><a id="more"></a><h2 id="评分标准"><a href="#评分标准" class="headerlink" title="评分标准"></a>评分标准</h2><blockquote><p>以下所有评价均为本人主观观点，如不赞同也很正常，每个人喜好不同，高分低分都信自己<br>1分=无法游玩<br>2分=坑钱粪作<br>3分=垃圾游戏<br>4分=缺点太多<br>5分=勉强能玩<br>6分=普普通通<br>7分=值得尝试<br>8分=优秀佳作<br>9分=不容错过<br>10分=神作</p></blockquote><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><table><thead><tr><th align="center">主机</th><th align="center">平台</th><th align="center">进度</th><th align="center">评分</th><th align="center">个人感受</th></tr></thead><tbody><tr><td align="center">荒野大镖客 救赎2</td><td align="center">PS4</td><td align="center">主流程30%，半弃坑</td><td align="center">8分</td><td align="center">还原了一个无比生动的西部世界，有剧情、有画面、有战斗、有细节，但开放世界玩法本身就很容易割裂游戏体验，而这游戏过慢的节奏进一步加剧了这个问题</td></tr><tr><td align="center">SNK女杰狂热大乱斗</td><td align="center">PS4</td><td align="center">白金</td><td align="center">6分</td><td align="center">只保留了SNK中的女性角色的格斗游戏，将格斗游戏降低了门槛，搓招更容易，走胡逼路线战斗花里胡哨。而且有丰富的换装系统，总而言之是个萌豚向游戏</td></tr><tr><td align="center">神界原罪2</td><td align="center">PS4</td><td align="center">白金</td><td align="center">10分</td><td align="center">可以说是近年来玩到最好玩的RPG游戏，优秀的世界观塑造+跌宕起伏的剧情+影响深远的支线任务+充满灵魂的角色塑造+灵活的角色build+异想天开的战斗策略+可圈可点的装备系统，目前最接近我心目中完美的RPG游戏了</td></tr><tr><td align="center">鬼泣5</td><td align="center">PS4</td><td align="center">DK难度通关</td><td align="center">8分</td><td align="center">大一时候沉迷鬼泣4玩了一百多个钟头，鬼泣5算是情怀了。这游戏基本也没啥剧情，突出一个爽就完事了。这游戏搓招要求精准无比，按键非常多，而且经常需要长按，最好有个精英手柄+背键，否则手会非常累。自己玩和看别人玩也是两个游戏，上限非常高</td></tr><tr><td align="center">只狼 影逝二度</td><td align="center">PS4</td><td align="center">白金</td><td align="center">10分</td><td align="center">TGA年度游戏名副其实，宫崎老贼真的牛逼。同样是ACT，只狼并没有像鬼泣5门槛超高的操作，更多靠的是对敌人的熟悉和反应，这一点其实还是黑魂那一套。前期不熟悉非常受苦，后期熟悉了就是各种玩花活儿。打铁那声音真的让人血脉喷张</td></tr><tr><td align="center">勇者斗恶龙 创世小玩家2</td><td align="center">PS4</td><td align="center">白金</td><td align="center">8分</td><td align="center">可以理解为一款有剧情的MC，能种田、能造房子、还能打怪，也继承了一代就有的攻城战防守，队友帮忙建造也使得大型建筑的建造过程不那么枯燥，一代通关后可玩性太低的问题也有所改善，挺让人沉迷</td></tr><tr><td align="center">仙剑奇侠传6</td><td align="center">PS4</td><td align="center">游戏20分钟，弃坑</td><td align="center">1分</td><td align="center">软星的吃相如此难看真实震撼我妈，本来仙6就不算一款好的仙剑游戏，放到PS4上连流畅运行都无法做到，而且完全没有补丁来修正，圈钱也没见过这么不要脸的，真是拜仙剑这个IP的口碑</td></tr><tr><td align="center">奈尔克与传说的炼金术士们</td><td align="center">PS4</td><td align="center">白金</td><td align="center">7分</td><td align="center">完全不是历代炼金工坊的RPG的玩法，而是一款模拟经营游戏，作为一个资本家，把炼金工坊20代的主角配角全都拉到你的麾下为你打工，安排他们采集、种植、炼金、开店，满足不断扩大的城市居民需要，炼金工坊系列粉丝向游戏，单纯作为模拟经营游戏也还算不错</td></tr><tr><td align="center">巫师之昆特牌 王权的陨落</td><td align="center">PS4</td><td align="center">白金</td><td align="center">8分</td><td align="center">其实我个人并不是特别喜欢卡牌类游戏。但这款游戏虽然主体是打牌，其实更多时候更像是利用卡牌来解谜，这游戏也有较为优秀的剧情以及影响深远的分支选择，而且包含一定的收集要素。当然单论打牌也算非常有趣，而且本地化做的很棒</td></tr><tr><td align="center">龙之信条 黑暗觉者</td><td align="center">PS4</td><td align="center">白金</td><td align="center">8分</td><td align="center">听了gamker的推荐才去玩的，这游戏可以说是一款完美游戏的半成品，卡婊怪猎组做的游戏，战斗让人非常的血脉喷张，打击感十足，各种大型怪物也是战斗体验拉满。但可惜地图太小整体内容较少，而且跑路蛋疼，支线较少，开放世界地图略空洞。这游戏剧情前中期都是白开水一般平平无奇，直到最后豁然开朗，让人感叹世界观设定之牛逼</td></tr><tr><td align="center">鲁弗兰的底下迷宫与魔女旅团</td><td align="center">PS4</td><td align="center">白金</td><td align="center">8分</td><td align="center">据说是全宇宙最好的DRPG，看着日呆萌二画风，但其实剧情很有深度，很多细节仔细推敲都是细思恐极充满血腥黑暗。DRPG讲究的探索体验和队伍搭配都做的很不错，有策略有难度。但毕竟是日本一的游戏，最后依旧是强制的刷刷刷，导致后期游戏体验割裂。</td></tr><tr><td align="center">怪物猎人世界冰原</td><td align="center">PS4</td><td align="center">白金</td><td align="center">9分</td><td align="center">本质上其实就是怪物猎人世界G，增加了不少本体怪物的亚种，也引入了很多情怀老怪物，一直到天地皇啼龙体验都非常棒。但之后的巨魔之地就非常蛋疼了，强制要求大量的无脑刷，装备毕业的珠子也是把肝度拉满。但就算刷到一套极限套装，也并没有对应强度的怪物去挑战。刷着空虚，刷完更空虚。另外为了强推钩爪导致部分怪物狩猎体验极差，钩爪的判定由很蛋疼，加上一些憨批的怪物换区问题，很多时候打怪体验被强行割裂体验极差，让人想骂街。但终究是个非常优秀的游戏</td></tr><tr><td align="center">嗜血代码</td><td align="center">PS4</td><td align="center">进行中</td><td align="center">7分</td><td align="center">还在玩，目前玩下来是二次元里最魂的，魂里最二次元的。人设优秀媚宅，色度拉满。战斗上继承了二次元的通病，不过已经算是二次元游戏里打击感比较好的了。毕竟魂like游戏，抄还是抄的不错的，不过有些用力过度，部分地图为了难而难。剧情还算不错</td></tr><tr><td align="center">火焰纹章风花雪月</td><td align="center">NS</td><td align="center">困难黑鹫+金鹿通关</td><td align="center">9分</td><td align="center">把IF里面的养成进一步强化，可以说是半战棋+半养成游戏，游戏背景设定也是非常优秀，加上火纹一贯的优秀系统和人设，还有4条主线，玩起来非常让人沉迷。几条剧情线各有各的优劣，唯一的遗憾就是没有一个完美结局吧</td></tr><tr><td align="center">牧场物语哆啦A梦</td><td align="center">NS</td><td align="center">进行中</td><td align="center">6分</td><td align="center">阉割版牧场物语，但是有了哆啦A梦的IP加成。虽然没有了结婚生子，很多地方都做了简化，游戏剧情也是弱智度拉满，但牧场物语这一套游戏模式还是很让人沉迷。毕竟是一个没有任何压力的游戏，非常适合下班疲劳回家玩一玩</td></tr><tr><td align="center">新马里奥兄弟U</td><td align="center">NS</td><td align="center">流程通关</td><td align="center">6分</td><td align="center">去年买的中间搁置了很久，中间游戏荒就拿出来通关了。公主又被库巴绑架了。游戏体验还算不错，难度也是非常高。关卡设计确实很棒，但这游戏也就仅限于此了</td></tr><tr><td align="center">文明6</td><td align="center">NS</td><td align="center">20~30小时</td><td align="center">5分</td><td align="center">NS上的文明让人随时随地能再来一个回合，由于是移植，不过还是针对NS做了很多优化的，不过感觉优化都是针对掌机模式，UI在主机模式下大的过分，而且由于手柄操作本来就很蛋疼，尤其征服胜利后期那么多单位一个个操作痛苦不堪，后期还特别卡，体验远低于PC</td></tr><tr><td align="center">精灵宝可梦剑</td><td align="center">NS</td><td align="center">流程通关，全图鉴中，半弃坑</td><td align="center">5分</td><td align="center">删精灵其实没什么，400只也是能撑的起游戏体验的，但这一作到处毫不掩饰的赶工痕迹让我们这些老破壳萌玩家极度失望。完全没有设计的三个道馆、稀烂的剧情、基本没有迷宫、没有二级神、没有四天王、人设虽好但都是没灵魂的路人，二周目也是没啥乐趣，作为一个RPG连最基本的要素都没做好。可就算这样，还是得买，毕竟没有其他地方能玩到正统宝可梦</td></tr><tr><td align="center">圣女战旗</td><td align="center">PC</td><td align="center">37H，中等难度流程通关</td><td align="center">7分</td><td align="center">非常老派的SRPG游戏，国产游戏，九酱子的立绘太让人射爆了。整体而言非常的传统，让我想起当年玩炎龙的快乐时光。职业互克过强导致逆职业打基本上不太可能，而由于绝大多数地图都是开阔地带，且这游戏没有ZOC，敌人攻击范围和移动距离也很广，导致后期经常因为突然的切后排而回档体验割裂</td></tr><tr><td align="center">纪元1800</td><td align="center">PC</td><td align="center">136H，世博会+8W投资人</td><td align="center">9分</td><td align="center">一款能从早上玩到第二天早上的城市模拟游戏，当我想起当年凯撒大帝3的快乐时光。一局玩60-70小时随随便便，不断升级的人口层级和产业链的搭配让人根本停不下来，更何况还有NPC势力+海盗势力对战，就算关掉NPC单纯建设城镇满足屁民的需要也非常有趣</td></tr><tr><td align="center">帝国时代2决定版</td><td align="center">PC</td><td align="center">2H，进行中</td><td align="center">8分</td><td align="center">有生之年系列，微软是真的不差钱。帝国时代2这重置算是非常良心了，不仅画面升级，原汁原味全势力全战役，还增加了孙子兵法让不擅长RTS的玩家学习上手。可惜打完一局之后没有像三代一样的沉淀，不过也算良心了</td></tr><tr><td align="center">全面战争三国</td><td align="center">PC</td><td align="center">43H，统一全国2次</td><td align="center">8分</td><td align="center">全战三国算是非常良心了，大地图策略，小战役即时的玩法业内也没有竞争对手，不同类型势力还有不同的科技升级方式。节奏和三国志比较像，早期玩个破局，中期玩个外交拉锯，后期玩个无双割草。但三国的要素还是太少，独立立绘很少，很多知名武将基本上淹没在了自动生成武将之中。是一款优秀的全战游戏，但绝对不是一款好的三国游戏</td></tr><tr><td align="center">波西亚时光</td><td align="center">PC</td><td align="center">76H，主线通关</td><td align="center">7分</td><td align="center">国产游戏，也是个模拟经营游戏，和牧场物语、星露谷物语很像，但主打产品线制作完成订单而不是种田，后期更是全自动工业化生产。原料批量生产略枯燥，但也加入了一些收集要素，也能结婚也能装修自己的房子，扩大自己的农场（工坊）。剧情比较简单，不过深入会有一些私货，结婚要谨慎</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正好TGA刚过去，评了一堆年度游戏，我也来一发TianGA，评一下我自己的年度游戏：</p><ul><li>年度最烂游戏：仙剑奇侠传6</li><li>年度最肝游戏：怪物猎人冰原</li><li>年度复古游戏：帝国时代2决定版</li><li>年度失望游戏：精灵宝可梦剑盾</li><li>年度最爽游戏：只狼</li><li>年度种田游戏：纪元1800</li><li>年度二次元游戏：火纹风花雪月</li><li>年度最佳前三游戏：1. 神界原罪2、2. 只狼、3. 怪物猎人冰原</li></ul>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/">游戏人生</category>
      
      
      <category domain="http://lingyu.life/tags/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      
      <comments>http://lingyu.life/2020/03/03/new/2019review/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>玩函数式编程有感</title>
      <link>https://lingyu.life/#/post/2020/03/01/new/functionalthink</link>
      <guid>https://lingyu.life/#/post/2020/03/01/new/functionalthink</guid>
      <pubDate>Sat, 29 Feb 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;之前有了解过函数式编程，也用过ramda库做一些数据转换，但一直没有深入。最近仔细思考了一下自己最近一两年的工作内容和自己的能力模型，发现自己做的绝大多数事情都比较简单粗暴，缺乏结构化的设计与思考，缺少对复杂问题的抽象与沉淀。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>之前有了解过函数式编程，也用过ramda库做一些数据转换，但一直没有深入。最近仔细思考了一下自己最近一两年的工作内容和自己的能力模型，发现自己做的绝大多数事情都比较简单粗暴，缺乏结构化的设计与思考，缺少对复杂问题的抽象与沉淀。</p><a id="more"></a><h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><p>在我个人看来，前端工程师实际上是在做前端相关工作的工程师，首先立足点是工程师，然后才是前端这个领域。工程师核心能力就是对一个复杂问题进行抽象，自顶向下逐步细化，再自底向上逐步实现，形成一个工程，最终解决问题。</p><p>举个例子，比如我们要做一个移动端业务需求，通常都会有一些自顶向下的细化抽象的流程，比如：应用 =&gt; 页面 =&gt; 区块 =&gt; 模块 =&gt; 业务组件 =&gt; 原子组件 =&gt; 标签 这么一个流程。但实际上由于各种完善的内部搭建系统的存在和职责细分，有产品和设计师解决了应用、页面以及部分区块的抽象，而各种组件的封装解决了部分业务组件、原子组件、标签的抽象，因此最终我们可能只需要实现部分区块、模块、部分业务组件的抽象。最终可能就是简单的代码堆砌就能完成需求。当然这里我并不是说这种开发方式不好，这样确实可以大幅度提升开发效率，在单位时间内完成更多的业务需求。但作为一个工程师，局限在小范围的问题之中，问题抽象的发挥空间有限，长久往复就会变成”无情的切图机器“。</p><p>要跳出这个局限范围有很多的方式，向上与业务一同基于业务思考去做应用、页面的抽象，向下与基建团队一同共建组件基础，当然也可以跳出这个移动端页面开发范围去投入诸如前端工程化、端能力建设、前端智能化等全新的范围。总体而言就是扩大自己的抽象能力发挥空间，通过解决更大的问题，来实现更大的自我价值。当这个空间足够大时，就可以拍着胸脯说自己是”架构师“了。</p><p>当我们面临更大的问题，就需要更多抽象问题的方法。我认为一个优秀的架构师，会针对所需要解决的问题以及问题的上下文，找到最合适的抽象方法来对问题自顶向下的细化，然后再选择最合适的方案来自底向上去实现，最终交付这个问题的完整解决方案。</p><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>而所谓编程范式，就是抽象问题的方法。</p><p>比如命令式编程，其实就是把问题抽象成一步步的流程，进而将流程转化为代码控制机器按照你所设想的流程运行，这种方式可以适合解决一些小范围的问题，对于机器是有好的，但并不符合人类的思维方式。而面向对象则是把问题抽象成一个个对象，对象将数据和操作它的方法封装来解决局部子问题，再通过各种继承、组合等方式将对象联系起来来解决更大范围的问题。而函数式编程则是把问题抽象成一个个函数，在函数内部来解决子问题，再通过各种函数的组装生成更多的函数来解决更大范围的问题。</p><p>仔细思考我们所编写的代码，实际上一直都是在操作数据，而面向对象的核心是数据，函数式编程的核心是操作。个人认为它们没有优劣之分，而是两个不同角度看待问题的产物。当我们需要机器做的事情是模拟的是一个名词，比如人，那么面向对象显然更合适。当我们需要机器做的事情是模拟一个动词，比如修改，那么函数式显然更合适。</p><h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h2><p>回到前端开发上面来，回归到日常页面开发中。前端页面的开发本质上其实分为两部分，一个是数据加工成UI，一个是用户操作改变数据，而MV*就是在解决这两个问题。</p><p>那么面向对象的方式是如何开发页面的呢？我们将页面上的模块或区域拆分成一个个对象，对象内部封装了一些内部状态以及状态变更的行为， 另外还会封装一些UI绘制，对象对外也有一些方法来输入输出数据。对于第一部分——数据加工成UI，我们是通过对象的联系，将数据交给对象然后对象自己通过他们创建的联系进行分发。而对于第二部分——用户操作改变数据，如果只是在一个对象内部的状态变化还算简单，当所触发的变化横跨多个对象，那么对于这些变化就强依赖对象之间提前建立的联系。这里就会发现一个问题，UI渲染本身是一颗树，而创建的对象本应与这棵树有明确的对应关系，但由于这些对象为了满足数据变化所建立了各种复杂的关系，使得对象之间又形成了一张网。在这个网的每个节点自身的状态加上网本身的复杂度提升，就带来了不确定性。早年间的天猫都是KISSY+模板引擎+Class的方式就是这个问题。一旦页面复杂起来，基本上就变得无法维护了。</p><p>这里其实就是问题的抽象不合理导致的。我们回头再看这两部分，第一部分数据加工成UI，第二部分用户操作改变数据。第一部分数据和UI是名词，加工是动词。第二部分用户和数据是名词，操作和改变是动词。按照面向对象抽象名词，函数式抽象动词的方式，我们发现之前我们强行将动词抽象按照名词使用面向对象进行抽象，显然是不合适的。</p><p>那么我们换一种抽象方式。将UI、数据、用户使用面向对象抽象，再将加工、操作、改变抽象成函数，然后仔细想一下就会发现，这不就是React + Redux么？UI就是一个个的Component、而数据就是Store、用户就是Action，操作就是dispatch、改变和加工就是reducer。</p><p>进一步思考数据加工成UI这一部分，UI是什么？Class Component的思路就是我们确实是有UI，它是一个实体所以它是一个对象。UI对象由子UI对象或VDOM组合而成。而到了Hooks其实就是换了个角度，其实我们没有UI，我们是在绘制UI，这一部分用函数式的说法就是数据加工并绘制界面，加工和绘制都是动词，输入是数据，输出是界面也就是VDOM。绘制过程由子绘制过程组合而成。可以看到Hooks实际上是React更加函数化的方式，在将加工、操作、改变等动词函数化之后，进一步将之前作为名词的UI也函数化。当然这只是一个表面的变化，React内部的机制也更加的函数式，这里就不展开了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>吹逼吹了这么多，你可能会有疑问，这篇文章究竟想表达什么？安利函数式编程？答案是否定的。我在并不是在呼吁大家都来函数式编程然后把代码全部重构，而是表达我对于问题抽象方式思考的一些看法。毕竟知乎上各种编程大牛们整天吵来吵去也没个结果。而我觉得作为一个工程师，不管是面向对象也好，还是函数式编程也好，最重要的是沉淀出一套行之有效的抽象问题的方法论。当遇到问题的时候，能够根据问题的本质找到最合适的切入角度来拆解细分。我个人也在不断寻找这一套方法论。今天这一站是函数式编程，明天可能又会是其他的什么东东。所谓工程师，最重要的还是解决问题的能力。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</category>
      
      
      <category domain="http://lingyu.life/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</category>
      
      
      <comments>http://lingyu.life/2020/03/01/new/functionalthink/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于博客重启</title>
      <link>https://lingyu.life/#/post/2020/02/29/new/restart</link>
      <guid>https://lingyu.life/#/post/2020/02/29/new/restart</guid>
      <pubDate>Fri, 28 Feb 2020 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;经过5年的沉寂，我决定在2020年2月的最后一天，决定把早已经挂掉的博客重启&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>经过5年的沉寂，我决定在2020年2月的最后一天，决定把早已经挂掉的博客重启</p><a id="more"></a><h2 id="拥抱变化"><a href="#拥抱变化" class="headerlink" title="拥抱变化"></a>拥抱变化</h2><p>从毕业入职到现在约有5年了，在这5年的过程中先后主要负责天猫商品、天猫搜索、手猫导购业务等。从PC到Mobile，从2B到2C，中间还做了诸如双十一狂欢城这样的互动业务，也做过天猫基础工具链、稳定性告警平台这样的前端基础能力工作。在这几年里，拥抱了不少变化，和不少其他岗位的人又合作，也接触到很多之前从未接触到的领域，收获还是非常多的。</p><p>而这几年没有怎么更新博客，主要问题有几个：</p><ol><li>确实业务比较忙，写文章是个非常耗时耗力的过程，保障文章内容的完整性和准确性需要很多时间</li><li>接触了很多大牛，觉得自己在这个领域做的事情很浅显，容易被别人鄙视</li><li>内网其实我也沉淀了一些文章，但由于多多少少和内网的系统强相关，所以没有办法发布到外网</li><li>域名到期被不知道谁给注册了，而且云存储啥的都出现问题，网站挂掉就懒得弄了</li></ol><p>那我为什么现在又要把博客重启呢？说白了还是<strong>输出倒逼输入</strong>。</p><p>最近一年拥抱了不少变化，跟着组织架构调整先后换了好几个团队。从半技术半业务的团队，换到了纯业务团队。而在这些变化的过程中，手上的业务负担也是越来越重，输入学习的时间越来越少。于是乎不断的寻找方法来打破这个局，也因此有了一些思考。</p><h2 id="沿途的风景"><a href="#沿途的风景" class="headerlink" title="沿途的风景"></a>沿途的风景</h2><p>之前有明确的目标，一路走来却发现在这过程中，做过的事情、做过的项目，并不只是PPT上的一页成果，而应该成为自己技术壁垒的一块青砖。在这其中非常重要的点是<strong>结构化和体系化</strong>。</p><p>拿之前做天猫基础工具链举例，在做的过程中，我主要是一些功能点怎么实现：</p><ul><li>项目如何初始化</li><li>怎么做资源代理</li><li>怎么构建</li><li>怎么做请求转发</li><li>等等等等</li></ul><p>最后也做上去了，服务了整个天猫业务。但后来淘系合并，这一套工具链就被废弃掉了。</p><p>这里拿我做这套工具链的过程来说明一下结构化和体系化。</p><h3 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h3><p>废弃掉之后，站在我个人角度而言，在这过程中，各个功能点其实都是离散的，看起来并没有太多交集。我参与了工具链的开发，确实积累了一些工具链开发的经验，但也仅限如此了。假如真让我去做一个前端自动化平台的TL带着团队搞，必然是会蒙圈的。核心问题在于，在过去做这套工具链的过程中，我并没有将整个工具链中的知识和思考提炼，将其中内在的关系汇聚在一起，形成产品思维，进而查漏补缺，将这个工具产品优化。</p><p>比如构建，我专注于gulp和webpack的构建配置、以及各种插件的花式调用。但实际上，在不同构建器开发的过程中，可以找到构建器的通性——对一段某种规范的代码的转化，而站在代码转化的来思考时，就不只是构建这么简单了，编码的规范、目录的规范、资源的管理、依赖关系的管理、构建流程的差异化、构建产物的一致性和安全性等等其实都殖代码转化过程中需要考虑的内容。这其中大概遵循如下流程：</p><ol><li>将多个零散的点中的共性进行提炼，形成一个上层的理念</li><li>在这个理念上进行思考，向下推导并穷举所有功能点</li><li>找到缺失的功能点去补全完善</li><li>然后将这个上层理念和其他理念进行共性提炼，重复1-3步，直至到达整个产品的核心理念</li></ol><p>最终通过这种方式，我们能够构建出一颗树，而这棵树就包含了整个产品的能力，以及每个部分满足的核心诉求。</p><p>通过这种结构化的方式，我们就能将自己零散的知识汇聚起来，沉淀成为方法论，后续再遇到类似的问题，只需要稍稍对这棵树进行增加或删减，就足够了。</p><h3 id="体系化"><a href="#体系化" class="headerlink" title="体系化"></a>体系化</h3><p>所以结构化是自底向上把零散的点组织起来，那体系化又怎么解释呢？所谓体系化，其实就是跳出所做的具体的事情，直接定义一个大的领域，然后自顶向下来推导，构建自己在这个领域的知识结构。</p><p>还是刚才的工具链，我们跳出做工具链这个范畴，直接上升到前端工程化这个领域，工具链是这个领域的一环，但这个领域远远不止工具链。工具链能够实现本地开发流程的提效，但放眼整个前端工程化领域，还有很多方式能提效，也能解决本地开发存在的一些问题。比如通过建设统一的模块体系以实现模块复用，这其中就涉及到统一的模块规范、模块加载器实现、模块生命周期管理、模块分析等等的一体化平台。又或是采用云端构建发布的方案来规避本地开发流程中存在的一致性问题和安全性问题，这其中就涉及到资源管理、容器技术、代码分析校验、持续集成、多环境部署、服务协同等等。可以看到，当我们跳出来纵观整个体系的时候，肯定很多东西是在做单纯工具链所不会接触到的。</p><p>总结下来就是，做了一件事情后，站在这个领域自顶向下看，补足自己不了解的部分，形成领域内知识的闭环，形成自己的一套领域解决方案，才能真正称之为这个领域的专家</p><h2 id="回到重启博客这件事"><a href="#回到重启博客这件事" class="headerlink" title="回到重启博客这件事"></a>回到重启博客这件事</h2><p>结构化自底向上，依赖的是对所做之事的提炼和归纳。体系化自顶向下，依赖的是对所做领域的思考与深化。这两部分的前提，就是将自己的所做的事情，以及所想的理念，沉淀下来形成片段。然后定期将这些片段梳理，了解自身的长处和短板，针对性的去学习，才能实现知识闭环。而博客是最好的归纳及思考的土壤。</p><h2 id="后续的计划"><a href="#后续的计划" class="headerlink" title="后续的计划"></a>后续的计划</h2><p>暂定是每1周有一篇文章的产出，包括但不限于所做之事的总结，所见之物的看法，所想之事的唠叨，包括但不限于技术、生活、游戏等等。如果周末确实有其他事，就顺延一周。另外搬运了几篇能放到外网的文章过来，后续纯技术类的文章和分享PPT都会同步到博客内。希望自己通过这种方式有所成长</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <category domain="http://lingyu.life/tags/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <comments>http://lingyu.life/2020/02/29/new/restart/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>聊一聊前端自动化测试</title>
      <link>https://lingyu.life/#/post/2016/03/07/new/autotest</link>
      <guid>https://lingyu.life/#/post/2016/03/07/new/autotest</guid>
      <pubDate>Sun, 06 Mar 2016 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;以前不喜欢写测试，主要是觉得编写和维护测试用例非常的浪费时间。在真正写了一段时间的基础组件和基础工具后，才发现自动化测试有很多好处。测试最重要的自然是提升代码质量。代码有测试用例，虽不能说百分百无bug，但至少说明测试用例覆盖到的场景是没有问题的。有测试用例，发布前跑一下，可以杜绝各种疏忽而引起的功能bug。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>以前不喜欢写测试，主要是觉得编写和维护测试用例非常的浪费时间。在真正写了一段时间的基础组件和基础工具后，才发现自动化测试有很多好处。测试最重要的自然是提升代码质量。代码有测试用例，虽不能说百分百无bug，但至少说明测试用例覆盖到的场景是没有问题的。有测试用例，发布前跑一下，可以杜绝各种疏忽而引起的功能bug。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为何要测试"><a href="#为何要测试" class="headerlink" title="为何要测试"></a>为何要测试</h3><p>自动化测试一个重要特点就是快速反馈，反馈越迅速意味着开发效率越高。拿UI组件为例，开发过程都是打开浏览器刷新页面点点点才能确定UI组件工作情况是否符合自己预期。接入自动化测试以后，通过脚本代替这些手动点击，接入代码watch后每次保存文件都能快速得知自己的的改动是否影响功能，节省了很多时间，毕竟机器干事情比人总是要快得多。</p><p>有了自动化测试，开发者会更加信任自己的代码。开发者再也不会惧怕将代码交给别人维护，不用担心别的开发者在代码里搞“破坏”。后人接手一段有测试用例的代码，修改起来也会更加从容。测试用例里非常清楚的阐释了开发者和使用者对于这端代码的期望和要求，也非常有利于代码的传承。</p><h3 id="考虑投入产出比来做测试"><a href="#考虑投入产出比来做测试" class="headerlink" title="考虑投入产出比来做测试"></a>考虑投入产出比来做测试</h3><p>说了这么多测试的好处，并不代表一上来就要写出100%场景覆盖的测试用例。个人一直坚持一个观点：<strong>基于投入产出比来做测试</strong>。由于维护测试用例也是一大笔开销（毕竟没有多少测试会专门帮前端写业务测试用例，而前端使用的流程自动化工具更是没有测试参与了）。对于像基础组件、基础模型之类的不常变更且复用较多的部分，可以考虑去写测试用例来保证质量。个人比较倾向于先写少量的测试用例覆盖到80%+的场景，保证覆盖主要使用流程。一些极端场景出现的bug可以在迭代中形成测试用例沉淀，场景覆盖也将逐渐趋近100%。但对于迭代较快的业务逻辑以及生存时间不长的活动页面之类的就别花时间写测试用例了，维护测试用例的时间大了去了，成本太高。</p><h2 id="Node-js模块的测试"><a href="#Node-js模块的测试" class="headerlink" title="Node.js模块的测试"></a>Node.js模块的测试</h2><p>对于Node.js的模块，测试算是比较方便的，毕竟源码和依赖都在本地，看得见摸得着。</p><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><p>测试主要使用到的工具是测试框架、断言库以及代码覆盖率工具：</p><ol><li>测试框架：<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>、<a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>等等，测试主要提供了清晰简明的语法来描述测试用例，以及对测试用例分组，测试框架会抓取到代码抛出的AssertionError，并增加一大堆附加信息，比如那个用例挂了，为什么挂等等。测试框架通常提供TDD（测试驱动开发）或BDD（行为驱动开发）的测试语法来编写测试用例，关于TDD和BDD的对比可以看一篇比较知名的文章<a href="http://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/" target="_blank" rel="noopener">The Difference Between TDD and BDD</a>。不同的测试框架支持不同的测试语法，比如Mocha既支持TDD也支持BDD，而Jasmine只支持BDD。这里后续以Mocha的BDD语法为例</li><li>断言库：<a href="https://shouldjs.github.io/" target="_blank" rel="noopener">Should.js</a>、<a href="http://chaijs.com/" target="_blank" rel="noopener">chai</a>、<a href="https://github.com/Automattic/expect.js" target="_blank" rel="noopener">expect.js</a>等等，断言库提供了很多语义化的方法来对值做各种各样的判断。当然也可以不用断言库，Node.js中也可以直接使用<a href="https://nodejs.org/api/assert.html" target="_blank" rel="noopener">原生assert库</a>。这里后续以Should.js为例</li><li>代码覆盖率：<a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a>等等为代码在语法级分支上打点，运行了打点后的代码，根据运行结束后收集到的信息和打点时的信息来统计出当前测试用例的对源码的覆盖情况。</li></ol><h3 id="一个煎蛋的栗子"><a href="#一个煎蛋的栗子" class="headerlink" title="一个煎蛋的栗子"></a>一个煎蛋的栗子</h3><p>以如下的Node.js项目结构为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── index.js</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">└── test</span><br><span class="line">    └── test.js</span><br></pre></td></tr></table></figure><p>首先自然是安装工具，这里先装测试框架和断言库：<code>npm install --save-dev mocha should</code>。装完后就可以开始测试之旅了。</p><p>比如当前有一段js代码，放在<code>index.js</code>里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Hello Tmall'</span>;</span><br></pre></td></tr></table></figure><p>那么对于这么一个函数，首先需要定一个测试用例，这里很明显，运行函数，得到字符串<code>Hello Tmall</code>就算测试通过。那么就可以按照Mocha的写法来写一个测试用例，因此新建一个测试代码在<code>test/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should get "Hello Tmall"'</span>, () =&gt; &#123;</span><br><span class="line">    mylib().should.be.eql(<span class="string">'Hello Tmall'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试用例写完了，那么怎么知道测试结果呢？</p><p>由于我们之前已经安装了Mocha，可以在node_modules里面找到它，Mocha提供了命令行工具_mocha，可以直接在<code>./node_modules/.bin/_mocha</code>找到它，运行它就可以执行测试了：</p><p><img src="https://img.alicdn.com/tps/TB12qJ5LVXXXXbHXFXXXXXXXXXX-930-322.png" alt="Hello Tmall"></p><p>这样就可以看到测试结果了。同样我们可以故意让测试不通过，修改<code>test.js</code>代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should get "Hello Taobao"'</span>, () =&gt; &#123;</span><br><span class="line">    mylib().should.be.eql(<span class="string">'Hello Taobao'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就可以看到下图了：</p><p><img src="https://img.alicdn.com/tps/TB1Uid7LVXXXXXNXFXXXXXXXXXX-1150-706.png" alt="Taobao is different with Tmall"></p><p>Mocha实际上支持很多参数来提供很多灵活的控制，比如使用<code>./node_modules/.bin/_mocha --require should</code>，Mocha在启动测试时就会自己去加载Should.js，这样<code>test/test.js</code>里就不需要手动<code>require(&#39;should&#39;);</code>了。更多参数配置可以查阅<a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha官方文档</a>。</p><p>那么这些测试代码分别是啥意思呢？</p><p>这里首先引入了断言库Should.js，然后引入了自己的代码，这里<code>it()</code>函数定义了一个测试用例，通过Should.js提供的api，可以非常语义化的描述测试用例。那么describe又是干什么的呢？</p><p><code>describe</code>干的事情就是给测试用例分组。为了尽可能多的覆盖各种情况，测试用例往往会有很多。这时候通过分组就可以比较方便的管理（这里提一句，<code>describe</code>是可以嵌套的，也就是说外层分组了之后，内部还可以分子组）。另外还有一个非常重要的特性，就是每个分组都可以进行预处理（<code>before</code>、<code>beforeEach</code>）和后处理（<code>after</code>, <code>afterEach</code>）。</p><p>如果把<code>index.js</code>源码改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">bu</span> =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;bu&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>为了测试不同的bu，测试用例也对应的改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"><span class="keyword">let</span> bu = <span class="string">'none'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">  describe(<span class="string">'Welcome to Tmall'</span>, () =&gt; &#123;</span><br><span class="line">    before(<span class="function"><span class="params">()</span> =&gt;</span> bu = <span class="string">'Tmall'</span>);</span><br><span class="line">    after(<span class="function"><span class="params">()</span> =&gt;</span> bu = <span class="string">'none'</span>);</span><br><span class="line">    it(<span class="string">'should get "Hello Tmall"'</span>, () =&gt; &#123;</span><br><span class="line">      mylib(bu).should.be.eql(<span class="string">'Hello Tmall'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  describe(<span class="string">'Welcome to Taobao'</span>, () =&gt; &#123;</span><br><span class="line">    before(<span class="function"><span class="params">()</span> =&gt;</span> bu = <span class="string">'Taobao'</span>);</span><br><span class="line">    after(<span class="function"><span class="params">()</span> =&gt;</span> bu = <span class="string">'none'</span>);</span><br><span class="line">    it(<span class="string">'should get "Hello Taobao"'</span>, () =&gt; &#123;</span><br><span class="line">      mylib(bu).should.be.eql(<span class="string">'Hello Taobao'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样运行一下<code>./node_modules/.bin/_mocha</code>就可以看到如下图：</p><p><img src="https://img.alicdn.com/tps/TB1KwBQLVXXXXbkaXXXXXXXXXXX-824-456.png" alt="all bu welcomes you"></p><p>这里<code>before</code>会在每个分组的所有测试用例运行前，相对的<code>after</code>则会在所有测试用例运行后执行，如果要以测试用例为粒度，可以使用<code>beforeEach</code>和<code>afterEach</code>，这两个钩子则会分别在该分组每个测试用例运行前和运行后执行。由于很多代码都需要模拟环境，可以再这些<code>before</code>或<code>beforeEach</code>做这些准备工作，然后在<code>after</code>或<code>afterEach</code>里做回收操作。</p><h3 id="异步代码的测试"><a href="#异步代码的测试" class="headerlink" title="异步代码的测试"></a>异步代码的测试</h3><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>这里很显然代码都是同步的，但很多情况下我们的代码都是异步执行的，那么异步的代码要怎么测试呢？</p><p>比如这里<code>index.js</code>的代码变成了一段异步代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">bu, callback</span>) =&gt;</span> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="string">`Hello <span class="subst">$&#123;bu&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>由于源代码变成异步，所以测试用例就得做改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'Welcome to Tmall'</span>, done =&gt; &#123;</span><br><span class="line">    mylib(<span class="string">'Tmall'</span>, rst =&gt; &#123;</span><br><span class="line">      rst.should.be.eql(<span class="string">'Hello Tmall'</span>);</span><br><span class="line">      done();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里传入<code>it</code>的第二个参数的函数新增了一个<code>done</code>参数，当有这个参数时，这个测试用例会被认为是异步测试，只有在<code>done()</code>执行时，才认为测试结束。那如果<code>done()</code>一直没有执行呢？Mocha会触发自己的超时机制，超过一定时间（默认是2s，时长可以通过<code>--timeout</code>参数设置）就会自动终止测试，并以测试失败处理。</p><p>当然，<code>before</code>、<code>beforeEach</code>、<code>after</code>、<code>afterEach</code>这些钩子，同样支持异步，使用方式和<code>it</code>一样，在传入的函数第一个参数加上done，然后在执行完成后执行即可。</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>平常我们直接写回调会感觉自己很low，也容易出现回调金字塔，我们可以使用Promise来做异步控制，那么对于Promise控制下的异步代码，我们要怎么测试呢？</p><p>首先把源码做点改造，返回一个Promise对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">bu</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">`Hello <span class="subst">$&#123;bu&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>当然，如果是co党也可以直接使用co包裹：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = co.wrap(<span class="function"><span class="keyword">function</span>* (<span class="params">bu</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;bu&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应的修改测试用例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'Welcome to Tmall'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> mylib(<span class="string">'Tmall'</span>).should.be.fulfilledWith(<span class="string">'Hello Tmall'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Should.js在8.x.x版本自带了Promise支持，可以直接使用<code>fullfilled()</code>、<code>rejected()</code>、<code>fullfilledWith()</code>、<code>rejectedWith()</code>等等一系列API测试Promise对象。</p><blockquote><p>注意：使用should测试Promise对象时，请一定要return，一定要return，一定要return，否则断言将无效</p></blockquote><h4 id="异步运行测试"><a href="#异步运行测试" class="headerlink" title="异步运行测试"></a>异步运行测试</h4><p>有时候，我们可能并不只是某个测试用例需要异步，而是整个测试过程都需要异步执行。比如测试Gulp插件的一个方案就是，首先运行Gulp任务，完成后测试生成的文件是否和预期的一致。那么如何异步执行整个测试过程呢？</p><p>其实Mocha提供了异步启动测试，只需要在启动Mocha的命令后加上<code>--delay</code>参数，Mocha就会以异步方式启动。这种情况下我们需要告诉Mocha什么时候开始跑测试用例，只需要执行<code>run()</code>方法即可。把刚才的<code>test/test.js</code>修改成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'Welcome to Tmall'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> mylib(<span class="string">'Tmall'</span>).should.be.fulfilledWith(<span class="string">'Hello Tmall'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  run();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>直接执行<code>./node_modules/.bin/_mocha</code>就会发生下面这样的杯具：</p><p><img src="https://img.alicdn.com/tps/TB1ZxtSLVXXXXc_XVXXXXXXXXXX-826-178.png" alt="no cases"></p><p>那么加上<code>--delay</code>试试：</p><p><img src="https://img.alicdn.com/tps/TB11.R0LVXXXXXqXVXXXXXXXXXX-838-306.png" alt="oh my green"></p><p>熟悉的绿色又回来了！</p><h4 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h4><p>单元测试玩得差不多了，可以开始试试代码覆盖率了。首先需要安装代码覆盖率工具istanbul：<code>npm install --save-dev istanbul</code>，istanbul同样有命令行工具，在<code>./node_modules/.bin/istanbul</code>可以寻觅到它的身影。Node.js端做代码覆盖率测试很简单，只需要用istanbul启动Mocha即可，比如上面那个测试用例，运行<code>./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --delay</code>，可以看到下图：</p><p><img src="https://img.alicdn.com/tps/TB1xmhULVXXXXXhaXXXXXXXXXXX-1296-848.jpg" alt="my first coverage"></p><p>这就是代码覆盖率结果了，因为index.js中的代码比较简单，所以直接就100%了，那么修改一下源码，加个if吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">bu</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (bu === <span class="string">'Tmall'</span>) <span class="keyword">return</span> resolve(<span class="string">`Welcome to Tmall`</span>);</span><br><span class="line">  resolve(<span class="string">`Hello <span class="subst">$&#123;bu&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试用例也跟着变一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'Welcome to Tmall'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> mylib(<span class="string">'Tmall'</span>).should.be.fulfilledWith(<span class="string">'Welcome to Tmall'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  run();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>换了姿势，我们再来一次<code>./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --delay</code>，可以得到下图：</p><p><img src="https://img.alicdn.com/tps/TB1slV0LVXXXXaDXVXXXXXXXXXX-1286-830.jpg" alt="coverage again"></p><blockquote><p>当使用istanbul运行Mocha时，istanbul命令自己的参数放在<code>--</code>之前，需要传递给Mocha的参数放在<code>--</code>之后</p></blockquote><p>如预期所想，覆盖率不再是100%了，这时候我想看看哪些代码被运行了，哪些没有，怎么办呢？</p><p>运行完成后，项目下会多出一个<code>coverage</code>文件夹，这里就是放代码覆盖率结果的地方，它的结构大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── coverage.json</span><br><span class="line">├── lcov-report</span><br><span class="line">│   ├── base.css</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── prettify.css</span><br><span class="line">│   ├── prettify.js</span><br><span class="line">│   ├── sort-arrow-sprite.png</span><br><span class="line">│   ├── sorter.js</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── index.html</span><br><span class="line">│       └── index.js.html</span><br><span class="line">└── lcov.info</span><br></pre></td></tr></table></figure><ul><li>coverage.json和lcov.info：测试结果描述的json文件，这个文件可以被一些工具读取，生成可视化的代码覆盖率结果，这个文件后面接入持续集成时还会提到。</li><li>lcov-report：通过上面两个文件由工具处理后生成的覆盖率结果页面，打开可以非常直观的看到代码的覆盖率</li></ul><p>这里<code>open coverage/lcov-report/index.html</code>可以看到文件目录，点击对应的文件进入到文件详情，可以看到<code>index.js</code>的覆盖率如图所示：</p><p><img src="https://img.alicdn.com/tps/TB1VChTLVXXXXX2aXXXXXXXXXXX-1196-434.png" alt="coverage report"></p><p>这里有四个指标，通过这些指标，可以量化代码覆盖情况：</p><ul><li>statements：可执行语句执行情况</li><li>branches：分支执行情况，比如if就会产生两个分支，我们只运行了其中的一个</li><li>Functions：函数执行情况</li><li>Lines：行执行情况</li></ul><p>下面代码部分，没有被执行过得代码会被标红，这些标红的代码往往是bug滋生的土壤，我们要尽可能消除这些红色。为此我们添加一个测试用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> mylib = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  describe(<span class="string">'My First Test'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'Welcome to Tmall'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> mylib(<span class="string">'Tmall'</span>).should.be.fulfilledWith(<span class="string">'Welcome to Tmall'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    it(<span class="string">'Hello Taobao'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> mylib(<span class="string">'Taobao'</span>).should.be.fulfilledWith(<span class="string">'Hello Taobao'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  run();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>再来一次<code>./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --delay</code>，重新打开覆盖率页面，可以看到红色已经消失了，覆盖率100%。目标完成，可以睡个安稳觉了</p><h3 id="集成到package-json"><a href="#集成到package-json" class="headerlink" title="集成到package.json"></a>集成到package.json</h3><p>好了，一个简单的Node.js测试算是做完了，这些测试任务都可以集中写到<code>package.json</code>的<code>scripts</code>字段中，比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"NODE_ENV=test ./node_modules/.bin/_mocha --require should"</span>,</span><br><span class="line">    <span class="attr">"cov"</span>: <span class="string">"NODE_ENV=test ./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --delay"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样直接运行<code>npm run test</code>就可以跑单元测试，运行<code>npm run cov</code>就可以跑代码覆盖率测试了，方便快捷</p><h3 id="对多个文件分别做测试"><a href="#对多个文件分别做测试" class="headerlink" title="对多个文件分别做测试"></a>对多个文件分别做测试</h3><p>通常我们的项目都会有很多文件，比较推荐的方法是<strong>对每个文件单独去做测试</strong>。比如代码在<code>./lib/</code>下，那么<code>./lib/</code>文件夹下的每个文件都应该对应一个<code>./test/</code>文件夹下的<code>文件名_spec.js</code>的测试文件</p><p>为什么要这样呢？不能直接运行<code>index.js</code>入口文件做测试吗？</p><p>直接从入口文件来测其实是黑盒测试，我们并不知道代码内部运行情况，只是看某个特定的输入能否得到期望的输出。这通常可以覆盖到一些主要场景，但是在代码内部的一些边缘场景，就很难直接通过从入口输入特定的数据来解决了。比如代码里需要发送一个请求，入口只是传入一个url，url本身正确与否只是一个方面，当时的网络状况和服务器状况是无法预知的。传入相同的url，可能由于服务器挂了，也可能因为网络抖动，导致请求失败而抛出错误，如果这个错误没有得到处理，很可能导致故障。因此我们需要把黑盒打开，对其中的每个小块做白盒测试。</p><p>当然，并不是所有的模块测起来都这么轻松，前端用Node.js常干的事情就是写构建插件和自动化工具，典型的就是Gulp插件和命令行工具，那么这俩种特定的场景要怎么测试呢？</p><h3 id="Gulp插件的测试"><a href="#Gulp插件的测试" class="headerlink" title="Gulp插件的测试"></a>Gulp插件的测试</h3><p>现在前端构建使用最多的就是Gulp了，它简明的API、流式构建理念、以及在内存中操作的性能，让它备受追捧。虽然现在有像webpack这样的后起之秀，但Gulp依旧凭借着其繁荣的生态圈担当着前端构建的绝对主力。目前天猫前端就是使用Gulp作为代码构建工具。</p><p>用了Gulp作为构建工具，也就免不了要开发Gulp插件来满足业务定制化的构建需求，构建过程本质上其实是对源代码进行修改，如果修改过程中出现bug很可能直接导致线上故障。因此针对Gulp插件，尤其是会修改源代码的Gulp插件一定要做仔细的测试来保证质量。</p><h4 id="又一个煎蛋的栗子"><a href="#又一个煎蛋的栗子" class="headerlink" title="又一个煎蛋的栗子"></a>又一个煎蛋的栗子</h4><p>比如这里有个煎蛋的Gulp插件，功能就是往所有js代码前加一句注释<code>// 天猫前端招人，有意向的请发送简历至lingyucoder@gmail.com</code>，Gulp插件的代码大概就是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">const</span> through = <span class="built_in">require</span>(<span class="string">'through2'</span>);</span><br><span class="line"><span class="keyword">const</span> PluginError = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>).PluginError;</span><br><span class="line"><span class="keyword">const</span> DEFAULT_CONFIG = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config = _.defaults(config || &#123;&#125;, DEFAULT_CONFIG);</span><br><span class="line">  <span class="keyword">return</span> through.obj(<span class="function">(<span class="params">file, encoding, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isStream()) <span class="keyword">return</span> callback(<span class="keyword">new</span> PluginError(<span class="string">'gulp-welcome-to-tmall'</span>, <span class="string">`Stream is not supported`</span>));</span><br><span class="line">    file.contents = <span class="keyword">new</span> Buffer(<span class="string">`// 天猫前端招人，有意向的请发送简历至lingyucoder@gmail.com\n<span class="subst">$&#123;file.contents.toString()&#125;</span>`</span>);</span><br><span class="line">    callback(<span class="literal">null</span>, file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于这么一段代码，怎么做测试呢？</p><p>一种方式就是直接伪造一个文件传入，Gulp内部实际上是通过vinyl-fs从操作系统读取文件并做成虚拟文件对象，然后将这个虚拟文件对象交由through2创造的Transform来改写流中的内容，而外层任务之间通过orchestrator控制，保证执行顺序（如果不了解可以看看这篇翻译文章<a href="https://segmentfault.com/a/1190000000711469" target="_blank" rel="noopener">Gulp思维——Gulp高级技巧</a>）。当然一个插件不需要关心Gulp的任务管理机制，只需要关心传入一个vinyl对象能否正确处理。因此只需要伪造一个虚拟文件对象传给我们的Gulp插件就可以了。</p><p>首先设计测试用例，考虑两个主要场景：</p><ol><li>虚拟文件对象是流格式的，应该抛出错误</li><li>虚拟文件对象是Buffer格式的，能够正常对文件内容进行加工，加工完的文件加上<code>// 天猫前端招人，有意向的请发送简历至lingyucoder@gmail.com</code>的头</li></ol><p>对于第一个测试用例，我们需要创建一个流格式的vinyl对象。而对于各第二个测试用例，我们需要创建一个Buffer格式的vinyl对象。</p><p>当然，首先我们需要一个被加工的源文件，放到<code>test/src/testfile.js</code>下吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure><p>这个源文件非常简单，接下来的任务就是把它分别封装成流格式的vinyl对象和Buffer格式的vinyl对象。</p><h5 id="构建Buffer格式的虚拟文件对象"><a href="#构建Buffer格式的虚拟文件对象" class="headerlink" title="构建Buffer格式的虚拟文件对象"></a>构建Buffer格式的虚拟文件对象</h5><p>构建一个Buffer格式的虚拟文件对象可以用vinyl-fs读取操作系统里的文件生成vinyl对象，Gulp内部也是使用它，默认使用Buffer：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> vfs = <span class="built_in">require</span>(<span class="string">'vinyl-fs'</span>);</span><br><span class="line"><span class="keyword">const</span> welcome = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'welcome to Tmall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should work when buffer'</span>, done =&gt; &#123;</span><br><span class="line">    vfs.src(path.join(__dirname, <span class="string">'src'</span>, <span class="string">'testfile.js'</span>))</span><br><span class="line">      .pipe(welcome())</span><br><span class="line">      .on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">vf</span>) </span>&#123;</span><br><span class="line">        vf.contents.toString().should.be.eql(<span class="string">`// 天猫前端招人，有意向的请发送简历至lingyucoder@gmail.com\n'use strict';\nconsole.log('hello world');\n`</span>);</span><br><span class="line">        done();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样测了Buffer格式后算是完成了主要功能的测试，那么要如何测试流格式呢？</p><h5 id="构建流格式的虚拟文件对象"><a href="#构建流格式的虚拟文件对象" class="headerlink" title="构建流格式的虚拟文件对象"></a>构建流格式的虚拟文件对象</h5><p>方案一和上面一样直接使用vinyl-fs，增加一个参数<code>buffer: false</code>即可：</p><p>把代码修改成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> vfs = <span class="built_in">require</span>(<span class="string">'vinyl-fs'</span>);</span><br><span class="line"><span class="keyword">const</span> PluginError = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>).PluginError;</span><br><span class="line"><span class="keyword">const</span> welcome = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'welcome to Tmall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should work when buffer'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="comment">// blabla</span></span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should throw PluginError when stream'</span>, done =&gt; &#123;</span><br><span class="line">    vfs.src(path.join(__dirname, <span class="string">'src'</span>, <span class="string">'testfile.js'</span>), &#123;</span><br><span class="line">      buffer: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">      .pipe(welcome())</span><br><span class="line">      .on(<span class="string">'error'</span>, e =&gt; &#123;</span><br><span class="line">        e.should.be.instanceOf(PluginError);</span><br><span class="line">        done();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样vinyl-fs直接从文件系统读取文件并生成流格式的vinyl对象。</p><p>如果内容并不来自于文件系统，而是来源于一个已经存在的可读流，要怎么把它封装成一个流格式的vinyl对象呢？</p><p>这样的需求可以借助<code>vinyl-source-stream</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);</span><br><span class="line"><span class="keyword">const</span> vfs = <span class="built_in">require</span>(<span class="string">'vinyl-fs'</span>);</span><br><span class="line"><span class="keyword">const</span> PluginError = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>).PluginError;</span><br><span class="line"><span class="keyword">const</span> welcome = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'welcome to Tmall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should work when buffer'</span>, done =&gt; &#123;</span><br><span class="line">    <span class="comment">// blabla</span></span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should throw PluginError when stream'</span>, done =&gt; &#123;</span><br><span class="line">    fs.createReadStream(path.join(__dirname, <span class="string">'src'</span>, <span class="string">'testfile.js'</span>))</span><br><span class="line">      .pipe(source())</span><br><span class="line">      .pipe(welcome())</span><br><span class="line">      .on(<span class="string">'error'</span>, e =&gt; &#123;</span><br><span class="line">        e.should.be.instanceOf(PluginError);</span><br><span class="line">        done();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里首先通过<code>fs.createReadStream</code>创建了一个可读流，然后通过vinyl-source-stream把这个可读流包装成流格式的vinyl对象，并交给我们的插件做处理</p><blockquote><p>Gulp插件执行错误时请抛出PluginError，这样能够让gulp-plumber这样的插件进行错误管理，防止错误终止构建进程，这在gulp watch时非常有用</p></blockquote><h4 id="模拟Gulp运行"><a href="#模拟Gulp运行" class="headerlink" title="模拟Gulp运行"></a>模拟Gulp运行</h4><p>我们伪造的对象已经可以跑通功能测试了，但是这数据来源终究是自己伪造的，并不是用户日常的使用方式。如果采用最接近用户使用的方式来做测试，测试结果才更加可靠和真实。那么问题来了，怎么模拟真实的Gulp环境来做Gulp插件的测试呢？</p><p>首先模拟一下我们的项目结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">├── build</span><br><span class="line">│   └── testfile.js</span><br><span class="line">├── gulpfile.js</span><br><span class="line">└── src</span><br><span class="line">    └── testfile.js</span><br></pre></td></tr></table></figure><p>一个简易的项目结构，源码放在src下，通过gulpfile来指定任务，构建结果放在build下。按照我们平常使用方式在<code>test</code>目录下搭好架子，并且写好gulpfile.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> welcome = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, cb =&gt; del(<span class="string">'build'</span>, cb));</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>], () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'src/**/*'</span>)</span><br><span class="line">    .pipe(welcome())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接着在测试代码里来模拟Gulp运行了，这里有两种方案：</p><ol><li>使用child_process库提供的<code>spawn</code>或<code>exec</code>开子进程直接跑<code>gulp</code>命令，然后测试build目录下是否是想要的结果</li><li>直接在当前进程获取gulpfile中的Gulp实例来运行Gulp任务，然后测试build目录下是否是想要的结果</li></ol><p>开子进程进行测试有一些坑，istanbul测试代码覆盖率时时无法跨进程的，因此开子进程测试，首先需要子进程执行命令时加上istanbul，然后还需要手动去收集覆盖率数据，当开启多个子进程时还需要自己做覆盖率结果数据合并，相当麻烦。</p><p>那么不开子进程怎么做呢？可以借助run-gulp-task这个工具来运行，其内部的机制就是首先获取gulpfile文件内容，在文件尾部加上<code>module.exports = gulp;</code>后require gulpfile从而获取Gulp实例，然后将Gulp实例递交给run-sequence调用内部未开放的API<code>gulp.run</code>来运行。</p><p>我们采用不开子进程的方式，把运行Gulp的过程放在<code>before</code>钩子中，测试代码变成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> run = <span class="built_in">require</span>(<span class="string">'run-gulp-task'</span>);</span><br><span class="line"><span class="keyword">const</span> CWD = process.cwd();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'welcome to Tmall'</span>, () =&gt; &#123;</span><br><span class="line">  before(<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    process.chdir(__dirname);</span><br><span class="line">    run(<span class="string">'default'</span>, path.join(__dirname, <span class="string">'gulpfile.js'</span>))</span><br><span class="line">      .catch(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line">      .then(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        process.chdir(CWD);</span><br><span class="line">        done(e);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should work'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFileSync(path.join(__dirname, <span class="string">'build'</span>, <span class="string">'testfile.js'</span>)).toString().should.be.eql(<span class="string">`// 天猫前端招人，有意向的请发送简历至lingyucoder@gmail.com\n'use strict';\nconsole.log('hello world');\n`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样由于不需要开子进程，代码覆盖率测试也可以和普通Node.js模块一样了</p><h3 id="测试命令行输出"><a href="#测试命令行输出" class="headerlink" title="测试命令行输出"></a>测试命令行输出</h3><h4 id="双一个煎蛋的栗子"><a href="#双一个煎蛋的栗子" class="headerlink" title="双一个煎蛋的栗子"></a>双一个煎蛋的栗子</h4><p>当然前端写工具并不只限于Gulp插件，偶尔还会写一些辅助命令啥的，这些辅助命令直接在终端上运行，结果也会直接展示在终端上。比如一个简单的使用commander实现的命令行工具：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in index.js</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(path.join(__dirname, <span class="string">'package.json'</span>));</span><br><span class="line"></span><br><span class="line">program.version(pkg.version)</span><br><span class="line">  .usage(<span class="string">'[options] &lt;file&gt;'</span>)</span><br><span class="line">  .option(<span class="string">'-t, --test'</span>, <span class="string">'Run test'</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">file, prog</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prog.test) <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = program;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in bin/cli</span></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'../index.js'</span>);</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line">!program.args[<span class="number">0</span>] &amp;&amp; program.help();</span><br><span class="line"></span><br><span class="line"><span class="comment">// in package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"bin"</span>: &#123;</span><br><span class="line">    <span class="string">"cli-test"</span>: <span class="string">"./bin/cli"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拦截输出"><a href="#拦截输出" class="headerlink" title="拦截输出"></a>拦截输出</h4><p>要测试命令行工具，自然要模拟用户输入命令，这一次依旧选择不开子进程，直接用伪造一个<code>process.argv</code>交给<code>program.parse</code>即可。命令输入了问题也来了，数据是直接<code>console.log</code>的，要怎么拦截呢？</p><p>这可以借助sinon来拦截<code>console.log</code>，而且sinon非常贴心的提供了mocha-sinon方便测试用，这样<code>test.js</code>大致就是这个样子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'mocha-sinon'</span>);</span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"><span class="keyword">const</span> uncolor = <span class="built_in">require</span>(<span class="string">'uncolor'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'cli-test'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> rst;</span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sinon.stub(<span class="built_in">console</span>, <span class="string">'log'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      rst = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should print "test"'</span>, () =&gt; &#123;</span><br><span class="line">    program.parse([</span><br><span class="line">      <span class="string">'node'</span>,</span><br><span class="line">      <span class="string">'./bin/cli'</span>,</span><br><span class="line">      <span class="string">'-t'</span>,</span><br><span class="line">      <span class="string">'file.js'</span></span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">return</span> uncolor(rst).trim().should.be.eql(<span class="string">'test'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>PS：由于命令行输出时经常会使用colors这样的库来添加颜色，因此在测试时记得用uncolor把这些颜色移除</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Node.js相关的单元测试就扯这么多了，还有很多场景像服务器测试什么的就不扯了，因为我不会。当然前端最主要的工作还是写页面，接下来扯一扯如何对页面上的组件做测试。</p><h2 id="页面测试"><a href="#页面测试" class="headerlink" title="页面测试"></a>页面测试</h2><p>对于浏览器里跑的前端代码，做测试要比Node.js模块要麻烦得多。Node.js模块纯js代码，使用V8运行在本地，测试用的各种各样的依赖和工具都能快速的安装，而前端代码不仅仅要测试js，CSS等等，更麻烦的事需要模拟各种各样的浏览器，比较常见的前端代码测试方案有下面几种：</p><ol><li>构建一个测试页面，人肉直接到虚拟机上开各种浏览器跑测试页面（比如公司的f2etest）。这个方案的缺点就是不好做代码覆盖率测试，也不好持续化集成，同时人肉工作较多</li><li>使用PhantomJS构建一个伪造的浏览器环境跑单元测试，好处是解决了代码覆盖率问题，也可以做持续集成。这个方案的缺点是PhantomJS毕竟是Qt的webkit，并不是真实浏览器环境，PhantomJS也有各种各样兼容性坑</li><li>通过Karma调用本机各种浏览器进行测试，好处是可以跨浏览器做测试，也可以测试覆盖率，但持续集成时需要注意只能开PhantomJS做测试，毕竟集成的Linux环境不可能有浏览器。这可以说是目前看到的最好的前端代码测试方式了</li></ol><blockquote><p>这里以gulp为构建工具做测试，后面在React组件测试部分再介绍以webpack为构建工具做测试</p></blockquote><h3 id="叒一个煎蛋的栗子"><a href="#叒一个煎蛋的栗子" class="headerlink" title="叒一个煎蛋的栗子"></a>叒一个煎蛋的栗子</h3><p>前端代码依旧是js，一样可以用Mocha+Should.js来做单元测试。打开node_modules下的Mocha和Should.js，你会发现这些优秀的开源工具已经非常贴心的提供了可在浏览器中直接运行的版本：<code>mocha/mocha.js</code>和<code>should/should.min.js</code>，只需要把他们通过<code>script</code>标签引入即可，另外Mocha还需要引入自己的样式<code>mocha/mocha.css</code></p><p>首先看一下我们的前端项目结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   └── index.js</span><br><span class="line">└── test</span><br><span class="line">    ├── test.html</span><br><span class="line">    └── test.js</span><br></pre></td></tr></table></figure><p>比如这里源码<code>src/index.js</code>就是定义一个全局函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctn = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  ctn.setAttribute(<span class="string">'id'</span>, <span class="string">'tmall'</span>);</span><br><span class="line">  ctn.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'天猫前端招人，有意向的请发送简历至lingyucoder@gmail.com'</span>));</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(ctn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而测试页面<code>test/test.html</code>大致上是这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"../node_modules/mocha/mocha.css"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../node_modules/mocha/mocha.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../node_modules/should/should.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../src/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>head里引入了测试框架Mocha和断言库Should.js，测试的结果会被显示在<code>&lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;</code>这个容器里，而<code>test/test.js</code>里则是我们的测试的代码。</p><p>前端页面上测试和Node.js上测试没啥太大不同，只是需要指定Mocha使用的UI，并需要手动调用<code>mocha.run()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mocha.ui(<span class="string">'bdd'</span>);</span><br><span class="line">describe(<span class="string">'Welcome to Tmall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.render();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Hello'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'tmall'</span>).textContent.should.be.eql(<span class="string">'天猫前端招人，有意向的请发送简历至lingyucoder@gmail.com'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">mocha.run();</span><br></pre></td></tr></table></figure><p>在浏览器里打开<code>test/test.html</code>页面，就可以看到效果了：</p><p><img src="https://img.alicdn.com/tps/TB11u5oLVXXXXbQXXXXXXXXXXXX-1656-492.png" alt="test page"></p><p>在不同的浏览器里打开这个页面，就可以看到当前浏览器的测试了。这种方式能兼容最多的浏览器，当然要跨机器之前记得把资源上传到一个测试机器都能访问到的地方，比如CDN。</p><p>测试页面有了，那么来试试接入PhantomJS吧</p><h3 id="使用PhantomJS进行测试"><a href="#使用PhantomJS进行测试" class="headerlink" title="使用PhantomJS进行测试"></a>使用PhantomJS进行测试</h3><p>PhantomJS是一个模拟的浏览器，它能执行js，甚至还有webkit渲染引擎，只是没有浏览器的界面上渲染结果罢了。我们可以使用它做很多事情，比如对网页进行截图，写爬虫爬取异步渲染的页面，以及接下来要介绍的——对页面做测试。</p><p>当然，这里我们不是直接使用PhantomJS，而是使用mocha-phantomjs来做测试。<code>npm install --save-dev mocha-phantomjs</code>安装完成后，就可以运行命令<code>./node_modules/.bin/mocha-phantomjs ./test/test.html</code>来对上面那个<code>test/test.html</code>的测试了：</p><p><img src="https://img.alicdn.com/tps/TB1qUt1LVXXXXaRaXXXXXXXXXXX-934-324.png" alt="PhantomJS test"></p><p>单元测试没问题了，接下来就是代码覆盖率测试</p><h4 id="覆盖率打点"><a href="#覆盖率打点" class="headerlink" title="覆盖率打点"></a>覆盖率打点</h4><p>首先第一步，改写我们的<code>gulpfile.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> istanbul = <span class="built_in">require</span>(<span class="string">'gulp-istanbul'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src([<span class="string">'src/**/*.js'</span>])</span><br><span class="line">    .pipe(istanbul(&#123;</span><br><span class="line">      coverageVariable: <span class="string">'__coverage__'</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build-test'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里把覆盖率结果保存到<code>__coverage__</code>里面，把打完点的代码放到<code>build-test</code>目录下，比如刚才的<code>src/index.js</code>的代码，在运行<code>gulp test</code>后，会生成<code>build-test/index.js</code>，内容大致是这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __cov_WzFiasMcIh_mBvAjOuQiQg = (<span class="built_in">Function</span>(<span class="string">'return this'</span>))();</span><br><span class="line"><span class="keyword">if</span> (!__cov_WzFiasMcIh_mBvAjOuQiQg.__coverage__) &#123; __cov_WzFiasMcIh_mBvAjOuQiQg.__coverage__ = &#123;&#125;; &#125;</span><br><span class="line">__cov_WzFiasMcIh_mBvAjOuQiQg = __cov_WzFiasMcIh_mBvAjOuQiQg.__coverage__;</span><br><span class="line"><span class="keyword">if</span> (!(__cov_WzFiasMcIh_mBvAjOuQiQg[<span class="string">'/Users/lingyu/gitlab/dev/mui/test-page/src/index.js'</span>])) &#123;</span><br><span class="line">   __cov_WzFiasMcIh_mBvAjOuQiQg[<span class="string">'/Users/lingyu/gitlab/dev/mui/test-page/src/index.js'</span>] = &#123;<span class="string">"path"</span>:<span class="string">"/Users/lingyu/gitlab/dev/mui/test-page/src/index.js"</span>,<span class="string">"s"</span>:&#123;<span class="string">"1"</span>:<span class="number">0</span>,<span class="string">"2"</span>:<span class="number">0</span>,<span class="string">"3"</span>:<span class="number">0</span>,<span class="string">"4"</span>:<span class="number">0</span>,<span class="string">"5"</span>:<span class="number">0</span>&#125;,<span class="string">"b"</span>:&#123;&#125;,<span class="string">"f"</span>:&#123;<span class="string">"1"</span>:<span class="number">0</span>&#125;,<span class="string">"fnMap"</span>:&#123;<span class="string">"1"</span>:&#123;<span class="string">"name"</span>:<span class="string">"(anonymous_1)"</span>,<span class="string">"line"</span>:<span class="number">1</span>,<span class="string">"loc"</span>:&#123;<span class="string">"start"</span>:&#123;<span class="string">"line"</span>:<span class="number">1</span>,<span class="string">"column"</span>:<span class="number">16</span>&#125;,<span class="string">"end"</span>:&#123;<span class="string">"line"</span>:<span class="number">1</span>,<span class="string">"column"</span>:<span class="number">27</span>&#125;&#125;&#125;&#125;,<span class="string">"statementMap"</span>:&#123;<span class="string">"1"</span>:&#123;<span class="string">"start"</span>:&#123;<span class="string">"line"</span>:<span class="number">1</span>,<span class="string">"column"</span>:<span class="number">0</span>&#125;,<span class="string">"end"</span>:&#123;<span class="string">"line"</span>:<span class="number">6</span>,<span class="string">"column"</span>:<span class="number">1</span>&#125;&#125;,<span class="string">"2"</span>:&#123;<span class="string">"start"</span>:&#123;<span class="string">"line"</span>:<span class="number">2</span>,<span class="string">"column"</span>:<span class="number">2</span>&#125;,<span class="string">"end"</span>:&#123;<span class="string">"line"</span>:<span class="number">2</span>,<span class="string">"column"</span>:<span class="number">42</span>&#125;&#125;,<span class="string">"3"</span>:&#123;<span class="string">"start"</span>:&#123;<span class="string">"line"</span>:<span class="number">3</span>,<span class="string">"column"</span>:<span class="number">2</span>&#125;,<span class="string">"end"</span>:&#123;<span class="string">"line"</span>:<span class="number">3</span>,<span class="string">"column"</span>:<span class="number">34</span>&#125;&#125;,<span class="string">"4"</span>:&#123;<span class="string">"start"</span>:&#123;<span class="string">"line"</span>:<span class="number">4</span>,<span class="string">"column"</span>:<span class="number">2</span>&#125;,<span class="string">"end"</span>:&#123;<span class="string">"line"</span>:<span class="number">4</span>,<span class="string">"column"</span>:<span class="number">85</span>&#125;&#125;,<span class="string">"5"</span>:&#123;<span class="string">"start"</span>:&#123;<span class="string">"line"</span>:<span class="number">5</span>,<span class="string">"column"</span>:<span class="number">2</span>&#125;,<span class="string">"end"</span>:&#123;<span class="string">"line"</span>:<span class="number">5</span>,<span class="string">"column"</span>:<span class="number">33</span>&#125;&#125;&#125;,<span class="string">"branchMap"</span>:&#123;&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">__cov_WzFiasMcIh_mBvAjOuQiQg = __cov_WzFiasMcIh_mBvAjOuQiQg[<span class="string">'/Users/lingyu/gitlab/dev/mui/test-page/src/index.js'</span>];</span><br><span class="line">__cov_WzFiasMcIh_mBvAjOuQiQg.s[<span class="string">'1'</span>]++;<span class="built_in">window</span>.render=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;__cov_WzFiasMcIh_mBvAjOuQiQg.f[<span class="string">'1'</span>]++;__cov_WzFiasMcIh_mBvAjOuQiQg.s[<span class="string">'2'</span>]++;<span class="keyword">var</span> ctn=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);__cov_WzFiasMcIh_mBvAjOuQiQg.s[<span class="string">'3'</span>]++;ctn.setAttribute(<span class="string">'id'</span>,<span class="string">'tmall'</span>);__cov_WzFiasMcIh_mBvAjOuQiQg.s[<span class="string">'4'</span>]++;ctn.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'天猫前端招人\uFF0C有意向的请发送简历至lingyucoder@gmail.com'</span>));__cov_WzFiasMcIh_mBvAjOuQiQg.s[<span class="string">'5'</span>]++;<span class="built_in">document</span>.body.appendChild(ctn);&#125;;</span><br></pre></td></tr></table></figure><p>这都什么鬼！不管了，反正运行它就好。把<code>test/test.html</code>里面引入的代码从<code>src/index.js</code>修改为<code>build-test/index.js</code>，保证页面运行时使用的是编译后的代码。</p><h4 id="编写钩子"><a href="#编写钩子" class="headerlink" title="编写钩子"></a>编写钩子</h4><p>运行数据会存放到变量<code>__coverage__</code>里，但是我们还需要一段钩子代码在单元测试结束后获取这个变量里的内容。把钩子代码放在<code>test/hook.js</code>下，里面内容这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  afterEnd: <span class="function"><span class="keyword">function</span>(<span class="params">runner</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coverage = runner.page.evaluate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.__coverage__;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (coverage) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Writing coverage to coverage/coverage.json'</span>);</span><br><span class="line">      fs.write(<span class="string">'coverage/coverage.json'</span>, <span class="built_in">JSON</span>.stringify(coverage), <span class="string">'w'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'No coverage data generated'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样准备工作工作就大功告成了，执行命令<code>./node_modules/.bin/mocha-phantomjs ./test/test.html --hooks ./test/hook.js</code>，可以看到如下图结果，同时覆盖率结果被写入到<code>coverage/coverage.json</code>里面了。</p><p><img src="https://img.alicdn.com/tps/TB1goylLVXXXXc8XXXXXXXXXXXX-1356-416.png" alt="coverage hook"></p><h4 id="生成页面"><a href="#生成页面" class="headerlink" title="生成页面"></a>生成页面</h4><p>有了结果覆盖率结果就可以生成覆盖率页面了，首先看看覆盖率概况吧。执行命令<code>./node_modules/.bin/istanbul report --root coverage text-summary</code>，可以看到下图：</p><p><img src="https://img.alicdn.com/tps/TB1dC5kLVXXXXXRXpXXXXXXXXXX-1338-354.png" alt="coverage summary"></p><p>还是原来的配方，还是想熟悉的味道。接下来运行<code>./node_modules/.bin/istanbul report --root coverage lcov</code>生成覆盖率页面，执行完后<code>open coverage/lcov-report/index.html</code>，点击进入到<code>src/index.js</code>：</p><p><img src="https://img.alicdn.com/tps/TB1ZqV.LVXXXXXFXVXXXXXXXXXX-1480-470.png" alt="coverage page"></p><p>一颗赛艇！这样我们对前端代码就能做覆盖率测试了</p><h3 id="接入Karma"><a href="#接入Karma" class="headerlink" title="接入Karma"></a>接入Karma</h3><p><a href="https://karma-runner.github.io/0.13/index.html" target="_blank" rel="noopener">Karma</a>是一个测试集成框架，可以方便地以插件的形式集成测试框架、测试环境、覆盖率工具等等。Karma已经有了一套相当完善的插件体系，这里尝试在PhantomJS、Chrome、FireFox下做测试，首先需要使用npm安装一些依赖：</p><ol><li>karma：框架本体</li><li>karma-mocha：Mocha测试框架</li><li>karma-coverage：覆盖率测试</li><li>karma-spec-reporter：测试结果输出</li><li>karma-phantomjs-launcher：PhantomJS环境</li><li>phantomjs-prebuilt: PhantomJS最新版本</li><li>karma-chrome-launcher：Chrome环境</li><li>karma-firefox-launcher：Firefox环境</li></ol><p>安装完成后，就可以开启我们的Karma之旅了。还是之前的那个项目，我们把该清除的清除，只留下源文件和而是文件，并增加一个karma.conf.js文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── karma.conf.js</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   └── index.js</span><br><span class="line">└── test</span><br><span class="line">    └── test.js</span><br></pre></td></tr></table></figure><p><code>karma.conf.js</code>是Karma框架的配置文件，在这个例子里，它大概是这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.set(&#123;</span><br><span class="line">    frameworks: [<span class="string">'mocha'</span>],</span><br><span class="line">    files: [</span><br><span class="line">      <span class="string">'./node_modules/should/should.js'</span>,</span><br><span class="line">      <span class="string">'src/**/*.js'</span>,</span><br><span class="line">      <span class="string">'test/**/*.js'</span></span><br><span class="line">    ],</span><br><span class="line">    preprocessors: &#123;</span><br><span class="line">      <span class="string">'src/**/*.js'</span>: [<span class="string">'coverage'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [<span class="string">'karma-mocha'</span>, <span class="string">'karma-phantomjs-launcher'</span>, <span class="string">'karma-chrome-launcher'</span>, <span class="string">'karma-firefox-launcher'</span>, <span class="string">'karma-coverage'</span>, <span class="string">'karma-spec-reporter'</span>],</span><br><span class="line">    browsers: [<span class="string">'PhantomJS'</span>, <span class="string">'Firefox'</span>, <span class="string">'Chrome'</span>],</span><br><span class="line">    reporters: [<span class="string">'spec'</span>, <span class="string">'coverage'</span>],</span><br><span class="line">    coverageReporter: &#123;</span><br><span class="line">      dir: <span class="string">'coverage'</span>,</span><br><span class="line">      reporters: [&#123;</span><br><span class="line">        type: <span class="string">'json'</span>,</span><br><span class="line">        subdir: <span class="string">'.'</span>,</span><br><span class="line">        file: <span class="string">'coverage.json'</span>,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        type: <span class="string">'lcov'</span>,</span><br><span class="line">        subdir: <span class="string">'.'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        type: <span class="string">'text-summary'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些配置都是什么意思呢？这里挨个说明一下：</p><ul><li>frameworks: 使用的测试框架，这里依旧是我们熟悉又亲切的Mocha</li><li>files：测试页面需要加载的资源，上面的test目录下已经没有test.html了，所有需要加载内容都在这里指定，如果是CDN上的资源，直接写URL也可以，不过建议尽可能使用本地资源，这样测试更快而且即使没网也可以测试。这个例子里，第一行载入的是断言库Should.js，第二行是src下的所有代码，第三行载入测试代码</li><li>preprocessors：配置预处理器，在上面files载入对应的文件前，如果在这里配置了预处理器，会先对文件做处理，然后载入处理结果。这个例子里，需要对src目录下的所有资源添加覆盖率打点（这一步之前是通过gulp-istanbul来做，现在karma-coverage框架可以很方便的处理，也不需要钩子啥的了）。后面做React组件测试时也会在这里使用webpack</li><li>plugins：安装的插件列表</li><li>browsers：需要测试的浏览器，这里我们选择了PhantomJS、FireFox、Chrome</li><li>reporters：需要生成哪些代码报告</li><li>coverageReporter：覆盖率报告要如何生成，这里我们期望生成和之前一样的报告，包括覆盖率页面、lcov.info、coverage.json、以及命令行里的提示</li></ul><p>好了，配置完成，来试试吧，运行<code>./node_modules/karma/bin/karma start --single-run</code>，可以看到如下输出：</p><p><img src="https://img.alicdn.com/tps/TB1QzGnLVXXXXXeXpXXXXXXXXXX-2076-1632.jpg" alt="run karma"></p><p>可以看到，Karma首先会在9876端口开启一个本地服务，然后分别启动PhantomJS、FireFox、Chrome去加载这个页面，收集到测试结果信息之后分别输出，这样跨浏览器测试就解决啦。如果要新增浏览器就安装对应的浏览器插件，然后在<code>browsers</code>里指定一下即可，非常灵活方便。</p><p>那如果我的mac电脑上没有IE，又想测IE，怎么办呢？可以直接运行<code>./node_modules/karma/bin/karma start</code>启动本地服务器，然后使用其他机器开对应浏览器直接访问本机的9876端口（当然这个端口是可配置的）即可，同样移动端的测试也可以采用这个方法。这个方案兼顾了前两个方案的优点，弥补了其不足，是目前看到最优秀的前端代码测试方案了</p><h3 id="React组件测试"><a href="#React组件测试" class="headerlink" title="React组件测试"></a>React组件测试</h3><p>去年React旋风一般席卷全球，当然天猫也在技术上紧跟时代脚步。天猫商家端业务已经全面切入React，形成了React组件体系，几乎所有新业务都采用React开发，而老业务也在不断向React迁移。React大红大紫，这里单独拉出来讲一讲React+webpack的打包方案如何进行测试</p><blockquote><p>这里只聊React Web，不聊React Native</p></blockquote><blockquote><p>事实上天猫目前并未采用webpack打包，而是Gulp+Babel编译React CommonJS代码成AMD模块使用，这是为了能够在新老业务使用上更加灵活，当然也有部分业务采用webpack打包并上线</p></blockquote><h4 id="叕一个煎蛋的栗子"><a href="#叕一个煎蛋的栗子" class="headerlink" title="叕一个煎蛋的栗子"></a>叕一个煎蛋的栗子</h4><p>这里创建一个React组件，目录结构大致这样（这里略过CSS相关部分，只要跑通了，集成CSS像PostCSS、Less都没啥问题）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── demo</span><br><span class="line">├── karma.conf.js</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   └── index.jsx</span><br><span class="line">├── test</span><br><span class="line">│   └── index_spec.jsx</span><br><span class="line">├── webpack.dev.js</span><br><span class="line">└── webpack.pub.js</span><br></pre></td></tr></table></figure><p>React组件源码<code>src/index.jsx</code>大概是这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Welcome.displayName = <span class="string">'Welcome'</span>;</span><br><span class="line">Welcome.propTypes = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * content of element</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  content: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line">Welcome.defaultProps = &#123;</span><br><span class="line">  content: <span class="string">'Hello Tmall'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = Welcome;</span><br></pre></td></tr></table></figure><p>那么对应的<code>test/index_spec.jsx</code>则大概是这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'should'</span>;</span><br><span class="line"><span class="keyword">import</span> Welcome <span class="keyword">from</span> <span class="string">'../src/index.jsx'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> TestUtils <span class="keyword">from</span> <span class="string">'react-addons-test-utils'</span>;</span><br><span class="line">describe(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(container);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Hello Tmall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cp = ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Welcome</span>/&gt;</span></span>, container);</span><br><span class="line">    <span class="keyword">let</span> welcome = TestUtils.findRenderedComponentWithType(cp, Welcome);</span><br><span class="line">    ReactDOM.findDOMnode(welcome).textContent.should.be.eql(<span class="string">'Hello Tmall'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于是测试React，自然要使用React的TestUtils，这个工具库提供了不少方便查找节点和组件的方法，最重要的是它提供了模拟事件的API，这可以说是UI测试最重要的一个功能。更多关于TestUtils的使用请参考<a href="https://facebook.github.io/react/docs/test-utils.html" target="_blank" rel="noopener">React官网</a>，这里就不扯了…</p><p>代码有了，测试用例也有了，接下就差跑起来了。<code>karma.conf.js</code>肯定就和上面不一样了，首先它要多一个插件<code>karma-webpack</code>，因为我们的React组件是需要webpack打包的，不打包的代码压根就没法运行。另外还需要注意代码覆盖率测试也出现了变化。因为现在多了一层Babel编译，Babel编译ES6、ES7源码生成ES5代码后会产生很多polyfill代码，因此如果对build完成之后的代码做覆盖率测试会包含这些polyfill代码，这样测出来的覆盖率显然是不可靠的，这个问题可以通过<code>isparta-loader</code>来解决。React组件的<code>karma.conf.js</code>大概是这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.set(&#123;</span><br><span class="line">    frameworks: [<span class="string">'mocha'</span>],</span><br><span class="line">    files: [</span><br><span class="line">      <span class="string">'./node_modules/phantomjs-polyfill/bind-polyfill.js'</span>,</span><br><span class="line">      <span class="string">'test/**/*_spec.jsx'</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: [<span class="string">'karma-webpack'</span>, <span class="string">'karma-mocha'</span>,, <span class="string">'karma-chrome-launcher'</span>, <span class="string">'karma-firefox-launcher'</span>, <span class="string">'karma-phantomjs-launcher'</span>, <span class="string">'karma-coverage'</span>, <span class="string">'karma-spec-reporter'</span>],</span><br><span class="line">    browsers: [<span class="string">'PhantomJS'</span>, <span class="string">'Firefox'</span>, <span class="string">'Chrome'</span>],</span><br><span class="line">    preprocessors: &#123;</span><br><span class="line">      <span class="string">'test/**/*_spec.jsx'</span>: [<span class="string">'webpack'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    reporters: [<span class="string">'spec'</span>, <span class="string">'coverage'</span>],</span><br><span class="line">    coverageReporter: &#123;</span><br><span class="line">      dir: <span class="string">'coverage'</span>,</span><br><span class="line">      reporters: [&#123;</span><br><span class="line">        type: <span class="string">'json'</span>,</span><br><span class="line">        subdir: <span class="string">'.'</span>,</span><br><span class="line">        file: <span class="string">'coverage.json'</span>,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        type: <span class="string">'lcov'</span>,</span><br><span class="line">        subdir: <span class="string">'.'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        type: <span class="string">'text-summary'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    webpack: &#123;</span><br><span class="line">      <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">          test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">          loaders: [<span class="string">'babel'</span>]</span><br><span class="line">        &#125;],</span><br><span class="line">        preLoaders: [&#123;</span><br><span class="line">          test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">          include: [path.resolve(<span class="string">'src/'</span>)],</span><br><span class="line">          loader: <span class="string">'isparta'</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    webpackMiddleware: &#123;</span><br><span class="line">      noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里相对于之前的karma.conf.js，主要有以下几点区别：</p><ol><li>由于webpack的打包功能，我们在测试代码里直接import组件代码，因此不再需要在files里手动引入组件代码</li><li>预处理里面需要对每个测试文件都做webpack打包</li><li>添加webpack编译相关配置，在编译源码时，需要定义preLoaders，并使用isparta-loader做代码覆盖率打点</li><li>添加webpackMiddleware配置，这里noInfo作用是不需要输出webpack编译时那一大串信息</li></ol><p>这样配置基本上就完成了，跑一把<code>./node_modules/karma/bin/karma start --single-run</code>：</p><p><img src="https://img.alicdn.com/tps/TB1TDN.LVXXXXXWXVXXXXXXXXXX-2100-1530.jpg" alt="react karma"></p><p>很好，结果符合预期。<code>open coverage/lcov-report/index.html</code>打开覆盖率页面：</p><p><img src="https://img.alicdn.com/tps/TB1UBWaLVXXXXXuXVXXXXXXXXXX-1782-938.jpg" alt="react coverage"></p><p>鹅妹子音！！！直接对jsx代码做的覆盖率测试！这样React组件的测试大体上就完工了</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>前端的代码测试主要难度是如何模拟各种各样的浏览器环境，Karma给我们提供了很好地方式，对于本地有的浏览器能自动打开并测试，本地没有的浏览器则提供直接访问的页面。前端尤其是移动端浏览器种类繁多，很难做到完美，但我们可以通过这种方式实现主流浏览器的覆盖，保证每次上线大多数用户没有问题。</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>测试结果有了，接下来就是把这些测试结果接入到持续集成之中。持续集成是一种非常优秀的多人开发实践，通过代码push触发钩子，实现自动运行编译、测试等工作。接入持续集成后，我们的每一次push代码，每个Merge Request都会生成对应的测试结果，项目的其他成员可以很清楚地了解到新代码是否影响了现有的功能，在接入自动告警后，可以在代码提交阶段就快速发现错误，提升开发迭代效率。</p><p>持续集成会在每次集成时提供一个几乎空白的虚拟机器，并拷贝用户提交的代码到机器本地，通过读取用户项目下的持续集成配置，自动化的安装环境和依赖，编译和测试完成后生成报告，在一段时间之后释放虚拟机器资源。</p><h3 id="开源的持续集成"><a href="#开源的持续集成" class="headerlink" title="开源的持续集成"></a>开源的持续集成</h3><p>开源比较出名的持续集成服务当属<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis</a>，而代码覆盖率则通过<a href="https://coveralls.io/" target="_blank" rel="noopener">Coveralls</a>，只要有GitHub账户，就可以很轻松的接入Travis和Coveralls，在网站上勾选了需要持续集成的项目以后，每次代码push就会触发自动化测试。这两个网站在跑完测试以后，会自动生成测试结果的小图片</p><p><img src="https://img.alicdn.com/tps/TB1veJ7LVXXXXXMaXXXXXXXXXXX-420-64.png" alt="build result"></p><p>Travis会读取项目下的<code>travis.yml</code>文件，一个简单的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"stable"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"4.0.0"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"5.0.0"</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">"npm run test"</span></span><br><span class="line"><span class="attr">after_script:</span> <span class="string">"npm install coveralls@2.10.0 &amp;&amp; cat ./coverage/lcov.info | coveralls"</span></span><br></pre></td></tr></table></figure><p>language定义了运行环境的语言，而对应的node_js可以定义需要在哪几个Node.js版本做测试，比如这里的定义，代表着会分别在最新稳定版、4.0.0、5.0.0版本的Node.js环境下做测试</p><p>而script则是测试利用的命令，一般情况下，都应该把自己这个项目开发所需要的命令都写在package.json的scripts里面，比如我们的测试方法<code>./node_modules/karma/bin/karma start --single-run</code>就应当这样写到scripts里：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"./node_modules/karma/bin/karma start --single-run"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而after_script则是在测试完成之后运行的命令，这里需要上传覆盖率结果到coveralls，只需要安装coveralls库，然后获取lcov.info上传给Coveralls即可</p><blockquote><p>更多配置请参照Travis官网介绍</p></blockquote><p>这样配置后，每次push的结果都可以上Travis和Coveralls看构建和代码覆盖率结果了</p><p><img src="https://img.alicdn.com/tps/TB1eC41LVXXXXXhapXXXXXXXXXX-2074-806.png" alt="travis"></p><p><img src="https://img.alicdn.com/tps/TB1KSacLVXXXXXxXVXXXXXXXXXX-1924-1468.jpg" alt="coveralls"></p><h3 id="内网的持续集成"><a href="#内网的持续集成" class="headerlink" title="内网的持续集成"></a>内网的持续集成</h3><p>当然，我们的工作相关代码肯定不能发到GitHub上，但这并不意味着我们不能做持续集成了。内网有<a href="cise.alibaba-inc.com">CISE平台</a>和<a href="ci.uitest.taobao.net/task">UITest平台</a>可以做同样的事情。</p><p>对于需要加入持续集成的项目，大致上需要如下几步：</p><ol><li>开启项目持续集成功能</li><li>创建配置文件</li><li>配置插件和命令</li><li>将测试结果标志写入README</li></ol><h4 id="开启项目持续集成"><a href="#开启项目持续集成" class="headerlink" title="开启项目持续集成"></a>开启项目持续集成</h4><p>GitLab项目页面 -&gt; 左侧菜单Setting -&gt; 左侧菜单Services -&gt; CISE -&gt; 勾选Active -&gt; SAVE CHANGES，这样就可以开启项目持续集成了</p><p><img src="https://img.alicdn.com/tps/TB1zf88LVXXXXXuaXXXXXXXXXXX-2746-692.jpg" alt="cise open"></p><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><p>与开源的Travis相同，CISE需要在项目下创建一个<code>.cise.yml</code>，内容大致如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stage:</span></span><br><span class="line">  <span class="attr">node-4:</span></span><br><span class="line">    <span class="attr">prepare:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">      <span class="comment"># 安装 nvm, 存在则不重复安装</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ls</span> <span class="string">/root/nvm</span> <span class="string">||</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">http://gitlab.alibaba-inc.com/node/nvm.git</span> <span class="string">--depth</span> <span class="number">1</span> <span class="string">/root/nvm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'source /root/nvm/nvm.sh'</span> <span class="string">&gt;&gt;</span> <span class="string">/root/.bashrc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nvm</span> <span class="string">use</span> <span class="number">4.0</span><span class="number">.0</span> <span class="string">||</span> <span class="string">nvm</span> <span class="string">install</span> <span class="number">4.0</span><span class="number">.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nvm</span> <span class="string">alias</span> <span class="string">default</span> <span class="number">4.0</span><span class="number">.0</span></span><br><span class="line">      <span class="comment"># 安装 tnpm, 存在则不重新安装</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tnpm</span> <span class="string">-v</span> <span class="string">||</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--silent</span> <span class="string">-g</span> <span class="string">tnpm</span> <span class="string">--registry=http://registry.npm.alibaba-inc.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tnpm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">@ali/def-ci</span> <span class="string">--silent</span></span><br><span class="line">      <span class="comment"># --unsafe-perm: http://gitlab.alibaba-inc.com/uitest/knight/issues/6</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tnpm</span> <span class="string">install</span> <span class="string">--silent</span> <span class="string">--unsafe-perm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node</span> <span class="string">-v;</span> <span class="string">npm</span> <span class="string">-v;</span> <span class="string">tnpm</span> <span class="string">-v</span></span><br><span class="line">    <span class="attr">unit_test:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">fed-ci</span> <span class="string">--repo</span> <span class="string">$&#123;scm_url&#125;</span> <span class="string">--branch</span> <span class="string">$&#123;scm_branch&#125;</span> <span class="string">--commitId</span> <span class="string">$&#123;source_version&#125;</span> <span class="string">--ciseBuildId</span> <span class="string">$&#123;build_idx&#125;</span> <span class="string">--ciseId</span> <span class="string">$&#123;task_id&#125;</span> <span class="string">--empId</span> <span class="string">$&#123;creator_emp_id&#125;</span></span><br><span class="line">  <span class="attr">node-5:</span></span><br><span class="line">    <span class="attr">prepare:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">      <span class="comment"># 安装 nvm, 存在则不重复安装</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ls</span> <span class="string">/root/nvm</span> <span class="string">||</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">http://gitlab.alibaba-inc.com/node/nvm.git</span> <span class="string">--depth</span> <span class="number">1</span> <span class="string">/root/nvm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">echo</span> <span class="string">'source /root/nvm/nvm.sh'</span> <span class="string">&gt;&gt;</span> <span class="string">/root/.bashrc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nvm</span> <span class="string">use</span> <span class="number">5.0</span><span class="number">.0</span> <span class="string">||</span> <span class="string">nvm</span> <span class="string">install</span> <span class="number">5.0</span><span class="number">.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nvm</span> <span class="string">alias</span> <span class="string">default</span> <span class="number">5.0</span><span class="number">.0</span></span><br><span class="line">      <span class="comment"># 安装 tnpm, 存在则不重新安装</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tnpm</span> <span class="string">-v</span> <span class="string">||</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--silent</span> <span class="string">-g</span> <span class="string">tnpm</span> <span class="string">--registry=http://registry.npm.alibaba-inc.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tnpm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">@ali/def-ci</span> <span class="string">--silent</span></span><br><span class="line">      <span class="comment"># --unsafe-perm: http://gitlab.alibaba-inc.com/uitest/knight/issues/6</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tnpm</span> <span class="string">install</span> <span class="string">--silent</span> <span class="string">--unsafe-perm</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node</span> <span class="string">-v;</span> <span class="string">npm</span> <span class="string">-v;</span> <span class="string">tnpm</span> <span class="string">-v</span></span><br><span class="line">    <span class="attr">unit_test:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">fed-ci</span> <span class="string">--repo</span> <span class="string">$&#123;scm_url&#125;</span> <span class="string">--branch</span> <span class="string">$&#123;scm_branch&#125;</span> <span class="string">--commitId</span> <span class="string">$&#123;source_version&#125;</span> <span class="string">--ciseBuildId</span> <span class="string">$&#123;build_idx&#125;</span> <span class="string">--ciseId</span> <span class="string">$&#123;task_id&#125;</span> <span class="string">--empId</span> <span class="string">$&#123;creator_emp_id&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">node-4,</span> <span class="string">node-5</span></span><br></pre></td></tr></table></figure><p>CISE的配置稍微复杂一些，但是更加灵活。通过上面的配置，会分别在Node.js 4.0.0版本和Node.js 5.0.0版本进行测试，在prepare里可以清除的看到需要做哪些准备，</p><h4 id="配置插件和命令"><a href="#配置插件和命令" class="headerlink" title="配置插件和命令"></a>配置插件和命令</h4><p>而在package.json里需要配置需要配置对应的scripts和ci插件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"ci"</span>: <span class="string">"./node_modules/karma/bin/karma start --single-run"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"ciPlugins"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CISE会自动执行<code>npm run ci</code>，并自动收集<code>coverage/coverage.json</code>生成覆盖率结果</p><h4 id="将测试结果标志写入README"><a href="#将测试结果标志写入README" class="headerlink" title="将测试结果标志写入README"></a>将测试结果标志写入README</h4><p>首先需要<code>tnpm install --save-dev @ali/def</code>安装@ali/def工具，然后在项目路径下执行<code>def ci badge</code>就可以生成markdown格式的标志了，把他们复制到自己的README里即可</p><p><img src="https://img.alicdn.com/tps/TB1fJiqLVXXXXbMXXXXXXXXXXXX-2092-582.jpg" alt="def ci badge"></p><h4 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h4><p>好了，准备完成了，只需要push一下代码，就可以看到CISE平台自动创建测试任务：</p><p><img src="https://img.alicdn.com/tps/TB1tS5rLVXXXXbXXXXXXXXXXXXX-2752-1300.jpg" alt="执行测试"></p><p>测试的结果也可以在UITest上查看</p><p><img src="https://img.alicdn.com/tps/TB1bbCbLVXXXXXAXVXXXXXXXXXX-2100-1292.jpg" alt="UITest"></p><blockquote><p>Karma跑PhantomJS的方案似乎没有办法在CISE的机器上运行，原因是karma-phantomjs-launcher依赖了2+版本的phantomjs——phantomjs-prebuilt，这个库是C++实现，在CISE机器上由于C++库版本的问题无法编译通过。目前没有看到比较好的解决办法，倒是mocha-phantomjs依赖的phantomjs 1.9+版本可以在CISE机器上正常运行</p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>项目接入持续集成在多人开发同一个仓库时候能起到很大的用途，每次push都能自动触发测试，测试没过会发生告警。如果需求采用Issues+Merge Request来管理，每个需求一个Issue+一个分支，开发完成后提交Merge Request，由项目Owner负责合并，项目质量将更有保障</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里只是前端测试相关知识的一小部分，还有非常多的内容可以深入挖掘，而测试也仅仅是前端流程自动化的一部分。在前端技术快速发展的今天，前端项目不再像当年的刀耕火种一般，越来越多的软件工程经验被集成到前端项目中，前端项目正向工程化、流程化、自动化方向高速奔跑。还有更多优秀的提升开发效率、保证开发质量的自动化方案亟待我们挖掘。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</category>
      
      
      <category domain="http://lingyu.life/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</category>
      
      <category domain="http://lingyu.life/tags/%E5%B7%A5%E5%85%B7/">工具</category>
      
      
      <comments>http://lingyu.life/2016/03/07/new/autotest/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>用React做重构时的一些思考</title>
      <link>https://lingyu.life/#/post/2015/08/30/old/chonggou</link>
      <guid>https://lingyu.life/#/post/2015/08/30/old/chonggou</guid>
      <pubDate>Sat, 29 Aug 2015 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;好久没写东西了，主要是工作比以前学生时代忙多了，周末也是各种加班充电，沉淀的少了。最近一直在用React对手上的老业务做重构，这里写一下重构中的一些感悟和思考&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>好久没写东西了，主要是工作比以前学生时代忙多了，周末也是各种加班充电，沉淀的少了。最近一直在用React对手上的老业务做重构，这里写一下重构中的一些感悟和思考</p><a id="more"></a><h2 id="老业务和老代码"><a href="#老业务和老代码" class="headerlink" title="老业务和老代码"></a>老业务和老代码</h2><h3 id="前台和后台"><a href="#前台和后台" class="headerlink" title="前台和后台"></a>前台和后台</h3><p>入职之后刚开始接手的是前台展示业务，基本上是在已有的框架上写模块，前台业务尤其是活动期间光完成业务就累得半死。</p><p>后来随着一次业务调整，开始负责商家后台业务了，两边节奏和开发方式都完全不同。前台业务更新换代较快，没事就改个版啥的，后台就完全不同了：</p><ol><li>后台的业务偏重的是功能，与前台业务酷炫的交互不同，后台业务往往是数据的直观展示和CRUD操作</li><li>前台业务往往可以根据展示的区域划分为多个模块，模块较为独立，很少有模块之间的通信。而后台业务往往是多个子功能模块通过复杂的业务逻辑串联到一起形成完整的功能</li></ol><h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>目前负责的应用应该是整个天猫最复杂的应用，里面都是一些老旧的代码，有很重的历史包袱。模块之间的划分不清晰，模块之间的耦合也比较严重，对DOM的交叉修改，不必要的依赖各种各样。进来后思考的最多的就是对这块老代码做重构。</p><p>当然老业务只是代码老，并不代表没有新需求，所以对于接手老代码的开发者来说，最重要的一点是：</p><blockquote><p>老坑没填的情况下，首先保证不会挖新坑，不要明知道之前的开发者使用了错误的开发方式，还不负责任的继续使用。历史问题会随着技术的发展和时间的推移而像滚雪球一样越滚越大，如果放任其滚下去很可能最后整个应用完全不可维护</p></blockquote><p>目前负责老业务并不是单纯的老到只需要维护就可以了，事实上还有大量的新需求不断加入当中，它们就是滚雪球时不断粘附到雪球上的雪</p><ul><li>对于与老代码之间耦合不是特别强烈的新需求，采用较为独立的模块化开发方式，以一种可插拔的形式嵌入到老业务中，保证插和拔的时候不会影响老业务正常运作</li><li>在老业务原有的代码上做更改，这是熟悉老业务代码的最佳方式，理清楚要修改的老业务代码逻辑，若涉及的模块和其他模块耦合程度较低，就将其抽离。如果耦合程度较高，就采用对现有架构尽可能小影响的开发方式开发</li><li>解耦的过程就像剥洋葱，剥离了最外面一层，里面一层就变成最外一层了，一层层剥到核心，整个解耦过程就完成了</li></ul><h2 id="老业务中的React"><a href="#老业务中的React" class="headerlink" title="老业务中的React"></a>老业务中的React</h2><p>在整个解耦的过程中，采用React做解耦。目前比较流行的React开发方式是采用Common JS开发，模块直接通过npm管理，上线时采用webpack或browserify做打包。但受限于身上的历史包袱，不可能整页采用React实现，成本太大。目前整体页面依旧是普通JS，通过模块加载器管理着各个模块，其中一些模块是React实现的，利用browserify的babelify+babel-runtime做ES 6语法编译，保证即使ES 6语法编写的代码也能够正常跑在浏览器上，由于每个模块是独立的，因此这样会产生一些问题，后面会讲到</p><h3 id="React做模块"><a href="#React做模块" class="headerlink" title="React做模块"></a>React做模块</h3><p>为什么要用 React 做解耦，主要是看中其封装理念，一个模块或组件，应当有：</p><ol><li>提供一些配置数据</li><li>模块自己内部逻辑用的数据</li><li>提供一些供交互的接口和事件</li></ol><h4 id="兼容JSX和原生JS调用"><a href="#兼容JSX和原生JS调用" class="headerlink" title="兼容JSX和原生JS调用"></a>兼容JSX和原生JS调用</h4><p>1，2，3分别对应props、state和onXXX回调。对于老业务而言，如果外层不是React，而是模块加载器包裹的原生JS怎么办呢？其实React组件完全可以独立运行，毕竟有<code>React.render</code>，举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'react'</span>, <span class="string">'event-mixin'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">React, EventMixin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defaultConfig = &#123;</span><br><span class="line">    value: <span class="string">''</span>,</span><br><span class="line">    onChange: noop</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> Component = React.createClass(&#123;</span><br><span class="line">    mixins: [EventMixin],</span><br><span class="line">    propTypes: &#123;&#125;,</span><br><span class="line">    getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> defaultConfig;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    setValue: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Component.init = <span class="function"><span class="keyword">function</span>(<span class="params">container, config</span>) </span>&#123;</span><br><span class="line">    config = S.merge(&#123;&#125;, defaultConfig, config);</span><br><span class="line">    <span class="keyword">return</span> React.render(<span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...config</span>&#125;/&gt;</span></span>, container);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Component;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，返回一个React类，这个类提供了静态方法用于在容器中直接绘制组件，方便原生JS，而JSX中也可以直接使用标签的方式使用组件</p><p>对于上面说的三点：</p><ol><li>配置数据props的传入：原生JS采用init方法传入，JSX直接写在标签上</li><li>内部数据state组件维护</li><li>组件的方法和事件，对于原生JS提供了getValue、setValue这样的方法，而对于JSX使用则直接可以通过配置传入。对于事件的处理采用了混入Event模型的方式，为组件自身提供了on、off、fire这种事件模型方法供原生JS使用，而对于JSX的调用方式，则直接使用onXXX风格的回调即可</li></ol><p>这样组件就可以兼容外层是JSX或外层是JS的调用方式，同时兼容新业务和老业务</p><h4 id="组件独立性"><a href="#组件独立性" class="headerlink" title="组件独立性"></a>组件独立性</h4><p>同时，一个组件应当保证对应的独立性：</p><ol><li>样式的独立</li><li>DOM的独立</li><li>组件逻辑的独立</li></ol><p>个人认为一个组件应该standalone就能跑起来的，React非常好的提供了DOM的独立和组件逻辑的独立，采用inline-style的方式也能提供样式的独立。其中DOM的独立非常重要，一旦多个组件DOM形成耦合，这几个组件的解耦将异常困难。React组件的每个DOM元素都分配了自己的id，一旦修改就会发生错误，强制了DOM的独立。</p><p>这样组件就只关注自己了，那么问题就来了，组件都只关注自己，组件之间交互怎么办？所以有Flux</p><h4 id="模块间通信"><a href="#模块间通信" class="headerlink" title="模块间通信"></a>模块间通信</h4><p>React解决了组件实现，组件间通信就交给了Flux的模式，Flux是一种数据通信模式，其实说简单点就是全局有一些保存数据的Store，各个React组件相互之间通信不是直接通信，而是通过这些保存数据的Store，一个组件修改Store递交数据，另外一个组件监听Store的变化获得数据来实现数据的传输。不过数据传输是单向的</p><p>以往组件之间的耦合是因为一个组件直接调用了另外一个组件的接口，现在大家都不依赖接口了，直接依赖数据，从主动调用变成了被动通知变更</p><p>这里有几个点：</p><ol><li>一个数据需求模块初始化后，一直在监听数据变化，但变更数据的模块可能根本就不存在，这个数据需求模块就蛋疼了，其实当不存在数据变更模块的时候，这个数据需求模块是不应该被初始化的</li><li>由于数据需求模块只在乎数据，给他的数据长啥样，它就长啥样，多个模块共同修改同一份数据时，永远是最新的数据决定了模块的展示，数据需求模块本身必须是无状态的，因为它没办法保证它所依赖的多份数据的递交顺序</li><li>数据需求模块依赖的数据结构是定死的， 变更数据的模块吐出来的数据结果也是定死的，这就产生一个问题，这两个定死的数据结构需要做适配，每个模块只关注自身，当然不应该考虑为其他模块做数据适配。所以这个适配就得在Flux上做，需要尽可能的通过定义开发规范来减少数据适配的出现</li><li>需要immutable保证数据本身的独立性，防止交叉修改同一份数据导致数据污染</li><li>数据都是整块递交，需要DOM Diff这样的方式来保证重绘范围尽可能小</li></ol><h3 id="Webpack和Browserify"><a href="#Webpack和Browserify" class="headerlink" title="Webpack和Browserify"></a>Webpack和Browserify</h3><p>这俩的运行机制大体上来说就是分析Common JS代码的AST语法树，找到其中的require指定的依赖名称，然后递归的分析依赖，最后将所有的依赖打包在一起，并配合打包工具自己的模块加载机制复写或替换require实现加载。采用这种方式，组件的安装和使用变得和Common JS一样简单，不用考虑组件的版本管理，因为组件在node_modules里面都有对应版本的源码。</p><p>但这种方式容易产生性能问题：</p><ol><li>不少Common JS的模块都有自己依赖的工具包，这些工具包的版本通常并不相同，这也就导致了重复打包的问题</li><li>Common JS的模块开发方式使得不少开发者没有在意自己使用的包的大小或内容，往往会为了几个很小的功能而引入一个完整的工具库，这在Node.Js上没什么，但是到了浏览器端，就成了大问题</li><li>很多模块没有采用异步加载依赖的方式，而是直接require同步加载依赖，导致打包出来的入口文件巨大无比…首屏很慢</li><li>ES 6的打包碎片问题，如果整页打包当然不存在碎片的问题。但是对于多个模块分开打包，就很导致每个模块自己独立打包，会生成自己的一些编译依赖，而通过模块加载器一起使用时，由于模块相互之间独立，这些依赖虽然有很多是相同的，但也会被引入很多次。目前没有什么好的解决办法，就是减少碎片生成。</li><li>React组件对于子组件的引入都是同步的，如果整页都是React开发就很容易遇到3中的问题</li></ol><p>对于一些新业务，用打包工具整页打包还是可行的，但是一定要注意处理好异步加载的模块，同时保证依赖本身的轻量。而对于老业务，则需要减少独立打包时产生的碎片。不管什么开发方式，都需要注意1，2的情况，个人比较倾向的方式就是，最外层依旧采用现有的AMD模块管理方式，而部分模块采用React开发，防止出现5和3的问题，但4的问题就得通过定义开发规范的方式来规避了</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这里随便写一点，可能个人对于React和打包技术的理解有误导致观点不符。其实还是一点，不同的业务场景有自身的技术取舍，能解决问题的技术就是好技术。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <category domain="http://lingyu.life/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/">前端架构</category>
      
      
      <comments>http://lingyu.life/2015/08/30/old/chonggou/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>轻松入门React和Webpack</title>
      <link>https://lingyu.life/#/post/2015/05/15/old/react-and-webpack</link>
      <guid>https://lingyu.life/#/post/2015/05/15/old/react-and-webpack</guid>
      <pubDate>Thu, 14 May 2015 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近在学习React.js，之前都是直接用最原生的方式去写React代码，发现组织起来特别麻烦，之前听人说用Webpack组织React组件得心应手，就花了点时间学习了一下，收获颇丰&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近在学习React.js，之前都是直接用最原生的方式去写React代码，发现组织起来特别麻烦，之前听人说用Webpack组织React组件得心应手，就花了点时间学习了一下，收获颇丰</p><a id="more"></a><h2 id="说说React"><a href="#说说React" class="headerlink" title="说说React"></a>说说React</h2><p>一个组件，有自己的结构，有自己的逻辑，有自己的样式，会依赖一些资源，会依赖某些其他组件。比如日常写一个组件，比较常规的方式：</p><p>－ 通过前端模板引擎定义结构<br>－ JS文件中写自己的逻辑<br>－ CSS中写组件的样式<br>－ 通过RequireJS、SeaJS这样的库来解决模块之间的相互依赖，<br>那么在React中是什么样子呢？</p><h3 id="结构和逻辑"><a href="#结构和逻辑" class="headerlink" title="结构和逻辑"></a>结构和逻辑</h3><p>在React的世界里，结构和逻辑交由JSX文件组织，React将模板内嵌到逻辑内部，实现了一个JS代码和HTML混合的JSX。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>在JSX文件中，可以直接通过<code>React.createClass</code>来定义组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CustomComponent = React.creatClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"custom-component"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这种方式可以很方便的定义一个组件，组件的结构定义在render函数中，但这并不是简单的模板引擎，我们可以通过js方便、直观的操控组件结构，比如我想给组件增加几个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CustomComponent = React.creatClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $nodes = [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;str&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"custom-component"</span>&gt;</span>&#123;$nodes&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这种方式，React使得组件拥有灵活的结构。那么React又是如何处理逻辑的呢？</p><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>写过前端组件的人都知道，组件通常首先需要相应自身DOM事件，做一些处理。必要时候还需要暴露一些外部接口，那么React组件要怎么做到这两点呢？</p><h5 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h5><p>比如我有个按钮组件，点击之后需要做一些处理逻辑，那么React组件大致上长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击按钮应当触发相应地逻辑，一种比较直观的方式就是给button绑定一个<code>onclick</code>事件，里面就是需要执行的逻辑了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDragonKillingSword</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//送宝刀</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getDragonKillingSword()"</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但事实上<code>getDragonKillingSword()</code>的逻辑属于组件内部行为，显然应当包装在组件内部，于是在React中就可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    getDragonKillingSword: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//送宝刀</span></span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就实现内部事件的响应了，那如果需要暴露接口怎么办呢？</p><h5 id="暴露接口"><a href="#暴露接口" class="headerlink" title="暴露接口"></a>暴露接口</h5><p>事实上现在<code>getDragonKillingSword</code>已经是一个接口了，如果有一个父组件，想要调用这个接口怎么办呢？</p><p>父组件大概长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ImDaddyComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                <span class="comment">//其他组件</span></span><br><span class="line">                &lt;ButtonComponent /&gt;</span><br><span class="line">                <span class="comment">//其他组件</span></span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p>那么如果想手动调用组件的方法，首先在ButtonComponent上设置一个<code>ref=&quot;&quot;</code>属性来标记一下，比如这里把子组件设置成<code>&lt;ButtonComponent ref=&quot;getSwordButton&quot;/&gt;</code>，那么在父组件的逻辑里，就可以在父组件自己的方法中通过这种方式来调用接口方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.refs.getSwordButton.getDragonKillingSword();</span><br></pre></td></tr></table></figure><p>看起来屌屌哒~那么问题又来了，父组件希望自己能够按钮点击时调用的方法，那该怎么办呢？</p><h5 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h5><p>父组件可以直接将需要执行的函数传递给子组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ButtonComponent clickCallback=&#123;<span class="keyword">this</span>.getSwordButtonClickCallback&#125;/&gt;</span><br></pre></td></tr></table></figure><p>然后在子组件中调用父组件方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.clickCallback&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子组件通过<code>this.props</code>能够获取在父组件创建子组件时传入的任何参数，因此<code>this.props</code>也常被当做配置参数来使用</p><p>屠龙宝刀每个人只能领取一把，按钮点击一下就应该灰掉，应当在子组件中增加一个是否点击过的状态，这又应当处理呢？</p><h5 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h5><p>在React中，每个组件都有自己的状态，可以在自身的方法中通过<code>this.state</code>取到，而初始状态则通过<code>getInitialState()</code>方法来定义，比如这个屠龙宝刀按钮组件，它的初始状态应该是没有点击过，所以<code>getInitialState</code>方法里面应当定义初始状态<code>clicked: false</code>。而在点击执行的方法中，应当修改这个状态值为<code>click: true</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//确定初始状态</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            clicked: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    getDragonKillingSword: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//送宝刀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改点击状态</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            clicked: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样点击状态的维护就完成了，那么render函数中也应当根据状态来维护节点的样式，比如这里将按钮设置为<code>disabled</code>，那么render函数就要添加相应的判断逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clicked = <span class="keyword">this</span>.state.clicked;</span><br><span class="line">    <span class="keyword">if</span>(clicked)</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p>这里简单介绍了通过JSX来管理组件的结构和逻辑，事实上React给组件还定义了很多方法，以及组件自身的生命周期，这些都使得组件的逻辑处理更加强大</p><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>CSS文件定义了组件的样式，现在的模块加载器通常都能够加载CSS文件，如果不能一般也提供了相应的插件。事实上CSS、图片可以看做是一种资源，因为加载过来后一般不需要做什么处理。</p><p>React对这一方面并没有做特别的处理，虽然它提供了Inline Style的方式把CSS写在JSX里面，但估计没有多少人会去尝试，毕竟现在CSS样式已经不再只是简单的CSS文件了，通常都会去用Less、Sass等预处理，然后再用像postcss、myth、autoprefixer、cssmin等等后处理。资源加载一般也就简单粗暴地使用模块加载器完成了</p><h3 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h3><p>组件依赖的处理一般分为两个部分：组件加载和组件使用</p><h4 id="组件加载"><a href="#组件加载" class="headerlink" title="组件加载"></a>组件加载</h4><p>React没有提供相关的组件加载方法，依旧需要通过<code>&lt;script&gt;</code>标签引入，或者使用模块加载器加载组件的JSX和资源文件。</p><h4 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h4><p>如果细心，就会发现其实之前已经有使用的例子了，要想在一个组件中使用另外一个组件，比如在<code>ParentComponent</code>中使用<code>ChildComponent</code>，就只需要在<code>ParentComponent</code>的<code>render()</code>方法中写上<code>&lt;ChildComponent /&gt;</code>就行了，必要的时候还可以传些参数。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>到这里就会发现一个问题，React除了只处理了结构和逻辑，资源也不管，依赖也不管。是的，React将近两万行代码，连个模块加载器都没有提供，更与Angularjs，jQuery等不同的是，他还不带啥脚手架…没有Ajax库，没有Promise库，要啥啥没有…</p><h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>那它为啥这么大？因为它实现了一个虚拟DOM（Virtual DOM）。虚拟DOM是干什么的？这就要从浏览器本身讲起</p><p>如我们所知，在浏览器渲染网页的过程中，加载到HTML文档后，会将文档解析并构建DOM树，然后将其与解析CSS生成的CSSOM树一起结合产生爱的结晶——RenderObject树，然后将RenderObject树渲染成页面（当然中间可能会有一些优化，比如RenderLayer树）。这些过程都存在与渲染引擎之中，渲染引擎在浏览器中是于JavaScript引擎（JavaScriptCore也好V8也好）分离开的，但为了方便JS操作DOM结构，渲染引擎会暴露一些接口供JavaScript调用。由于这两块相互分离，通信是需要付出代价的，因此JavaScript调用DOM提供的接口性能不咋地。各种性能优化的最佳实践也都在尽可能的减少DOM操作次数。</p><p>而虚拟DOM干了什么？它直接用JavaScript实现了DOM树（大致上）。组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React又通过在这个虚拟DOM上实现了一个 diff 算法找出最小变更，再把这些变更写入实际的DOM中。这个虚拟DOM以JS结构的形式存在，计算性能会比较好，而且由于减少了实际DOM操作次数，性能会有较大提升</p><p><strong>道理我都懂，可是为什么我们没有模块加载器？</strong></p><p>所以就需要Webpack了</p><h2 id="说说Webpack"><a href="#说说Webpack" class="headerlink" title="说说Webpack"></a>说说Webpack</h2><h3 id="什么是Webpack？"><a href="#什么是Webpack？" class="headerlink" title="什么是Webpack？"></a>什么是Webpack？</h3><p>事实上它是一个打包工具，而不是像RequireJS或SeaJS这样的模块加载器，通过使用Webpack，能够像Node.js一样处理依赖关系，然后解析出模块之间的依赖，将代码打包</p><h3 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h3><p>首先得有Node.js</p><p>然后通过<code>npm install -g webpack</code>安装webpack，当然也可以通过gulp来处理webpack任务，如果使用gulp的话就<code>npm install --save-dev gulp-webpack</code></p><h3 id="配置Webpack"><a href="#配置Webpack" class="headerlink" title="配置Webpack"></a>配置Webpack</h3><p>Webpack的构建过程需要一个配置文件，一个典型的配置文件大概就是这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> commonsPlugin = <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        entry1: <span class="string">'./entry/entry1.js'</span>,</span><br><span class="line">        entry2: <span class="string">'./entry/entry2.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: <span class="string">'[name].entry.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.jsx$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader!jsx-loader?harmony'</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [commonsPlugin]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里对Webpack的打包行为做了配置，主要分为几个部分：</p><ul><li>entry：指定打包的入口文件，每有一个键值对，就是一个入口文件</li><li>output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称，filename里面的<code>[name]</code>会由entry中的键（这里是entry1和entry2）替换</li><li>resolve：定义了解析模块路径时的配置，常用的就是extensions，可以用来指定模块的后缀，这样在引入模块时就不需要写后缀了，会自动补全</li><li>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。比如这里定义了凡是<code>.js</code>结尾的文件都是用<code>babel-loader</code>做处理，而<code>.jsx</code>结尾的文件会先经过<code>jsx-loader</code>处理，然后经过<code>babel-loader</code>处理。当然这些loader也需要通过<code>npm install</code>安装</li><li>plugins: 这里定义了需要使用的插件，比如commonsPlugin在打包多个入口文件时会提取出公用的部分，生成common.js</li></ul><p>当然Webpack还有很多其他的配置，具体可以参照它的<a href="http://webpack.github.io/docs/configuration.html#entry" target="_blank" rel="noopener">配置文档</a></p><h3 id="执行打包"><a href="#执行打包" class="headerlink" title="执行打包"></a>执行打包</h3><p>如果通过<code>npm install -g webpack</code>方式安装webpack的话，可以通过命令行直接执行打包命令，比如这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">webpack --config webpack.config.js</span></span><br></pre></td></tr></table></figure><p>这样就会读取当前目录下的webpack.config.js作为配置文件执行打包操作</p><p>如果是通过gulp插件gulp-webpack，则可以在gulpfile中写上gulp任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'gulp-webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line">gulp.task(<span class="string">"webpack"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .src(<span class="string">'./'</span>)</span><br><span class="line">        .pipe(webpack(webpackConfig))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="组件编写"><a href="#组件编写" class="headerlink" title="组件编写"></a>组件编写</h3><h4 id="使用Babel提升逼格"><a href="#使用Babel提升逼格" class="headerlink" title="使用Babel提升逼格"></a>使用Babel提升逼格</h4><p>Webpack使得我们可以使用Node.js的CommonJS规范来编写模块，比如一个简单的Hello world模块，就可以这么处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloWorldComponent = React.createClass(&#123;</span><br><span class="line">    displayName: <span class="string">'HelloWorldComponent'</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloWorldComponent;</span><br></pre></td></tr></table></figure><p>等等，这和之前的写法没啥差别啊，依旧没有逼格…程序员敲码要有geek范，要逼格than逼格，这太low了。现在都ES6了，React的代码也要写ES6，<code>babel-loader</code>就是干这个的。<a href="https://babeljs.io" target="_blank" rel="noopener">Babel</a>能够将ES6代码转换成ES5。首先需要通过命令<code>npm install --save-dev babel-loader</code>来进行安装，安装完成后就可以使用了，一种使用方式是之前介绍的在<code>webpack.config.js</code>的loaders中配置，另一种是直接在代码中使用，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloWorldComponent = <span class="built_in">require</span>(<span class="string">'!babel!jsx!./HelloWorldComponent'</span>);</span><br></pre></td></tr></table></figure><p>那我们应当如何使用Babel提升代码的逼格呢？改造一下之前的HelloWorld代码吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在其他组件中需要引入HelloWorldComponent组件，就只要就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorldComponent <span class="keyword">from</span> <span class="string">'./HelloWorldComponent'</span></span><br></pre></td></tr></table></figure><p>怎么样是不是更有逼格了？通过import引入模块，还可以直接定义类和类的继承关系，这里也不再需要<code>getInitialState</code>了，直接在构造函数<code>constructor</code>中用<code>this.state = xxx</code>就好了</p><p>Babel带来的当然还不止这些，在其帮助下还能尝试很多优秀的ES6特性，比如箭头函数，箭头函数的特点就是内部的this和外部保持一致，从此可以和<code>that</code>、<code>_this</code>说再见了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>].map(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;c&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其他还有很多，具体可以参照<a href="https://babeljs.io/docs/learn-es6" target="_blank" rel="noopener">Babel的学习文档</a></p><h4 id="样式编写"><a href="#样式编写" class="headerlink" title="样式编写"></a>样式编写</h4><p>我是一个强烈地Less依赖患者，脱离了Less直接写CSS就会出现四肢乏力、不想干活、心情烦躁等现象，而且还不喜欢在写Less时候加前缀，平常都是gulp+less+autoprefixer直接处理的，那么在Webpack组织的React组件中要怎么写呢？</p><p><strong>没错，依旧是使用loader</strong></p><p>可以在<code>webpack.config.js</code>的loaders中增加Less的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  loader: <span class="string">'style-loader!css-loader!autoprefixer-loader!less-loader'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的配置，就可以直接在模块代码中引入Less样式了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./HelloWorldComponent.less'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Webpack的loader为React组件化提供了很多帮助，像图片也提供了相关的loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.png$/</span>, <span class="attr">loader</span>: <span class="string">"url-loader?mimetype=image/png"</span> &#125;</span><br></pre></td></tr></table></figure><p>更多地loader可以移步<a href="https://github.com/webpack/docs/wiki/list-of-loaders" target="_blank" rel="noopener">webpack的wiki</a></p><h2 id="在Webpack下实时调试React组件"><a href="#在Webpack下实时调试React组件" class="headerlink" title="在Webpack下实时调试React组件"></a>在Webpack下实时调试React组件</h2><p>Webpack和React结合的另一个强大的地方就是，在修改了组件源码之后，不刷新页面就能把修改同步到页面上。这里需要用到两个库<code>webpack-dev-server</code>和<code>react-hot-loader</code>。</p><p>首先需要安装这两个库，<code>npm install --save-dev webpack-dev-server react-hot-loader</code></p><p>安装完成后，就要开始配置了，首先需要修改entry配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  helloworld: [</span><br><span class="line">    <span class="string">'webpack-dev-server/client?http://localhost:3000'</span>,</span><br><span class="line">    <span class="string">'webpack/hot/only-dev-server'</span>,</span><br><span class="line">    <span class="string">'./helloworld'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>通过这种方式指定资源热启动对应的服务器，然后需要配置<code>react-hot-loader</code>到loaders的配置当中，比如我的所有组件代码全部放在scripts文件夹下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">  loaders: [<span class="string">'react-hot'</span>, <span class="string">'babel'</span>],</span><br><span class="line">  include: [path.join(__dirname, <span class="string">'scripts'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配置一下plugins，加上热替换的插件和防止报错的插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  <span class="keyword">new</span> webpack.NoErrorsPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样配置就完成了，但是现在要调试需要启动一个服务器，而且之前配置里映射到<code>http://localhost:3000</code>，所以就在本地3000端口起个服务器吧，在项目根目录下面建个server.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> WebpackDevServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  publicPath: config.output.publicPath,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening at localhost:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以在本地3000端口开启调试服务器了，比如我的页面是根目录下地<code>index.html</code>，就可以直接通过<code>http://localhost:3000/index.html</code>访问页面，修改React组件后页面也会被同步修改，这里貌似使用了websocket来同步数据。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>React的组件化开发很有想法，而Webpack使得React组件编写和管理更加方便，这里只涉及到了React和Webpack得很小一部分，还有更多的最佳实践有待在学习的路上不断发掘</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E9%A1%B5%E9%9D%A2%E6%A1%86%E6%9E%B6/">页面框架</category>
      
      
      <category domain="http://lingyu.life/tags/React/">React</category>
      
      
      <comments>http://lingyu.life/2015/05/15/old/react-and-webpack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前端动画对比</title>
      <link>https://lingyu.life/#/post/2015/04/18/old/learn-canvas-1</link>
      <guid>https://lingyu.life/#/post/2015/04/18/old/learn-canvas-1</guid>
      <pubDate>Fri, 17 Apr 2015 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;将近三个月没写文章了，就在这三个月内，我从一只学生狗变成了上班族。现在一切都稳定下来了，决定重新开始写点东西了。以后的计划是每周一篇，努力坚持~&lt;/p&gt;
&lt;p&gt;之前玩了很长时间的Canvas动画，也写了一些工具和一些demo，放在了我Github上的&lt;a href=&quot;https://github.com/LingyuCoder/learn-canvas&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;learn-canvas&lt;/a&gt;仓库里。在学习Canvas动画的过程中学到了不少宝贵的新知识，这篇主要是个人对于Canvas动画的一些想法以及与其他前端动画实现的一些对比。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>将近三个月没写文章了，就在这三个月内，我从一只学生狗变成了上班族。现在一切都稳定下来了，决定重新开始写点东西了。以后的计划是每周一篇，努力坚持~</p><p>之前玩了很长时间的Canvas动画，也写了一些工具和一些demo，放在了我Github上的<a href="https://github.com/LingyuCoder/learn-canvas" target="_blank" rel="noopener">learn-canvas</a>仓库里。在学习Canvas动画的过程中学到了不少宝贵的新知识，这篇主要是个人对于Canvas动画的一些想法以及与其他前端动画实现的一些对比。</p><a id="more"></a><h2 id="动画？"><a href="#动画？" class="headerlink" title="动画？"></a>动画？</h2><p>几年前，网页开发主要的侧重点还在于功能的实现。那时候的界面虽然不漂亮甚至很丑，但只要提供了用户切实需要的功能，也往往能够得到认可。但如今，随着互联网的快速发展，提供相同功能的互联网产品层出不穷，相互之间的竞争也日益增大。</p><p>互联网产品与传统的软件产品不同，以前用户通常是通过购买软件安装软体来获取服务，这种方式使得用户在竞品之间相互转换的代价很高，因此产品往往会有一批自己的用户，竞品相互之间会各有一片领地，然后通过销售、广告等等渠道缓慢的蚕食对手的地盘。</p><p>然而互联网产品的情境就完全不同了，用户只需要在浏览器中敲入一个网址，就可以轻松的获取服务。这方便了产品的推广和传播，同时也大大降低了用户对于产品的依赖程度，用户可以很方便的获取到其他同类产品的服务。因此服务提供商就需要想尽各种办法来留住用户。</p><p>当然留住用户的方法有很多，比如提供竞品没有的功能、仔细研究特殊用户群的痛点并提供针对性的解决方案等等，但其中的一个比较直接的方式就是“让我们的产品用起来比别人的用起来爽”，说白了也就是提升用户体验。浏览器的性能提升以及对CSS3和HTML5规范的支持，为用户带来了多种多样前所未有的互联网产品体验，动画就是其中一个。</p><p>动画给用户带来的体验提升是非常直接的，添加了动画后，信息的展现不再是冰冷冷的文字和图片，变得更加生动、直观，各种模仿现实的动画效果也使得页面元素的展现更加自然、亲切。在页面上实现动画比较常见的有三种方法：</p><ol><li>CSS动画</li><li>JavaScript动画</li><li>Canvas、WebGL动画</li></ol><p>这里就说说这三种动画</p><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>CSS3可以很方便的通过修改页面元素的样式来实现动画，主要是两种：<code>transition</code>和<code>animation</code>：</p><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><code>transition</code>为状态的转变提供了过渡动画，比如<code>transition: width 1s linear</code>，如果当前宽度为200，修改其宽度为400，那么就会发生一个时长为1s的动画，在这个动画过程中宽度逐渐增加转变为400。具体的转变方式由linear这种缓动函数来指定，linear就是线性的变化</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p><code>animation</code>则是通过定义<code>keyframes</code>关键帧来实现动画，一个典型的keyframes大致是这个样子的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myAnime &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">200px</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在通过在元素样式中定义<code>animation</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ele</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: myAnime <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方法就可以让元素动起来，具体每个参数有什么作用，可以去看看W3C或是MDN的介绍</p><h3 id="优势和缺陷"><a href="#优势和缺陷" class="headerlink" title="优势和缺陷"></a>优势和缺陷</h3><p>CSS动画有很多优点：</p><ol><li>写起来很简单，也比较直观，非常适合实现一些元素动效</li><li>在绝大部分时间CSS动画的性能都比较好（不触发重布局和重绘，还能使用上GPU加速）</li></ol><p>但缺陷也很多：</p><ol><li>动画过程控制能力较弱，逐帧控制不可行</li><li>部分浏览器不兼容，现在大部分都可以，尤其是移动端</li><li>若触发重布局和重绘，会大幅度降低性能</li><li>由于是CSS实现因此有不少局限性（页面滚动动画等）</li><li>基于页面元素，不可能实现像素级的渲染控制</li></ol><h2 id="JavaScript动画"><a href="#JavaScript动画" class="headerlink" title="JavaScript动画"></a>JavaScript动画</h2><p>JavaScript的动画本质上和CSS动画相似，同样是构建在页面元素的基础之上，比如jQuery的<code>$.fn.animate</code>就实现了JavaScript动画。</p><p>JavaScript动画本质上就是通过每隔一小段时间修改一次元素的CSS样式来实现动画。由于每一帧元素的样式都需要计算当前时间点所需要展现的样式属性值，因此只要修改计算的方式就能干预动画过程。这种逐帧绘制的方式有很多好处：由于每一帧都能进行干预，因此拥有极强的控制能力，可以单帧的控制、变换，写得好完全可以兼容IE6，并且像页面滚动这样的效果也可以实现。但由于计算过程需要自己实现，因此JavaScript动画往往较为复杂，所以性能上很容易出现问题，而且一般需要依赖外部动画库（不久之后就不需要了）。另外JavaScript动画和CSS动画同样是基于页面元素和CSS样式，因此有自己的局限性，像素级的控制无法实现。</p><p>JavaScript动画往往用于CSS动画无法完成动画的场景，比如兼容低级浏览器、实现一些细粒度动画等等</p><h2 id="Canvas、WebGL动画"><a href="#Canvas、WebGL动画" class="headerlink" title="Canvas、WebGL动画"></a>Canvas、WebGL动画</h2><p>Canvas和WebGL分别提供了2D和3D的画布进行绘制，这种绘制脱离元素和CSS，因此可以随心所欲定义绘制方案。这里就以Canvas为主，因为WebGL我不会哈哈。</p><p>Canvas本身提供了一系列的绘制方法，但同样需要JavaScript来控制，与JavaScript动画类似。Canvas本质上可以看做一叠白纸，并且提供了一些圆规直尺的工具，然后画一个动画的过程就是：画一帧，然后把换下一张白纸再画下一帧，和童年在书上画翻页动画原理一样。因此Canvas动画的好处有：</p><ol><li>拥有JavaScript动画的控制能力</li><li>完全脱离CSS和元素，绘制的方式和结果完全由自己控制，可以实现像素级别的控制</li><li>能够利用GPU加速，性能不错</li><li>可以进行画布控制，导入图像或导出图像</li><li>可以进行图像分析</li></ol><p>但是这些好处也是需要付出代价的：</p><ol><li>所有的绘制细节都要自己去控制，需要大量代码</li><li>不再基于CSS和DOM，因此在交互上很麻烦，只能在canvas上监听然后再计算位置投射到对应的元素上</li></ol><p>由于这种像素级别的控制能力，往往会使用Canvas做游戏和像音频可视化这样的复杂视觉效果</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今天先写到这里，下一篇写一写Canvas动画里的一些基础知识</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E4%BA%92%E5%8A%A8%E5%8A%A8%E7%94%BB/">互动动画</category>
      
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Canvas/">Canvas</category>
      
      <category domain="http://lingyu.life/tags/%E5%8A%A8%E7%94%BB/">动画</category>
      
      <category domain="http://lingyu.life/tags/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      
      <comments>http://lingyu.life/2015/04/18/old/learn-canvas-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RisingStack的Node.js风格指南</title>
      <link>https://lingyu.life/#/post/2014/11/24/old/risingstack-nodejs-style-guide</link>
      <guid>https://lingyu.life/#/post/2014/11/24/old/risingstack-nodejs-style-guide</guid>
      <pubDate>Sun, 23 Nov 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;本文翻译自&lt;a href=&quot;https://github.com/RisingStack/node-style-guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RisingStack/node-style-guide&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本文翻译自<a href="https://github.com/RisingStack/node-style-guide" target="_blank" rel="noopener">RisingStack/node-style-guide</a></p><a id="more"></a><h2 id="RisingStack-的Node-js-风格指南"><a href="#RisingStack-的Node-js-风格指南" class="headerlink" title="RisingStack 的Node.js 风格指南() {"></a><a href="http://risingstack.com" target="_blank" rel="noopener">RisingStack</a> 的Node.js 风格指南() {</h2><h3 id="文章的大部分内容来自-Airbnb-stlyeguide"><a href="#文章的大部分内容来自-Airbnb-stlyeguide" class="headerlink" title="文章的大部分内容来自 Airbnb stlyeguide"></a>文章的大部分内容来自 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb stlyeguide</a></h3><p>以下风格指南对此指南有很大影响:</p><ul><li>@caolan’s <a href="http://caolanmcmahon.com/posts/nodejs_style_and_structure" target="_blank" rel="noopener">Node.js stlyeguide</a></li><li>@felixge’s <a href="https://github.com/felixge/node-style-guide" target="_blank" rel="noopener">Node.js stlyeguide</a></li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li><p><strong>原生类型</strong>: 当访问一个原生类型时直接对其值进行操作</p><ul><li><code>string</code></li><li><code>number</code></li><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"></span><br><span class="line">bar = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo, bar); <span class="comment">// =&gt; 1, 9</span></span><br></pre></td></tr></table></figure></li><li><p><strong>复杂类型</strong>: 当访问一个复杂类型时，将对其值的引用上进行操作</p><ul><li><code>object</code></li><li><code>array</code></li><li><code>function</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"></span><br><span class="line">bar[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>], bar[<span class="number">0</span>]); <span class="comment">// =&gt; 9, 9</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>使用字面量创建对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> item = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用可读的同义单词来代替JavaScript的保留字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐，class是保留字</span></span><br><span class="line"><span class="keyword">var</span> superman = &#123;</span><br><span class="line">  class: 'alien'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐，klass不具备可读性</span></span><br><span class="line"><span class="keyword">var</span> superman = &#123;</span><br><span class="line">  klass: <span class="string">'alien'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> superman = &#123;</span><br><span class="line">  type: <span class="string">'alien'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>使用字面量创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> items = [];</span><br></pre></td></tr></table></figure></li><li><p>如果不知道数组的长度，使用Array#push方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someStack = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">someStack[someStack.length] = <span class="string">'abracadabra'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">someStack.push(<span class="string">'abracadabra'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用Array#slice来拷贝数组，这样性能较好，详见<a href="http://jsperf.com/converting-arguments-to-an-array/7" target="_blank" rel="noopener">jsPerf</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = items.length;</span><br><span class="line"><span class="keyword">var</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐，遍历性能较低</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure></li><li><p>将类数组对象转变为数组时，使用Array#slice方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><ul><li><p>对字符串使用单引号<code>&#39;&#39;</code>包裹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob Parr"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob Parr'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">"Bob "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">'Bob '</span> + <span class="keyword">this</span>.lastName;</span><br></pre></td></tr></table></figure></li><li><p>字符串长度超过80个字符时，应当将字符串写成多行并通过加号进行拼接</p></li><li><p>注意：如果过度使用长字符串拼接方式将影响性能，详见<a href="http://jsperf.com/ya-string-concat" target="_blank" rel="noopener">jsPerf</a> &amp; <a href="https://github.com/airbnb/javascript/issues/40" target="_blank" rel="noopener">Discussion</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because \</span></span><br><span class="line"><span class="string">of Batman. When you stop to think about how Batman had anything to do \</span></span><br><span class="line"><span class="string">with this, you would get nowhere \</span></span><br><span class="line"><span class="string">fast.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because '</span> +</span><br><span class="line">  <span class="string">'of Batman. When you stop to think about how Batman had anything to do '</span> +</span><br><span class="line">  <span class="string">'with this, you would get nowhere fast.'</span>;</span><br></pre></td></tr></table></figure></li><li><p>当以编码的方式构建一个字符串时，使用Array#join方法，而不要拼接字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items;</span><br><span class="line"><span class="keyword">var</span> messages;</span><br><span class="line"><span class="keyword">var</span> length;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line">messages = [&#123;</span><br><span class="line">  state: <span class="string">'success'</span>,</span><br><span class="line">  message: <span class="string">'This one worked.'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  state: <span class="string">'success'</span>,</span><br><span class="line">  message: <span class="string">'This one worked as well.'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  state: <span class="string">'error'</span>,</span><br><span class="line">  message: <span class="string">'This one did not work.'</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">length = messages.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inbox</span>(<span class="params">messages</span>) </span>&#123;</span><br><span class="line">  items = <span class="string">'&lt;ul&gt;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    items += <span class="string">'&lt;li&gt;'</span> + messages[i].message + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> items + <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inbox</span>(<span class="params">messages</span>) </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    items[i] = messages[i].message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;ul&gt;&lt;li&gt;'</span> + items.join(<span class="string">'&lt;/li&gt;&lt;li&gt;'</span>) + <span class="string">'&lt;/li&gt;&lt;/ul&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数表达式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数 (immediately-invoked function expression, IIFE)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>不要在非函数块（if、while等代码块）中声明函数，这种情况下应当将函数赋值给变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Nope.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  test = <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要声明<code>arguments</code>变量，这样将覆盖函数作用域的<code>arguments</code>对象（夺取了优先权，导致无法访问函数作用域的<code>arguments</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nope</span>(<span class="params">name, options, arguments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yup</span>(<span class="params">name, options, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li><p>使用符号<code>.</code>来访问属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luke = &#123;</span><br><span class="line">  jedi: <span class="literal">true</span>,</span><br><span class="line">  age: <span class="number">28</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> isJedi = luke[<span class="string">'jedi'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> isJedi = luke.jedi;</span><br></pre></td></tr></table></figure></li><li><p>在需要通过变量访问属性时使用中括号<code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luke = &#123;</span><br><span class="line">  jedi: <span class="literal">true</span>,</span><br><span class="line">  age: <span class="number">28</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> luke[prop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isJedi = getProp(<span class="string">'jedi'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>使用<code>var</code>来声明变量，这样能避免意外声明全局变量、污染全局命名空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">superPower = <span class="keyword">new</span> SuperPower();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> superPower = <span class="keyword">new</span> SuperPower();</span><br></pre></td></tr></table></figure></li><li><p>每个变量声明新启一行，并在每个声明前面加上<code>var</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"> <span class="keyword">var</span> items = getItems(),</span><br><span class="line">      goSportsTeam = <span class="literal">true</span>,</span><br><span class="line">      dragonball = <span class="string">'z'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"> <span class="keyword">var</span> items = getItems();</span><br><span class="line"> <span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">var</span> dragonball = <span class="string">'z'</span>;</span><br></pre></td></tr></table></figure></li><li><p>先声明需要赋值的变量，后声明不需要赋值的变量。这样后声明的变量能够依靠前面生成变量来生成自己的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> items = getItems(),</span><br><span class="line"><span class="keyword">var</span> dragonball,</span><br><span class="line"><span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,</span><br><span class="line"><span class="keyword">var</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> items = getItems(),</span><br><span class="line"><span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,</span><br><span class="line"><span class="keyword">var</span> dragonball,</span><br><span class="line"><span class="keyword">var</span> length,</span><br><span class="line"><span class="keyword">var</span> i;</span><br></pre></td></tr></table></figure></li><li><p>在作用域的顶部声明所有变量，这样有助于避免变量提升导致的相关问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  test();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..other stuff..</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  test();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..other stuff..</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h2><ul><li><p>按照如下顺序引用模块</p><ul><li>核心模块</li><li>npm上的工具模块</li><li>其他模块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br></pre></td></tr></table></figure></li><li><p>在模块引用时不要加上<code>.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul><li><p>总是在回调函数中检查是否出现错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">database.get(<span class="string">'pokemons'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, pokemons</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pokemons);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>回调函数也需要返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 如果不在这里返回</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这一样依旧会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常捕获（Try-catch）"><a href="#异常捕获（Try-catch）" class="headerlink" title="异常捕获（Try-catch）"></a>异常捕获（Try-catch）</h2><ul><li><p>只在同步函数中使用Try-catch</p><p>Try-catch代码块不能用来包裹异步的代码。Try-catch代码块将冒泡到最顶层，并记录整个冒泡的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>  callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在同步调用中使用Try-catch捕获异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonAsAString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">var</span> data;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  data = <span class="built_in">JSON</span>.parse(jsonAsAString);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误 —— 最好不只是用console.log输出</span></span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li><p>变量声明会提升到作用域顶端，但对这些变量的赋值是不会提升的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如我们所知，这不起作用 （没有同名的全局变量情况下）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(notDefined); <span class="comment">// =&gt; 抛出一个引用错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在引用一个变量之后创建一个变量声明一样能够正常工作</span></span><br><span class="line"><span class="comment">// 这是由于变量会提升。注意：这里赋值`true`并没有被提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></span><br><span class="line">  <span class="keyword">var</span> declaredButNotAssigned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器会将变量声明提升到作用域的顶部</span></span><br><span class="line"><span class="comment">// 这也就意味着上例可以写成如下方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> declaredButNotAssigned;</span><br><span class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></span><br><span class="line">  declaredButNotAssigned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名函数表达式只会提升变量定义，函数赋值语句不会提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(anonymous); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  anonymous(); <span class="comment">// =&gt; TypeError anonymous 不是函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'anonymous function expression'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名函数表达式同样提升变量定义，而不会提升函数名称和函数体</p></li><li><p>Named function expressions hoist the variable name, not the function name or the function body.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span></span><br><span class="line"></span><br><span class="line">  superPower(); <span class="comment">// =&gt; ReferenceError superPower 未定义</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就算函数名称和变量名称相同，也是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'named'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数声明会提升名称和函数体</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  superPower(); <span class="comment">// =&gt; Flying</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更多信息可以查看 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting" target="_blank" rel="noopener">JavaScript Scoping &amp; Hoisting</a> ，作者为 <a href="http://www.adequatelygood.com" target="_blank" rel="noopener">Ben Cherry</a></p></li></ul><h2 id="条件表达式和相等判断"><a href="#条件表达式和相等判断" class="headerlink" title="条件表达式和相等判断"></a>条件表达式和相等判断</h2><ul><li><p>使用 <code>===</code> 和 <code>!==</code> ，不要用 <code>==</code> 和 <code>!=</code></p></li><li><p>条件表达式计算时会强迫使用<code>ToBoolean</code>方法，并遵循如下规则：</p><ul><li><strong>Objects</strong> 判定为 <strong>true</strong></li><li><strong>Undefined</strong> 判定为 <strong>false</strong></li><li><strong>Null</strong> 判定为 <strong>false</strong></li><li><strong>Booleans</strong> 判定为 <strong>the value of the boolean</strong></li><li><strong>Numbers</strong> 如果为 <strong>+0, -0, or NaN</strong> 判定为 <strong>false</strong>，否则为 <strong>true</strong></li><li><strong>Strings</strong> 如果为 空字符串 <code>&#39;&#39;</code> 判定为 <strong>false</strong> 否则为 <strong>true</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 数组也是对象，对象都判定为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>善于简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (name !== <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (collection.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (collection.length) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更多信息请查看Angus Croll所著的 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" target="_blank" rel="noopener">Truth Equality and JavaScript</a> </p></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li><p>在所有多行代码块时都是用大括号</p></li><li><p>Use braces with all multi-line blocks.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (test)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (test) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p>使用<code>/**....*/</code>包裹多行注释，这种注释包括描述、参数及返回值的类型和值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="comment">// make() returns a new element</span></span><br><span class="line"><span class="comment">// based on the passed in tag name</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// @param &lt;String&gt; tag</span></span><br><span class="line"><span class="comment">// @return &lt;Element&gt; element</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed in tag name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>&lt;String&gt; tag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>&lt;Element&gt; element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单行注释时使用<code>//</code>。每一个单行注释在需要注释的位置上面新启一行。并在注释前加一个空行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> active = <span class="literal">true</span>;  <span class="comment">// is current tab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">var</span> active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</span><br><span class="line">  <span class="comment">// 设定默认值为'no type'</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设定默认值为'no type'</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在注释前增加<code>FIXME</code>或<code>TODO</code>来帮助其他开发者快速理解这里出现了一个问题或是需要提供实现。这种注释和常规的注释不同，它是可操作的。这些操作为<code>FIXME -- 需要弄清楚</code>或是<code>TODO -- 需要添加实现</code></p></li><li><p>使用 <code>// FIXME:</code> 来标注问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> 这里不应该有全局变量</span></span><br><span class="line">  total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>// TODO:</code> 来标注问题的解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> total应该通过参数来配置</span></span><br><span class="line">  <span class="keyword">this</span>.total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li><p>将TAB设置成两个空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙∙∙∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在大括号前加个空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>,&#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>, &#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在操作符旁边加上空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> x=y+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> x = y + <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>以一个换行符结束文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);↵</span><br><span class="line">↵</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);↵</span><br></pre></td></tr></table></figure></li><li></li><li><p>为长的链式方法调用增加缩进</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">$(<span class="string">'#items'</span>).find(<span class="string">'.selected'</span>).highlight().end().find(<span class="string">'.open'</span>).updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">$(<span class="string">'#items'</span>)</span><br><span class="line">  .find(<span class="string">'.selected'</span>)</span><br><span class="line">    .highlight()</span><br><span class="line">    .end()</span><br><span class="line">  .find(<span class="string">'.open'</span>)</span><br><span class="line">    .updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>).data(data).enter().append(<span class="string">'svg:svg'</span>).class(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>).append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>)</span><br><span class="line">    .data(data)</span><br><span class="line">  .enter().append(<span class="string">'svg:svg'</span>)</span><br><span class="line">    .class(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>)</span><br><span class="line">  .append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br></pre></td></tr></table></figure></li></ul><h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><ul><li><p>以逗号启始: <strong>不</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    firstName: <span class="string">'Bob'</span></span><br><span class="line">  , <span class="attr">lastName</span>: <span class="string">'Parr'</span></span><br><span class="line">  , <span class="attr">heroName</span>: <span class="string">'Mr. Incredible'</span></span><br><span class="line">  , <span class="attr">superPower</span>: <span class="string">'strength'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Bob'</span>,</span><br><span class="line">  lastName: <span class="string">'Parr'</span>,</span><br><span class="line">  heroName: <span class="string">'Mr. Incredible'</span>,</span><br><span class="line">  superPower: <span class="string">'strength'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在结尾加上逗号：<em>不</em>。这将在IE6/7和IE9的怪异模式中引发一些问题。而且，如果在数组中这么做，在一些ES3的实现中会增加数组的长度。这在ES5中做了修正(<a href="http://es5.github.io/#D" target="_blank" rel="noopener">source</a>)：</p><blockquote><p>Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Kevin'</span>,</span><br><span class="line">  lastName: <span class="string">'Flynn'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heroes = [</span><br><span class="line">  <span class="string">'Batman'</span>,</span><br><span class="line">  <span class="string">'Superman'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Kevin'</span>,</span><br><span class="line">  lastName: <span class="string">'Flynn'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heroes = [</span><br><span class="line">  <span class="string">'Batman'</span>,</span><br><span class="line">  <span class="string">'Superman'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure></li></ul><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><ul><li><p>永远使用分号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span></span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><h2 id="类型转换和强制类型转换"><a href="#类型转换和强制类型转换" class="headerlink" title="类型转换和强制类型转换"></a>类型转换和强制类型转换</h2><ul><li><p>在声明开头进行强制类型转换</p></li><li><p>字符串:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  =&gt; this.reviewScore = 9;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>parseInt</code> 转换成数字并总是加上进制数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputValue = <span class="string">'4'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="keyword">new</span> <span class="built_in">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = +inputValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果你出于某种原因做一些非常规的需求且<code>parseInt</code>是你性能的瓶颈，必须用位操作<a href="http://jsperf.com/coercion-vs-casting/3" target="_blank" rel="noopener">提升性能</a>时，添加注释来解释为什么这么做、到底做了什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parseInt是性能不佳的原因</span></span><br><span class="line"><span class="comment"> * 位操作强制将一个String转换为Number要快得多</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意:</strong> 使用位操作时需要注意。所有的数字都是<a href="http://es5.github.io/#x4.3.19" target="_blank" rel="noopener">64位浮点型</a>，但位操作经常返回32位整型（<a href="http://es5.github.io/#x11.7" target="_blank" rel="noopener">请看</a>）。位操作会在值大于32位时发生一些问题。<a href="https://github.com/airbnb/javascript/issues/109" target="_blank" rel="noopener">这里有一些关于此的讨论</a>。最大的有符号整型是 2,147,483,647</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2147483647</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; 2147483647</span></span><br><span class="line"><span class="number">2147483648</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483648</span></span><br><span class="line"><span class="number">2147483649</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483647</span></span><br></pre></td></tr></table></figure></li><li><p>布尔类型:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = <span class="keyword">new</span> <span class="built_in">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = <span class="built_in">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = !!age;</span><br></pre></td></tr></table></figure></li></ul><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ul><li><p>避免单字母的命名。命名应该能够自解释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">q</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ..stuff..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在命名对象、函数和实例的时候使用驼峰命名法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> OBJEcttsssss = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> this_is_my_object = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> user(&#123;</span><br><span class="line">  name: <span class="string">'Bob Parr'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> thisIsMyObject = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  name: <span class="string">'Bob Parr'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在命名构造函数和类时使用帕斯卡构造法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bad = <span class="keyword">new</span> user(&#123;</span><br><span class="line">  name: <span class="string">'nope'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> good = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  name: <span class="string">'yup'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>命名私有属性时添加<code>_</code>前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">this</span>.__firstName__ = <span class="string">'Panda'</span>;</span><br><span class="line"><span class="keyword">this</span>.firstName_ = <span class="string">'Panda'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">this</span>._firstName = <span class="string">'Panda'</span>;</span><br></pre></td></tr></table></figure></li><li><p>当需要保存一个<code>this</code>的引用时，使用<code>_this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(that);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总是为函数命名，这样有助于栈的追踪</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h2><ul><li><p>一般不需要属性的访问器函数</p></li><li><p>如果要创造属性的访问器函数，使用 getVal() 和 setVal(‘hello’)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dragon.age();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dragon.getAge();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dragon.age(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dragon.setAge(<span class="number">25</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果属性时布尔类型，使用 isVal() 或 hasVal()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (!dragon.age()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (!dragon.hasAge()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以创建 get() 和 set() 方法，但必须一致</p></li><li><p>It’s okay to create get() and set() functions, but be consistent.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  <span class="keyword">var</span> lightsaber = options.lightsaber || <span class="string">'blue'</span>;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'lightsaber'</span>, lightsaber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[key] = val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><p>给构造函数的prototype对象增加新方法，不要直接给prototype重写一个新的对象。重写prototype对象会导致无法继承：重写prototype将覆盖掉基类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new jedi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">Jedi.prototype = &#123;</span><br><span class="line">  fight: <span class="function"><span class="keyword">function</span> <span class="title">fight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fighting'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  block: <span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'blocking'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Jedi.prototype.fight = <span class="function"><span class="keyword">function</span> <span class="title">fight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fighting'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.block = <span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'blocking'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>可以为方法返回<code>this</code>方便链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();</span><br><span class="line">luke.jump(); <span class="comment">// =&gt; true</span></span><br><span class="line">luke.setHeight(<span class="number">20</span>) <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();</span><br><span class="line"></span><br><span class="line">luke.jump()</span><br><span class="line">  .setHeight(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可以重写toString()方法，只要它能正常工作且不会有副作用就行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  <span class="keyword">this</span>.name = options.name || <span class="string">'no name'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Jedi - '</span> + <span class="keyword">this</span>.getName();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>推荐的书籍</strong></p><ul><li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" target="_blank" rel="noopener">JavaScript语言精粹</a> - Douglas Crockford</li><li><a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752" target="_blank" rel="noopener">JavaScript模式</a> - Stoyan Stefanov</li><li><a href="http://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X" target="_blank" rel="noopener">JavaScript设计模式</a>  - Ross Harmes and Dustin Diaz</li><li><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309" target="_blank" rel="noopener">高性能网站建设指南</a> - Steve Souders</li><li><a href="http://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680" target="_blank" rel="noopener">编写可维护的JavaScript</a> - Nicholas C. Zakas</li><li><a href="http://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X" target="_blank" rel="noopener">JavaScript Web 富应用开发</a> - Alex MacCaw</li><li><a href="http://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273" target="_blank" rel="noopener">Pro JavaScript Techniques</a> - John Resig</li><li><a href="http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595" target="_blank" rel="noopener">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li><li><a href="http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X" target="_blank" rel="noopener">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li><li><a href="http://humanjavascript.com" target="_blank" rel="noopener">Human JavaScript</a> - Henrik Joreteg</li><li><a href="http://superherojs.com" target="_blank" rel="noopener">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li><li><a href="http://jsbooks.revolunet.com" target="_blank" rel="noopener">JSBooks</a></li><li><a href="http://manning.com/vinegar" target="_blank" rel="noopener">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li></ul><p><strong>推荐的博客</strong></p><ul><li><a href="http://dailyjs.com" target="_blank" rel="noopener">DailyJS</a></li><li><a href="http://javascriptweekly.com" target="_blank" rel="noopener">JavaScript Weekly</a></li><li><a href="http://javascriptweblog.wordpress.com" target="_blank" rel="noopener">JavaScript, JavaScript…</a></li><li><a href="http://weblog.bocoup.com" target="_blank" rel="noopener">Bocoup Weblog</a></li><li><a href="http://www.adequatelygood.com" target="_blank" rel="noopener">Adequately Good</a></li><li><a href="http://www.nczonline.net" target="_blank" rel="noopener">NCZOnline</a></li><li><a href="http://perfectionkills.com" target="_blank" rel="noopener">Perfection Kills</a></li><li><a href="http://benalman.com" target="_blank" rel="noopener">Ben Alman</a></li><li><a href="http://dmitry.baranovskiy.com" target="_blank" rel="noopener">Dmitry Baranovskiy</a></li><li><a href="http://dustindiaz.com" target="_blank" rel="noopener">Dustin Diaz</a></li><li><a href="http://net.tutsplus.com/?s=javascript" target="_blank" rel="noopener">nettuts</a></li></ul><h2 id="JavaScript风格指南"><a href="#JavaScript风格指南" class="headerlink" title="JavaScript风格指南"></a>JavaScript风格指南</h2><ul><li><a href="https://github.com/airbnb/javascript/wiki/The-JavaScript-Style-Guide-Guide" target="_blank" rel="noopener">查看</a></li></ul><h2 id="项目贡献者"><a href="#项目贡献者" class="headerlink" title="项目贡献者"></a>项目贡献者</h2><ul><li><a href="https://github.com/airbnb/javascript/graphs/contributors" target="_blank" rel="noopener">查看贡献者</a></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h1 id=""><a href="#" class="headerlink" title="};"></a>};</h1>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/">服务端技术</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      
      <comments>http://lingyu.life/2014/11/24/old/risingstack-nodejs-style-guide/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Peertc和五子棋</title>
      <link>https://lingyu.life/#/post/2014/11/18/old/peertc-and-fivechess</link>
      <guid>https://lingyu.life/#/post/2014/11/18/old/peertc-and-fivechess</guid>
      <pubDate>Mon, 17 Nov 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：&lt;a href=&quot;https://github.com/LingyuCoder/peertc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Peertc&lt;/a&gt;、&lt;a href=&quot;https://github.com/LingyuCoder/FiveChess&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五子棋&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：<a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="noopener">Peertc</a>、<a href="https://github.com/LingyuCoder/FiveChess" target="_blank" rel="noopener">五子棋</a></p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之前我曾经写过好几篇关于WebRTC和DataChannel相关的文章。WebRTC是我毕业设计中非常重要的一部分，因此对它做了不少研究。虽然WebRTC的RTC是real-time communication，但它带来的好处并不只局限在即时通信领域。建立点对点通信并在浏览器之间直接传递数据，光这一点就可以提出非常多有趣的设想。有两个应用的点子我一直想做：</p><ul><li>FC红白机那种双人对战（协作）游戏，配合Canvas和WebGL，这也就是这次五子棋想法的来源。</li><li>在线协作编辑：《黑客与画家》中曾经提到过，说在线协作这种工具很有市场。另外除了文档，我们还可以基于Canvas做协作绘图。</li></ul><p>五子棋就来源一第一个点子。至于第二个，做了一些调研，估计用<a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="noopener">OT.js</a>，只能等有时间的时候去弄了。</p><p>FC那么多牛逼的游戏，我却只是做了一个五子棋。原因很简单，Canvas玩的不够熟练也没有素材。五子棋游戏和其他游戏不同的是，它不需要做循环画面刷新，非常适合Canvas上手。</p><h2 id="Peertc"><a href="#Peertc" class="headerlink" title="Peertc"></a>Peertc</h2><p><a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="noopener">Peertc</a>是我在WebRTC DataChannel基础上实现的一个建立点对点通信，发送数据和文件的一个库。由于WebRTC在建立通信信道上还是无法脱离服务器，所以使用Node.js和<a href="https://www.npmjs.org/package/ws" target="_blank" rel="noopener">ws</a>在后台弄了个WebSocket服务器，同时WebSocket也是很好的退化方案。</p><p>至于Peertc具体如何建立点对点连接，我已经在文章<a href="/#/post/2014/10/21/datachannel">使用WebRTC DataChannel在浏览器间传递数据</a>中通过老姚和老刘的故事介绍过了</p><p>如果图简单的话，只要知道Peertc就是一个在俩浏览器之间传输数据的库就可以了</p><h2 id="五子棋"><a href="#五子棋" class="headerlink" title="五子棋"></a>五子棋</h2><p>我以前没写过五子棋，玩五子棋也玩的比较渣。乘着这个机会，仔细研究了一下五子棋的实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一个棋盘（多大随意，我玩过15*15的，但是也玩过可以无限扩展的）就是一个二维数组，黑白轮流往棋盘上放棋子，也就是往二维数组里赋值。每次放下棋子，判断一下在当前位置的横线、竖线、两条斜线上是否能成五个相连，也就是判断各个方向是否能成5个数字相同。</p><p>状态也只有4个：</p><ol><li>黑色落子</li><li>白色落子</li><li>黑色获胜</li><li>白色获胜</li></ol><p>状态转移：</p><ul><li>初始状态为黑色落子</li><li>黑色落子后judge判断是否获胜，若获胜转黑色获胜，否则转白色落子</li><li>白色落子后judge判断是否获胜，若获胜转白色获胜，否则转黑色落子</li></ul><p>所以，五子棋的核心就是一个judge方法来判断是否连成5子，实现很简单</p><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><p>为什么要写AI？本来只是想实现双人对战的，那就不要AI了，但是觉着如果只能双人对战未免太过无趣，所以就调研了一下五子棋的AI算法。发现它和计算网页内容的readablity一样，通过计算下在各个位置所获得的分值，得分最高的即是最优解。这里需要注意几个地方：</p><ol><li>这是一个对战游戏，自己要下子获胜，也要堵别人子防止别人获胜。因此计算权重时两种情况都要考虑</li><li>下过五子棋的都知道，如果成了一列（无论方向），两头都没有被堵子肯定要比被堵了一头要强，因此这个是否被堵也要加到考虑当中</li><li>连着的越多，越靠近胜利</li><li>放在棋盘较为中间的位置比较好（如果棋盘是固定大小的话）</li></ol><h2 id="双人对战"><a href="#双人对战" class="headerlink" title="双人对战"></a>双人对战</h2><p>既然涉及到双人互动的话，就会涉及到协议了。就算是一个简单的五子棋对战也有协议，这里直接用json好了。由于Peertc帮我们实现了链接和数据传输，A下的子的位置直接传给B就行了。</p><p>这里与AI不同的一个地方就是，AI反应快的一笔，不是玩家下子的时候，不做屏蔽也没太大关系。但是玩家需要思考，网络有延迟，所以在上面的黑色落子和白色落子阶段都需要加上对应的屏蔽，保证不会出现该白色落子，黑色依然能下的情况。</p><p>那么，需要哪些信令呢？</p><h3 id="开一局"><a href="#开一局" class="headerlink" title="开一局"></a>开一局</h3><p>开局，这个开局由一方先行发起，发起的一方将自己所持的颜色保存，并将对方应持的颜色和开局指令交给对方，至于颜色怎么来，可以随机或者固定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selfColor = <span class="string">'black'</span>;</span><br><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'new'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        color: <span class="string">'white'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="落子"><a href="#落子" class="headerlink" title="落子"></a>落子</h3><p>开局之后，双方都将开始游戏，各自会有自己的游戏数据和状态机。他们的状态应当完全同步。其实可以把对方想象成一个有延迟的AI。落子的关键就在于位置和颜色，位置一般不会有太大问题，而颜色如果错误麻烦就大了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'drop'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        color: fiveChess.state,</span><br><span class="line">        x: x,</span><br><span class="line">        y: y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里使用的是五子棋内部的状态表明的颜色，而不是使用当前持有的颜色，就是为了防止状态机不同步导致错误。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>双方在自己或对方落子后可以自行计算是否获胜游戏结束。真正需要传输的游戏结束的信令应当表征有一方认输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'end'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这三个信令，一个对战的五子棋就完成了</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>五子棋属于逻辑比较简单的游戏，因此实现起来很好理解，难度不大。写一个这种基于网络对战游戏，设计好自动机、设计好相互交互的信令是非常重要的。</p><p>希望以后Canvas学好了，能够写出像《魂斗罗》，《雪人兄弟》，《拳皇》这样的游戏。</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/">技术探索</category>
      
      
      <category domain="http://lingyu.life/tags/WebIM/">WebIM</category>
      
      <category domain="http://lingyu.life/tags/WebRTC/">WebRTC</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Canvas/">Canvas</category>
      
      <category domain="http://lingyu.life/tags/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      <category domain="http://lingyu.life/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://lingyu.life/2014/11/18/old/peertc-and-fivechess/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用WebRTC DataChannel在浏览器间传递数据</title>
      <link>https://lingyu.life/#/post/2014/10/21/old/datachannel</link>
      <guid>https://lingyu.life/#/post/2014/10/21/old/datachannel</guid>
      <pubDate>Mon, 20 Oct 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p><a id="more"></a><p>如果对WebRTC和DataChannel不太了解的同学，可以先阅读如下文章：</p><ul><li><a href="/#/post/2014/05/22/webrtc-data-channels">WebRTC的RTCDataChannel</a></li><li><a href="/#/post/2014/03/18/webRTC-2">使用WebRTC搭建前端视频聊天室——信令篇</a></li><li><a href="/#/post/2014/03/15/webRTC-1">使用WebRTC搭建前端视频聊天室——入门篇</a></li></ul><h2 id="老刘和老姚"><a href="#老刘和老姚" class="headerlink" title="老刘和老姚"></a>老刘和老姚</h2><p>当然服务器完全不参与其中，显然是不可能的，用户需要通过服务器上存储的信息，才能确定需要和谁建立连接。这里通过一个故事来讲述建立连接的过程：</p><h3 id="不如钓鱼去"><a href="#不如钓鱼去" class="headerlink" title="不如钓鱼去"></a>不如钓鱼去</h3><p>一些背景：</p><ul><li>老刘和老姚都住在同一个小区但不同的片区，小区很破旧，没有电话</li><li>片区相互隔离且片区门口有个保安，保安只认识自己片区的人，遇到不认识的人就需要查询凭证才能通过，而凭证需要找物业才能确定</li><li>门卫老大爷认识小区里的所有人但是不知道都住哪，有什么消息都可以在出入小区的时候代为传达</li></ul><p>现在，老刘听说老姚钓鱼技术高超，想和老姚讨论钓鱼技巧。只要老刘和老姚相互之间知道对方的门牌号以及凭证，就可以串门了:</p><ol><li>门卫老大爷认识老刘和老姚</li><li>老刘找物业确定了自己片区的出入凭证，将凭证、自己的门牌号以及意图告诉门卫老大爷，让其转交给老姚</li><li>老姚买菜归来遇到门卫老大爷，门卫老大爷将老刘的消息传达给老姚。于是老姚知道怎么去老刘家了</li><li>老姚很开心，他也找物业获取了自己小区的凭证，并将凭证、自己的门牌号等信息交给门卫老大爷，希望他传达给老刘</li><li>老刘吃早餐回来遇到门卫老大爷，老大爷把老姚的小区凭证、门牌号等信息告诉老刘，这样老刘就知道了怎么去老姚家了</li></ol><p>老刘和老姚相互之间知道了对方的门牌号和小区出入凭证，他们相互之间有什么需要交流的直接串门就行了，消息不再需要门卫老大爷来代为传达了</p><h3 id="换个角度"><a href="#换个角度" class="headerlink" title="换个角度"></a>换个角度</h3><p>我们把角色做一个映射：</p><ul><li>老刘：浏览器1</li><li>老姚：浏览器2</li><li>片区：不同网段</li><li>保安：防火墙</li><li>片区凭证：ICE candidate</li><li>物业：ICE server</li><li>门牌号：session description</li><li>门卫老大爷：server</li></ul><p>于是乎故事就变成了这样：</p><ol><li>浏览器1和浏览器2在server上注册，并保有连接</li><li>浏览器1从ice server获取ice candidate并发送给server，并生成包含session description的offer，发送给server</li><li>server发送浏览器1的offer和ice candidate给浏览器2</li><li>浏览器2发送包含session description的answer和ice candidate给server</li><li>server发送浏览器2的answer和ice candidate给浏览器1</li></ol><h2 id="礼物"><a href="#礼物" class="headerlink" title="礼物"></a>礼物</h2><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><p>老刘和老姚已经可以相互串门了，经过一段时间的交流感情越来越深。老姚的亲友送了20斤葡萄给老姚，老姚决定送10斤给老刘。老姚毕竟年事已高，不可能一次带10斤。于是乎，老姚将葡萄分成了10份，每次去老刘家串门就送一份过去。</p><p>这里可以做如下类比：</p><ol><li>10斤葡萄：一个文件（尽管文件分片没有意义，葡萄分开还可以单独吃，但是实在找不到啥好的比喻了）</li><li>分成10份：将文件分片，转成多个chunk</li><li>老姚一次只能带一斤：datachannel每次传输的数据量不宜太大（<a href="http://stackoverflow.com/questions/15435121/what-is-the-maximum-size-of-webrtc-data-channel-messages" target="_blank" rel="noopener">找到最合适的大小</a>）</li></ol><p>这其实就是通过datachannel传输文件的方式，首先将文件分片，然后逐个发送，最后再统一的进行组合成一个新的文件</p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>通过HTML5的File API可以将type为file的input选中的文件读取出来，并转换成data url字符串。这也就为我们提供了很方便的分片方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="built_in">window</span>.FileReader(file);</span><br><span class="line">reader.readAsDataURL(file);</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">event, text</span>) </span>&#123;</span><br><span class="line">    chunkify(event.target.result);<span class="comment">//将数据分片</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>通过datachannel发送的分片数据，我们需要将其进行组合，由于是data url字符串，在接收到所有包之后进行拼接就可以了。拼接完成后就得到了一个文件完整的data url字符串，那么我们如何将这个字符串转换成文件呢？</p><h4 id="方案一：直接跳转下载"><a href="#方案一：直接跳转下载" class="headerlink" title="方案一：直接跳转下载"></a>方案一：直接跳转下载</h4><p>既然是个dataurl，我们直接将其赋值给<code>window.location.href</code>自然可以下载，但是这样下载是没法设定下载后的文件名的，这想一想都蛋疼</p><h4 id="方案二：通过a标签下载"><a href="#方案二：通过a标签下载" class="headerlink" title="方案二：通过a标签下载"></a>方案二：通过a标签下载</h4><p>这个原理和跳转下载类似，都是使用dataurl本身的特性，通过创建一个a标签，将dataurl字符串赋值给href属性，然后使用download确定下载后的文件名，就可以完成下载了。但是很快又有新问题了，稍微大一点的文件下载的时候页面崩溃了。这是因为dataurl有<a href="http://stackoverflow.com/questions/695151/data-protocol-url-size-limitations" target="_blank" rel="noopener">大小限制</a></p><h4 id="方案三：blob"><a href="#方案三：blob" class="headerlink" title="方案三：blob"></a>方案三：blob</h4><p>其实可以通过给a标签创建blob url的方式来进行下载，这个没有大小限制。但是我们手上是dataurl，所以需要先进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span>(<span class="params">dataURI, dataTYPE</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> binary = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]),</span><br><span class="line">        array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; binary.length; i++) array.push(binary.charCodeAt(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(array)], &#123;</span><br><span class="line">        type: dataTYPE</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得blob后，我们就可以通过URL API来下载了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">a.style = <span class="string">"display: none"</span>;</span><br><span class="line"><span class="keyword">var</span> blob = dataURItoBlob(data, <span class="string">'octet/stream'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">a.href = url;</span><br><span class="line">a.download = filename;</span><br><span class="line">a.click();</span><br><span class="line">!moz &amp;&amp; <span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br><span class="line">a.parentNode.removeChild(a);</span><br></pre></td></tr></table></figure><p>这里有几个点：</p><ol><li>datachannel其实是可以直接传送blob的，但是只有ff支持，所以传data url</li><li>chrome下载是直接触发的，不会进行询问，firefox会先询问后下载，在询问过程中如果执行了<code>revokeObjectURL</code>，下载就会取消，囧</li></ol><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>如我们所知，WebRTC最有特点的地方其实是可以传输getUserMedia获得的视频、音频流，来实现视频聊天。但事实上我们的使用习惯来看，一般人不会一开始就打开视频聊天，而且视频聊天时很消耗内存的（32位机上一个连接至少20M左右好像，也有可能有出入）。所以常见的需求是，先建立一个包含datachannel的连接用于传输数据，然后在需要时升级成可以传输视频、音频。</p><p>看看我们之前传输的session description，它其实来自<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1" target="_blank" rel="noopener">Session Description Protocol</a>。可以看到wiki上的介绍：</p><blockquote><p>The Session Description Protocol (SDP) is a format for describing streaming media initialization parameters.</p></blockquote><p>这意味着什么呢？我们之前建立datachannel是没有加视频、音频流的，而这个流的描述是写在SDP里面的。现在我们需要传输视频、音频，就需要添加这些描述。所以就得重新获得SDP，然后构建offer和answer再传输一次。传输的流程和之前一样，没什么区别。但这一次，我们不需要传输任何的ice candidate，这里我曾经<a href="http://stackoverflow.com/questions/26469794/webrtc-add-ice-candidate-error-on-established-peerconnection" target="_blank" rel="noopener">遇到了坑</a>，经过国外大大的点拨才明白过来。</p><blockquote><p>from mattm: You do not need to send ICE candidates on an already established peer connection. The ICE candidates are to make sure the two peers can establish a connection through their potential NAT and firewalls. If you can already send data on the peer connection, ICE candidates will not do anything.</p></blockquote><h2 id="Peertc"><a href="#Peertc" class="headerlink" title="Peertc"></a>Peertc</h2><p>我将datachannel和websocket组合，实现了一个构建点对点连接的库Peertc，它提供非常简洁的方式来建立连接和发送数据、文件和视频/音频流，详情见<a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="noopener">github</a>。走过路过的记得star一下哦，有什么bug也非常希望能够提出来。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>WebRTC的点对点方式能够运用在很多场景：</p><ul><li>如web qq这种Web IM工具，这就不说了</li><li>如象棋这种双人对战游戏，每一步的数据服务器时不关心的，所以完全可以点对点发送</li><li>一对一在线面试、在线教育，这其实是即时通信的一个业务方向</li><li>视频裸（），当我没说</li></ul>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/">技术探索</category>
      
      
      <category domain="http://lingyu.life/tags/WebSocket/">WebSocket</category>
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/WebIM/">WebIM</category>
      
      <category domain="http://lingyu.life/tags/WebRTC/">WebRTC</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/DataChannel/">DataChannel</category>
      
      
      <comments>http://lingyu.life/2014/10/21/old/datachannel/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Gulp思维 —— Gulp高级技巧</title>
      <link>https://lingyu.life/#/post/2014/10/07/old/getting-gulpy</link>
      <guid>https://lingyu.life/#/post/2014/10/07/old/getting-gulpy</guid>
      <pubDate>Mon, 06 Oct 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;本文翻译自&lt;a href=&quot;https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Getting gulpy – Advanced tips for using gulp.js&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感受过&lt;a href=&quot;http://gulpjs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gulp.js&lt;/a&gt;带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5" target="_blank" rel="noopener">Getting gulpy – Advanced tips for using gulp.js</a></strong></p><p>感受过<a href="http://gulpjs.com" target="_blank" rel="noopener">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p><a id="more"></a><h2 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务"></a>基本任务</h2><p>gulp的基本设置拥有非常友好的语法，让你能够非常方便的对文件进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./src/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(concat(<span class="string">'all.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方式能够应付绝大多数情况，但如果你需要更多的定制，很快就会遇到麻烦了。这篇将介绍这其中的一些情况并提供解决方案。</p><h2 id="流不兼容？"><a href="#流不兼容？" class="headerlink" title="流不兼容？"></a>流不兼容？</h2><p>使用gulp时，你可能会陷入“流不兼容”的问题。这主要是因为常规流和Vinyl文件对象有差异，或是使用了仅支持buffer（不支持流）库的gulp插件与常规流不兼容。</p><p>比如说，你不能直接将常规流与gulp和（或）gulp插件相连。我们创建一个可读流，并尝试使用<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-rename" target="_blank" rel="noopener">gulp-rename</a>来进行转换，将最后得到的内容交给<code>gulp.dest()</code>。下面就是个错误的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line">gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.createReadStream(<span class="string">'app.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(rename(<span class="string">'bundle.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么我们不能将可读流和一个gulp插件直接相连？gulp难道不就是一个基于流的构建系统吗？是的，但上面的例子忽视了一个事实，gulp插件期望的输入是Vinyl文件对象。你不能直接将一个可读流与一个以Vinyl文件对象作为输入的函数（插件）相连</p><h2 id="Vinyl文件对象"><a href="#Vinyl文件对象" class="headerlink" title="Vinyl文件对象"></a>Vinyl文件对象</h2><p>gulp使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank" rel="noopener">vinyl-fs</a>，它实现了<code>gulp.src()</code>和<code>gulp.dest()</code>方法。vinyl-fs使用<a href="https://github.com/wearefractal/vinyl" target="_blank" rel="noopener">vinyl</a>文件对象——一种“虚拟文件格式”。如果我们需要将gulp和（或）gulp插件与常规的可读流一起使用，我们就需要先把可读流转换为vinyl。</p><p>使用<a href="https://www.npmjs.org/package/vinyl-source-stream" target="_blank" rel="noopener">vinyl-source-stream</a>是个不错的选择，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),</span><br><span class="line">    marked = <span class="built_in">require</span>(<span class="string">'gulp-marked'</span>);</span><br><span class="line">fs.createReadStream(<span class="string">'*.md'</span>)</span><br><span class="line">    .pipe(source())</span><br><span class="line">    .pipe(marked())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure><p>另外一个例子首先通过<a href="http://browserify.org" target="_blank" rel="noopener">browserify</a>封装并最终将其转换为一个vinyl流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);</span><br><span class="line">gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> browserify(<span class="string">'./src/app.js'</span>)</span><br><span class="line">        .bundle()</span><br><span class="line">        .pipe(source(‘bundle.min.js))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>哎呦不错哦。注意我们不再需要使用gulp-rename了，因为vinyl-source-stream创建了一个拥有指定文件名的vinyl文件实例（这样gulp.dest方法将使用这个文件名）</p><h3 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest"></a>gulp.dest</h3><p>这个gulp方法创建了一个可写流，它真的很方便。它重新使用可读流中的文件名，然后在必要时创建文件夹（使用<a href="https://www.npmjs.org/package/mkdirp" target="_blank" rel="noopener">mkdirp</a>）。在写入操作完成后，你能够继续使用这个流（比如：你需要使用gzip压缩数据并写入到其他文件）</p><h2 id="流和buffer"><a href="#流和buffer" class="headerlink" title="流和buffer"></a>流和buffer</h2><p>既然你有兴趣使用gulp，这篇文章假设你已经了解了流的基础知识。无论是buffer还是流，vinyl的虚拟文件都能包含在内。使用常规可读流时，你可以监听data事件来检测数据碎片的到来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; ...</span><br></pre></td></tr></table></figure><p>不同的是，使用<code>gulp.src()</code>会将转换成buffer的vinyl文件对象重新写入到流中。也就是说，你获得的不再是数据碎片，而是将内容转换成buffer后的（虚拟）文件。vinyl文件格式拥有一个属性来表示里面是buffer还是流，gulp默认使用buffer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, file.contents.length);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">2493109</span> bytes <span class="keyword">of</span> data</span><br></pre></td></tr></table></figure><p>这个例子说明了在文件被完整加入到流之前数据会被转换成buffer。</p><h2 id="Gulp默认使用buffer"><a href="#Gulp默认使用buffer" class="headerlink" title="Gulp默认使用buffer"></a>Gulp默认使用buffer</h2><p>尽管更加推荐使用流中的数据，但很多插件的底层库使用的是buffer。有时候必须使用buffer，因为转换需要完整的文件内容。比如文本替换和正则表达式的情形。如果使用数据碎片，将会面临匹配失败的风险。同样，像<a href="http://lisperator.net/uglifyjs" target="_blank" rel="noopener">UglifyJS</a>和<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur Compiler</a>需要输入完整的文件内容（至少需要语法完整的JavaScript字符串）</p><p>这就是为什么gulp默认使用转换成buffer的流，因为这更好处理。</p><p>使用转换成buffer的流也有缺点，处理大文件时将非常低效。文件必须完全读取，然后才能被加入到流中。那么问题来了，文件的尺寸多大才会降低性能？对于普通的文本文件，比如JavaScript、CSS、模板等等，这些使用buffer开销非常小。</p><p>在任何情况下，如果将buffer选项设为false，你可以告诉gulp流中传递的内容究竟是什么。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'/usr/share/dict/words'</span>, &#123;<span class="attr">buffer</span>: <span class="literal">false</span>&#125;).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stream = file.contents;</span><br><span class="line">    stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; ...</span><br></pre></td></tr></table></figure><h2 id="从流到buffer"><a href="#从流到buffer" class="headerlink" title="从流到buffer"></a>从流到buffer</h2><p>由于所需的输入（输出）流和gulp插件不尽相同，你可能需要将流转换成buffer（反之亦然）。之前已经有过介绍，大多数插件使用buffer（尽管他们的一部分也支持流）。比如<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-traceur" target="_blank" rel="noopener">gulp-traceur</a>。你可以通过<a href="https://www.npmjs.org/package/gulp-buffer" target="_blank" rel="noopener">gulp-buffer</a>来转换成buffer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),</span><br><span class="line">    buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">fs.createReadStream(<span class="string">'./src/app.js'</span>)</span><br><span class="line">    .pipe(source(<span class="string">'app.min.js'</span>))</span><br><span class="line">    .pipe(buffer())</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure><p>或者另一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),</span><br><span class="line">    traceur = <span class="built_in">require</span>(<span class="string">'gulp-traceur'</span>);</span><br><span class="line">gulp.src(<span class="string">'app.js'</span>, &#123;<span class="attr">buffer</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">    .pipe(buffer())</span><br><span class="line">    .pipe(traceur())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure><h2 id="将buffer转换为流"><a href="#将buffer转换为流" class="headerlink" title="将buffer转换为流"></a>将buffer转换为流</h2><p>你也可以使用<a href="https://www.npmjs.org/package/gulp-streamify" target="_blank" rel="noopener">gulp-streamify</a>或<a href="https://www.npmjs.org/package/gulp-stream" target="_blank" rel="noopener">gulp-stream</a>将一个使用buffer的插件的输出转化为一个可读流。这样处理之后，跟在使用buffer的插件后面的（只能）使用流的插件也能正常工作了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wrap = <span class="built_in">require</span>(<span class="string">'gulp-wrap'</span>),</span><br><span class="line">    streamify = <span class="built_in">require</span>(<span class="string">'gulp-streamify'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    gzip = <span class="built_in">require</span>(<span class="string">'gulp-gzip'</span>);</span><br><span class="line">gulp.src(<span class="string">'app.js'</span>, &#123;<span class="attr">buffer</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">    .pipe(wrap(<span class="string">'(function()&#123;&lt;%= contents %&gt;&#125;());'</span>))</span><br><span class="line">    .pipe(streamify(uglify()))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>))</span><br><span class="line">    .pipe(gzip())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br></pre></td></tr></table></figure><h2 id="不是所有事都需要插件"><a href="#不是所有事都需要插件" class="headerlink" title="不是所有事都需要插件"></a>不是所有事都需要插件</h2><p>虽然已经有很多使用且方便的插件，很多任务以及转换可以不使用插件而轻易完成。插件会带来一些问题，你需要依赖一个额外的npm模块，一个插件接口和（反应迟钝？）的维护者，等等。如果一个任务可以不使用插件而使用原生模块就能轻易完成，绝大多数情况下，都建议不要使用插件。能够理解上面所说的概念，并能够在所处的情况下做出正确的决定，这点非常重要。下面来看一些例子：</p><h3 id="vinyl-source-stream"><a href="#vinyl-source-stream" class="headerlink" title="vinyl-source-stream"></a>vinyl-source-stream</h3><p>之前的例子中，我们已经直接使用了browserify，而不是使用（现已加入黑名单）<a href="https://www.npmjs.org/package/gulp-browserify" target="_blank" rel="noopener">gulp-browserify</a>插件。这里的关键是使用vinyl-source-stream（或类似的库）进行加工，来将常规的可读流输入使用vinyl的插件。</p><h3 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h3><p>另一个例子就是基于字符串的变换。这里有一个非常基础的插件，直接使用了vinyl的buffer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">modifier</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> through2.obj(<span class="function"><span class="keyword">function</span>(<span class="params">file, encoding, done</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = modifier(<span class="built_in">String</span>(file.contents));</span><br><span class="line">        file.contents = <span class="keyword">new</span> Buffer(content);</span><br><span class="line">        <span class="keyword">this</span>.push(file);</span><br><span class="line">        done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像这样使用这个插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'modify'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'app.js'</span>)</span><br><span class="line">        .pipe(modify(version))</span><br><span class="line">        .pipe(modify(swapStuff))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">version</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.replace(<span class="regexp">/__VERSION__/</span>, pkg.version);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapStuff</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2, $1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个插件并没有完成，而且也不能处理流（<a href="https://gist.github.com/webpro/a9a9e14d291c021894b3" target="_blank" rel="noopener">完整版本</a>）。然而，这个例子说明，可以很轻易地通过一些基本函数来创建新的变换。<a href="https://www.npmjs.org/package/through2" target="_blank" rel="noopener">through2</a>库提供了非常优秀的Node流封装，并且允许像上面那样使用转换函数。</p><h2 id="任务流程"><a href="#任务流程" class="headerlink" title="任务流程"></a>任务流程</h2><p>如果你需要去运行一些定制化或动态的任务，了解gulp所使用的<a href="https://www.npmjs.org/package/orchestrator" target="_blank" rel="noopener">Orchestrator</a>模块会很有帮助。<code>gulp.add</code>方法其实就是<code>Orchestrator.add</code>方法（事实上所有的方法都是从Orchestrator继承而来的）。但为什么你需要这个？</p><ul><li>你不想“私有任务”（比如：不暴露给命令行工具）弄乱gulp任务列表。</li><li>你需要更多的动态的和（或）可重用的子任务。</li></ul><h2 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h2><p>请注意，gulp（或grunt）并不总是当前情境下的最佳工具。比如说，如果你需要拼接并使用uglify压缩一系列的JavaScript文件，又或者你需要编译一些SASS文件，你可能需要考虑使用makefile或npm run，通过命令行来实现。减少依赖，减少配置，才是正解。</p><p>阅读<a href="http://substack.net/task_automation_with_npm_run" target="_blank" rel="noopener">通过npm run来实现任务自动化</a>来了解更多信息。你需要明确通过一系列的“自定义构建”后需要得到什么，而哪个工具最合适。</p><p>不过，我觉得gulp是一个伟大的构建系统，我很喜欢使用它，它展现了Node.js中流的强大。</p><p>希望这些能够帮到你！如果你有任何反馈或其他提议，请在评论中告诉我，或者加我的twitter：<a href="https://twitter.com/webprolific" target="_blank" rel="noopener">@webprolific</a></p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Gulp/">Gulp</category>
      
      
      <comments>http://lingyu.life/2014/10/07/old/getting-gulpy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Gulp -- 项目的愿景、过去和将来</title>
      <link>https://lingyu.life/#/post/2014/10/06/old/gulp-vision-history-future</link>
      <guid>https://lingyu.life/#/post/2014/10/06/old/gulp-vision-history-future</guid>
      <pubDate>Sun, 05 Oct 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;本文翻译自&lt;a href=&quot;https://medium.com/@contrahacks/gulp-3828e8126466&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gulp – The vision, history, and future of the project&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466" target="_blank" rel="noopener">gulp – The vision, history, and future of the project</a></strong></p><p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p><a id="more"></a><p>下面我们就来介绍gulp背后的各个部分以及它们所起到的作用。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是一种将多个小的变换操作进行组合，连接成管道的一种方式。你将数据丢入管道顶部，它将下落并穿过所有的变换，最后在底部得到你想要的内容。流系统的灵活性能够很好地解决文件变换需求。</p><p>想获得更多关于流的信息，请查阅substack的<a href="https://github.com/substack/stream-handbook" target="_blank" rel="noopener">流操作手册</a></p><h2 id="Vinyl"><a href="#Vinyl" class="headerlink" title="Vinyl"></a>Vinyl</h2><p><a href="https://github.com/wearefractal/vinyl" target="_blank" rel="noopener">Vinyl</a>是一个用来描述文件的简单元数据对象。当你想要使用一个文件时，首先映入脑海的是文件的两个属性：<a href="https://github.com/wearefractal/vinyl/blob/master/index.js#L18-L25" target="_blank" rel="noopener">路径和内容</a>。这两个属性就是一个Vinyl对象的主要属性。这里的文件并不一定是指你的文件系统里的文件。你在S3、FTP、Dropbox、Box、CloudThingly.io或者其他服务上的文件，一样可以使用Vinyl来描述。</p><h2 id="Vinyl-Adapters（Vinyl适配器）"><a href="#Vinyl-Adapters（Vinyl适配器）" class="headerlink" title="Vinyl Adapters（Vinyl适配器）"></a>Vinyl Adapters（Vinyl适配器）</h2><p>既然Vinyl提供了一个清晰的方法用来描述文件，我们现在还需要找到访问这些文件的方式。每一种文件源我们都需要一个“Vinyl适配器”。一个Vinyl适配器只需要暴露三个方法：<code>.src(globs)</code>、<code>.dest(folder)</code>、和一个<code>.watch(globs, fn)</code>。src流负责产生文件对象，而dest流负责消费这些文件对象。</p><p>表面上看人们已经理解了“gulp插件”(一个transform形式的流)的概念，但Vinyl适配器的理念却没有被广泛传播。除非自己开发一些适配器，否则无法得知适配器是如何引用文件源中的内容。。通过Vinyl适配器来实现gulp，并将其作为一个开发工具的想法非常奇妙。</p><h3 id="vinyl-fs"><a href="#vinyl-fs" class="headerlink" title="vinyl-fs"></a>vinyl-fs</h3><p>如果你使用gulp，你已经使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank" rel="noopener">vinyl-fs</a>模块。它是用来适配本地文件系统的适配器。</p><h3 id="vinyl-s3"><a href="#vinyl-s3" class="headerlink" title="vinyl-s3"></a>vinyl-s3</h3><p>vinyl-s3尚不存在，但<a href="https://github.com/nkostelnik/gulp-s3" target="_blank" rel="noopener">gulp-s3</a>已经实现了。它无法提供所有的功能，但它是了一个不错的权宜方案。</p><h2 id="Orchestrator"><a href="#Orchestrator" class="headerlink" title="Orchestrator"></a>Orchestrator</h2><p>在写这篇文章时，目前的任务系统是<a href="https://github.com/orchestrator/orchestrator" target="_blank" rel="noopener">Orchestrator</a> 0.3。Orchestrator提供了简单的方式去定义任务和依赖，并能够在依赖树为基础的前提下以最大并发数去与并发执行这些任务。Orchestrator虽然工作良好，但它复杂的依赖管理给用户带来不小的麻烦。Orchestrator为了配合gulp的理念而做了巨大的调整：更加轻量、低复杂度，以及可组合的功能性API。</p><p>这里简要介绍一下gulp 4带来的变化：</p><ol><li>你可以任意指定任务顺序，并行/串行的任意组合都随心所欲。只有想不到，没有做不到</li><li>API将非常流畅和友好</li><li>代码更加简洁</li></ol><p>非常感谢Blaine Bublitz在这方面积极的努力。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>实话告诉你：gulp现在的错误处理很烂。我从不期望能从报错信息中获得一点有用的信息。使用gulp的过程中，你可能会遭遇两种错误：</p><h3 id="任务失败"><a href="#任务失败" class="headerlink" title="任务失败"></a>任务失败</h3><p>watch时出现任务失败，内部将会一团糟，然后线程会退出，具体的退出方式要取决你如何启动这个任务。这种情况非常糟糕，完全不应该发生，在新的任务系统中将对这些进行修复。</p><h3 id="管道失败"><a href="#管道失败" class="headerlink" title="管道失败"></a>管道失败</h3><p>标准的流在遭遇错误时仅仅会停止工作。而像linter（代码风格检测）这样的任务，问题就来了。我想看到所有的代码风格提示，而不只是第一个文件里的那些。技术上其实是因为unpipe事件。本质上看，当一个流遇到错误，它将会触发<strong>unpipe</strong>事件，这个事件将告诉其他流不再向它写入数据。目前有一些hack的解决方法如gulp-plumber，可以作为权宜之计，但我很高兴的说，我将会把这些集成到gulp核心之中去。</p><p>这些问题我会在下个release版本最优先解决。</p><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><p>从一个局外人的角度来看，人们都能参与到这场文件转换工具的战斗之中，实在有些疯狂。虽然外人看来可能有些无趣，但成为这个激情小组的一部分绝对令人振奋。我很自豪社区能够接纳这个工具并对人们的日常生活带来帮助。</p><h2 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h2><p>想要跟踪gulp 4的进展，你可以在github上查看<a href="https://github.com/gulpjs/gulp/issues?milestone=1&state=open" target="_blank" rel="noopener">里程碑</a></p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/Gulp/">Gulp</category>
      
      
      <comments>http://lingyu.life/2014/10/06/old/gulp-vision-history-future/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>koa-anywhere</title>
      <link>https://lingyu.life/#/post/2014/09/24/old/koa-anywhere</link>
      <guid>https://lingyu.life/#/post/2014/09/24/old/koa-anywhere</guid>
      <pubDate>Tue, 23 Sep 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近写了一个快速启动静态文件服务器的NodeJs包&lt;a href=&quot;https://github.com/LingyuCoder/koa-anywhere&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;koa-anywhere&lt;/a&gt;，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere" target="_blank" rel="noopener">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p><a id="more"></a><h1 id="koa-anywhere"><a href="#koa-anywhere" class="headerlink" title="koa-anywhere"></a>koa-anywhere</h1><p>通过一条命令，将当前目录变成一个静态文件服务器</p><p>需要Node版本：&gt;= 0.11.13</p><h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g koa-anywhere</span><br></pre></td></tr></table></figure><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>只需一条简单的命令<code>ka</code>就可以启动一个静态文件服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;想要共享的目录&gt;</span><br><span class="line">$ ka</span><br></pre></td></tr></table></figure><h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>通过<code>-p &lt;端口号&gt;</code>或者<code>--port &lt;端口号&gt;</code>来指定静态文件服务器的端口</p><p>默认端口为<code>3000</code></p><h3 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h3><p>通过<code>-d &lt;层级数&gt;</code>或者<code>--deep &lt;层级数&gt;</code>来确定静态文件需要显示的文件层级，超过层级的文件不显示</p><p>默认层级数为<code>3</code></p><h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h3><p>通过<code>-s</code>或者<code>--silent</code>来决定是否显示日志</p><p>默认为<code>false</code>，也就是显示日志</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/ES6/">ES6</category>
      
      <category domain="http://lingyu.life/tags/koa/">koa</category>
      
      
      <comments>http://lingyu.life/2014/09/24/old/koa-anywhere/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>学前端的一点总结</title>
      <link>https://lingyu.life/#/post/2014/09/22/old/learn-fe</link>
      <guid>https://lingyu.life/#/post/2014/09/22/old/learn-fe</guid>
      <pubDate>Sun, 21 Sep 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近&lt;a href=&quot;https://github.com/qiu-deqing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qiu&lt;/a&gt;开了一个&lt;a href=&quot;https://github.com/qiu-deqing/FE-learning/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FE学习经验介绍&lt;/a&gt;，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近<a href="https://github.com/qiu-deqing" target="_blank" rel="noopener">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md" target="_blank" rel="noopener">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p><a id="more"></a><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li>chrome dev tools：前端开发调试利器，着重注意几个功能：<ul><li>console（废话）</li><li>elements:元素样式调整，很常用</li><li>sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象<ul><li>watch expression：通过表达式查看当前内存中的值</li><li>call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候）</li><li>scope variables：作用域链上的变量，非常有用</li></ul></li><li>network：抓包查看每个请求，非常重要，前后端联调必备</li><li>timeline：分析渲染、js执行等等各个阶段，性能优化利器</li><li>emulation：模拟移动端环境，mobile页面开发必备</li><li>一些插件:<ul><li>liveload: 修改页面后自动刷新，不用按F5</li><li>dimensions：直接在页面上测量的利器</li><li>livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中</li><li>image tool：测量，取色</li><li>UC二维码：移动端调试扫码必备</li><li>pagespeed，YSlow：页面性能分析和优化插件</li><li>马克飞象：优秀的在线markdown编辑器，快速写周报，做记录</li></ul></li></ul></li><li>sublime text2：编码方便，插件多，速度快，性能好<ul><li>emmet：提升html编码速度必备</li><li>sublimelinter + 各种语言的lint和hint：代码纠错</li><li>一些snippets：自动补全，提升开发效率</li></ul></li><li>Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能</li><li>Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件</li><li>GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子</li><li>iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备</li><li>Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用</li><li>Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便</li></ul><h4 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h4><p>前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说</p><h5 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h5><p>JavaScript：</p><ul><li>作用域链、闭包、运行时上下文、this</li><li>原型链、继承</li><li>NodeJS基础和常用API</li></ul><p>CSS：</p><ul><li>选择器</li><li>浏览器兼容性及常见的hack处理</li><li>CSS布局的方式和原理（盒子模型、BFC、IFC等等）</li><li>CSS 3，如animation、gradient、等等</li></ul><p>HTML：</p><ul><li>语义化标签</li></ul><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>JavaScript:</p><ul><li>异步控制（Promise、ES6 generator、Async）</li><li>模块化的开发方式（AMD、CMD、KMD等等）</li><li>JavaScript解释器的一些相关知识<ul><li>异步IO实现</li><li>垃圾回收</li><li>事件队列</li></ul></li><li>常用框架使用及其原理<ul><li>jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研</li><li>AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦</li><li>underscore：优秀的工具库，方便的理解常用工具代码片段的实现</li><li>polymer/React: 组件化开发，面向未来，理解组件化开发的原理</li></ul></li></ul><p>CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理</p><ul><li>DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程</li><li>解析HTML、CSS、JavaScript时造成的阻塞</li><li>HTML5相关<ul><li>SVG及矢量图原理</li><li>Canvas开发及动画原理（帧动画）</li><li>Video和Audio</li></ul></li><li>flex box布局方式</li><li>icon fonts的使用</li></ul><p>常用NodeJs的package：</p><ul><li>koa</li><li>express</li><li>underscore</li><li>async</li><li>gulp</li><li>grunt</li><li>connect</li><li>request</li></ul><p>一些理念：</p><ul><li>响应式Web</li><li>优雅降级、渐进增强</li><li>don`t make me think</li><li>网页可用性、可访问性、其中的意义</li><li>SEO搜索引擎优化，了解搜索引擎的原理</li><li>SPA的好处和问题</li></ul><p>性能优化：</p><ul><li>减少请求数量（sprite、combo）</li><li>善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式）</li><li>减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离）</li><li>CSS的回流与重绘</li></ul><h5 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h5><ul><li>版本管理：首推Git，用过Git都不会想用SVN了<ul><li>Git：本地版本管理的机制</li><li>SVN：远程中心的版本管理机制</li></ul></li><li>自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并<ul><li>Gulp：基于流构建，速度快、模块质量好</li><li>Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高</li></ul></li><li>预处理和模板引擎<ul><li>less：语法简单，但功能有限</li><li>jade、ejs、velocity等模板引擎，各有各的长处</li><li>coffee：python工程师最爱，我没用过</li></ul></li><li>环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了<ul><li>本地代理：ihosts</li></ul></li><li>自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果<ul><li>jasmine</li><li>mocha</li></ul></li><li>生态系统<ul><li>npm</li><li>bower</li><li>spm</li></ul></li><li>搭建一个属于自己的博客<ul><li>git pages</li><li>hexo</li><li>jekyll</li></ul></li></ul><h5 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h5><ul><li>Web Componets：面向未来的组件化开发方式<ul><li>HTML模板</li><li>Shadow DOM</li><li>Custom Elements</li><li>HTML Import</li></ul></li><li>移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方</p><ul><li><strong>对于业务的思考</strong>：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务</li><li>交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目</li><li>知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录</li><li>对新技术的渴望，以及敢于尝试</li></ul><h4 id="入门书"><a href="#入门书" class="headerlink" title="入门书"></a>入门书</h4><p>入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书：</p><ul><li>《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看</li><li>《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助</li><li>《编写可维护的JavaScript》和：</li><li>《Node.js开发指南》：不错的Nodejs入门书籍</li><li>《深入浅出Node.js》：Nodejs进阶书籍，必备</li><li>《JavaScript异步编程》：理解JS异步的编程理念</li><li>《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书</li><li>《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西</li><li>《Don`t make me think》：网页设计的理念，了解用户行为，非常不错</li><li>《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题</li><li>《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习</li><li>《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助</li><li>《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识</li><li>《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想</li><li>《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门</li></ul><h4 id="一些不错的网站"><a href="#一些不错的网站" class="headerlink" title="一些不错的网站"></a>一些不错的网站</h4><ul><li><a href="https://github.com" target="_blank" rel="noopener">github</a>：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习</li><li><a href="http://codepen.io" target="_blank" rel="noopener">codepen</a>：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件</li><li><a href="http://www.echojs.com" target="_blank" rel="noopener">echojs</a>：快速了解js新资讯的网站</li><li><a href="http://stackoverflow.com" target="_blank" rel="noopener">stackoverflow</a>和<a href="segmentfault.com">segmentfault</a>：基本上各种问题都能在上面获得解答</li><li><a href="https://developers.google.com/web/fundamentals" target="_blank" rel="noopener">google web fundamentals</a>：每篇文章都适合仔细阅读</li><li><a href="http://www.staticfile.org" target="_blank" rel="noopener">static files</a>：开放的CDN，很好用</li><li><a href="http://www.iconfont.cn" target="_blank" rel="noopener">iconfont</a>：阿里的矢量图标库，非常不错，支持CDN而且支持项目</li><li><a href="http://www.html5rocks.com" target="_blank" rel="noopener">html5 rocks</a>: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章</li><li><a href="http://css-tricks.com" target="_blank" rel="noopener">css tricks</a>：如何活用CSS，以及了解CSS新特性，这里可以满足你</li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.general" target="_blank" rel="noopener">JavaScript 秘密花园</a> JavaScript初学必看，非常不错</li><li><a href="http://www.w3cplus.com" target="_blank" rel="noopener">w3cplus</a>：一个前端学习的网站，里面的文章质量都挺不错的</li><li><a href="http://nodeschool.io" target="_blank" rel="noopener">node school</a>：一个不错的node学习网站</li><li><a href="http://pcottle.github.io/learnGitBranching/?demo" target="_blank" rel="noopener">learn git branch</a>：一个git学习网站，交互很棒</li><li><a href="http://www.html-js.com" target="_blank" rel="noopener">前端乱炖</a>：一个前端文章分享的社区，有很多优秀文章</li><li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式</a>：一个正则表达式入门教程，非常值得一看</li><li><a href="http://www.ruanyifeng.com/blog" target="_blank" rel="noopener">阮一峰的博客</a>和<a href="http://www.zhangxinxu.com/wordpress" target="_blank" rel="noopener">张鑫旭的博客</a>：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源</li><li>各路大牛的博客：这个太多了，就不贴了，知乎上有很全的</li><li>各种规范的官方网站，不懂得时候读规范</li></ul><h4 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h4><p>以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和<a href="http://www.w3school.com.cn" target="_blank" rel="noopener">W3C School</a>上的教程，以及一些前端博客，如<a href="http://www.cnblogs.com/TomXu" target="_blank" rel="noopener">汤姆大叔的博客</a>。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了…</p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <category domain="http://lingyu.life/tags/CSS/">CSS</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/HTML/">HTML</category>
      
      <category domain="http://lingyu.life/tags/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <comments>http://lingyu.life/2014/09/22/old/learn-fe/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>细说Generator</title>
      <link>https://lingyu.life/#/post/2014/07/29/old/generator</link>
      <guid>https://lingyu.life/#/post/2014/07/29/old/generator</guid>
      <pubDate>Mon, 28 Jul 2014 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p><a id="more"></a><p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="/#/post/post/2014/3/28/js-basis">JavaScript一些基础知识简介</a></p><h1 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h1><p>generator函数执行的时候，会进行如下动作：</p><ol><li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li><li>创建一个generator对象，其有如下值：<ul><li>Scope：新建的作用域链</li><li>Code：generator function内部的代码</li><li>ExecutionContext：EC，目前值为null</li><li>State：”newborn”</li><li>Handler：默认的generator的处理器</li></ul></li></ol><p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p><h1 id="yield的行为"><a href="#yield的行为" class="headerlink" title="yield的行为"></a>yield的行为</h1><p>当执行到<code>yield e</code>时：</p><ol><li>计算出表达式e的值</li><li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li><li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li><li>从EC栈弹出当前的EC</li><li>返回(normal, 1中的结果值, null)</li></ol><p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p><p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p><h1 id="return行为"><a href="#return行为" class="headerlink" title="return行为"></a>return行为</h1><p>当执行到<code>return e</code>时：</p><ol><li>计算出表达式e的值</li><li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li><li>将这个generator对象的状态修改为closed</li><li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li><li>throw这个对象</li></ol><p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p><h1 id="Generator对象的私有属性"><a href="#Generator对象的私有属性" class="headerlink" title="Generator对象的私有属性"></a>Generator对象的私有属性</h1><ul><li>prototype：Object.prototype</li><li>code：generator函数的函数体</li><li>ExecutionContext：内部代码运行使用的EC</li><li>Scope：作用域链</li><li>Handler：标准的generator句柄</li><li>State：newborn、executing、suspended、closed</li><li>Send：看内部方法部分</li><li>Throw：看内部方法部分</li><li>Close：看内部方法部分</li></ul><h1 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h1><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.send，传入一个undefined</li><li>返回结果</li></ol><p>调用私有send方法</p><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><p>send方法允许指定一个值，作为上一次yield的返回值</p><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.send，传入当前第一个参数</li><li>返回结果</li></ol><p>同样是调用私有send方法，不过传入了参数</p><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.throw，传入当前第一个参数</li><li>返回结果</li></ol><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>调用close方法可以直接以当前的value作为Generator的返回值</p><ol><li>如果this指向的不是generator对象，抛异常</li><li>调用this.close，不传入任何参数</li><li>返回结果</li></ol><h2 id="iterate"><a href="#iterate" class="headerlink" title="iterate"></a>iterate</h2><p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p><h1 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h1><ul><li>newborn：Code不为null，EC为null</li><li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li><li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li><li>closed：Code为null，EC为null</li></ul><p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p><p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p><p>当然也可以通过close方法，手动修改状态为closed</p><h1 id="内部方法"><a href="#内部方法" class="headerlink" title="内部方法"></a>内部方法</h1><h2 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h2><ol><li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li><li>如果state为newborn<ol><li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li><li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li><li>将这个EC压入EC栈中</li><li>执行generator中的代码，并返回或得到的结果</li></ol></li><li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li></ol><p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p><p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p><p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p><h2 id="throw-1"><a href="#throw-1" class="headerlink" title="throw"></a>throw</h2><ol><li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li><li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li><li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li></ol><p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p><h2 id="close-1"><a href="#close-1" class="headerlink" title="close"></a>close</h2><ol><li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li><li>如果state已经是closed了，那直接return就好</li><li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li><li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li></ol><p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p><h2 id="Resume-EC-completionType-V"><a href="#Resume-EC-completionType-V" class="headerlink" title="Resume(EC, completionType, V)"></a>Resume(EC, completionType, V)</h2><ol><li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li><li>从EC通过currentGenerator获取单签generator对象</li><li>设置当前作用域链为当前generator对象的作用域链</li><li>继续执行代码，并根据completionType做相应的处理</li></ol><h1 id="NodeJs上的不同"><a href="#NodeJs上的不同" class="headerlink" title="NodeJs上的不同"></a>NodeJs上的不同</h1><p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank" rel="noopener">harmony generators ES Wiki</a></p>]]></content:encoded>
      
      
      <category domain="http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</category>
      
      
      <category domain="http://lingyu.life/tags/NodeJs/">NodeJs</category>
      
      <category domain="http://lingyu.life/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://lingyu.life/tags/ES6/">ES6</category>
      
      <category domain="http://lingyu.life/tags/Generator/">Generator</category>
      
      <category domain="http://lingyu.life/tags/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/">语言特性</category>
      
      
      <comments>http://lingyu.life/2014/07/29/old/generator/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>