{"tags":[{"name":"WebIM","permalink":"http://lingyu.life/tags/WebIM/","url":"/async/tags/WebIM.json","count":6},{"name":"WebRTC","permalink":"http://lingyu.life/tags/WebRTC/","url":"/async/tags/WebRTC.json","count":5},{"name":"JavaScript","permalink":"http://lingyu.life/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":28},{"name":"Canvas","permalink":"http://lingyu.life/tags/Canvas/","url":"/async/tags/Canvas.json","count":2},{"name":"游戏","permalink":"http://lingyu.life/tags/%E6%B8%B8%E6%88%8F/","url":"/async/tags/游戏.json","count":2},{"name":"算法","permalink":"http://lingyu.life/tags/%E7%AE%97%E6%B3%95/","url":"/async/tags/算法.json","count":1}],"categories":[{"name":"即时通信","permalink":"http://lingyu.life/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/","url":"/async/categories/即时通信.json","count":6}],"url":"/async/posts/2014/11/18/peertc-and-fivechess.json","date":1416240000000,"path":{"year":2014,"month":11,"day":18,"name":"peertc-and-fivechess"},"subtitle":"使用Peertc实现双人对战五子棋","title":"Peertc和五子棋","permalink":"http://lingyu.life/2014/11/18/peertc-and-fivechess/","content":"<p>今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：<a href=\"https://github.com/LingyuCoder/peertc\" target=\"_blank\" rel=\"noopener\">Peertc</a>、<a href=\"https://github.com/LingyuCoder/FiveChess\" target=\"_blank\" rel=\"noopener\">五子棋</a></p>\n<a id=\"more\"></a>\n\n<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>之前我曾经写过好几篇关于WebRTC和DataChannel相关的文章。WebRTC是我毕业设计中非常重要的一部分，因此对它做了不少研究。虽然WebRTC的RTC是real-time communication，但它带来的好处并不只局限在即时通信领域。建立点对点通信并在浏览器之间直接传递数据，光这一点就可以提出非常多有趣的设想。有两个应用的点子我一直想做：</p>\n<ul>\n<li>FC红白机那种双人对战（协作）游戏，配合Canvas和WebGL，这也就是这次五子棋想法的来源。</li>\n<li>在线协作编辑：《黑客与画家》中曾经提到过，说在线协作这种工具很有市场。另外除了文档，我们还可以基于Canvas做协作绘图。</li>\n</ul>\n<p>五子棋就来源一第一个点子。至于第二个，做了一些调研，估计用<a href=\"https://github.com/Operational-Transformation/ot.js\" target=\"_blank\" rel=\"noopener\">OT.js</a>，只能等有时间的时候去弄了。</p>\n<p>FC那么多牛逼的游戏，我却只是做了一个五子棋。原因很简单，Canvas玩的不够熟练也没有素材。五子棋游戏和其他游戏不同的是，它不需要做循环画面刷新，非常适合Canvas上手。</p>\n<h2 id=\"Peertc\"><a href=\"#Peertc\" class=\"headerlink\" title=\"Peertc\"></a>Peertc</h2><p><a href=\"https://github.com/LingyuCoder/peertc\" target=\"_blank\" rel=\"noopener\">Peertc</a>是我在WebRTC DataChannel基础上实现的一个建立点对点通信，发送数据和文件的一个库。由于WebRTC在建立通信信道上还是无法脱离服务器，所以使用Node.js和<a href=\"https://www.npmjs.org/package/ws\" target=\"_blank\" rel=\"noopener\">ws</a>在后台弄了个WebSocket服务器，同时WebSocket也是很好的退化方案。</p>\n<p>至于Peertc具体如何建立点对点连接，我已经在文章<a href=\"/#/post/2014/10/21/datachannel\">使用WebRTC DataChannel在浏览器间传递数据</a>中通过老姚和老刘的故事介绍过了</p>\n<p>如果图简单的话，只要知道Peertc就是一个在俩浏览器之间传输数据的库就可以了</p>\n<h2 id=\"五子棋\"><a href=\"#五子棋\" class=\"headerlink\" title=\"五子棋\"></a>五子棋</h2><p>我以前没写过五子棋，玩五子棋也玩的比较渣。乘着这个机会，仔细研究了一下五子棋的实现。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>一个棋盘（多大随意，我玩过15*15的，但是也玩过可以无限扩展的）就是一个二维数组，黑白轮流往棋盘上放棋子，也就是往二维数组里赋值。每次放下棋子，判断一下在当前位置的横线、竖线、两条斜线上是否能成五个相连，也就是判断各个方向是否能成5个数字相同。</p>\n<p>状态也只有4个：</p>\n<ol>\n<li>黑色落子</li>\n<li>白色落子</li>\n<li>黑色获胜</li>\n<li>白色获胜</li>\n</ol>\n<p>状态转移：</p>\n<ul>\n<li>初始状态为黑色落子</li>\n<li>黑色落子后judge判断是否获胜，若获胜转黑色获胜，否则转白色落子</li>\n<li>白色落子后judge判断是否获胜，若获胜转白色获胜，否则转黑色落子</li>\n</ul>\n<p>所以，五子棋的核心就是一个judge方法来判断是否连成5子，实现很简单</p>\n<h3 id=\"AI\"><a href=\"#AI\" class=\"headerlink\" title=\"AI\"></a>AI</h3><p>为什么要写AI？本来只是想实现双人对战的，那就不要AI了，但是觉着如果只能双人对战未免太过无趣，所以就调研了一下五子棋的AI算法。发现它和计算网页内容的readablity一样，通过计算下在各个位置所获得的分值，得分最高的即是最优解。这里需要注意几个地方：</p>\n<ol>\n<li>这是一个对战游戏，自己要下子获胜，也要堵别人子防止别人获胜。因此计算权重时两种情况都要考虑</li>\n<li>下过五子棋的都知道，如果成了一列（无论方向），两头都没有被堵子肯定要比被堵了一头要强，因此这个是否被堵也要加到考虑当中</li>\n<li>连着的越多，越靠近胜利</li>\n<li>放在棋盘较为中间的位置比较好（如果棋盘是固定大小的话）</li>\n</ol>\n<h2 id=\"双人对战\"><a href=\"#双人对战\" class=\"headerlink\" title=\"双人对战\"></a>双人对战</h2><p>既然涉及到双人互动的话，就会涉及到协议了。就算是一个简单的五子棋对战也有协议，这里直接用json好了。由于Peertc帮我们实现了链接和数据传输，A下的子的位置直接传给B就行了。</p>\n<p>这里与AI不同的一个地方就是，AI反应快的一笔，不是玩家下子的时候，不做屏蔽也没太大关系。但是玩家需要思考，网络有延迟，所以在上面的黑色落子和白色落子阶段都需要加上对应的屏蔽，保证不会出现该白色落子，黑色依然能下的情况。</p>\n<p>那么，需要哪些信令呢？</p>\n<h3 id=\"开一局\"><a href=\"#开一局\" class=\"headerlink\" title=\"开一局\"></a>开一局</h3><p>开局，这个开局由一方先行发起，发起的一方将自己所持的颜色保存，并将对方应持的颜色和开局指令交给对方，至于颜色怎么来，可以随机或者固定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selfColor = <span class=\"string\">'black'</span>;</span><br><span class=\"line\">connector.send(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">'new'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        color: <span class=\"string\">'white'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"落子\"><a href=\"#落子\" class=\"headerlink\" title=\"落子\"></a>落子</h3><p>开局之后，双方都将开始游戏，各自会有自己的游戏数据和状态机。他们的状态应当完全同步。其实可以把对方想象成一个有延迟的AI。落子的关键就在于位置和颜色，位置一般不会有太大问题，而颜色如果错误麻烦就大了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connector.send(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">'drop'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        color: fiveChess.state,</span><br><span class=\"line\">        x: x,</span><br><span class=\"line\">        y: y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里使用的是五子棋内部的状态表明的颜色，而不是使用当前持有的颜色，就是为了防止状态机不同步导致错误。</p>\n<h3 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h3><p>双方在自己或对方落子后可以自行计算是否获胜游戏结束。真正需要传输的游戏结束的信令应当表征有一方认输。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connector.send(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">'end'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过这三个信令，一个对战的五子棋就完成了</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>五子棋属于逻辑比较简单的游戏，因此实现起来很好理解，难度不大。写一个这种基于网络对战游戏，设计好自动机、设计好相互交互的信令是非常重要的。</p>\n<p>希望以后Canvas学好了，能够写出像《魂斗罗》，《雪人兄弟》，《拳皇》这样的游戏。</p>\n"}