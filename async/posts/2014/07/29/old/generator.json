{"tags":[{"name":"NodeJs","permalink":"http://lingyu.life/tags/NodeJs/","url":"/async/tags/NodeJs.json","count":11},{"name":"JavaScript","permalink":"http://lingyu.life/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":26},{"name":"ES6","permalink":"http://lingyu.life/tags/ES6/","url":"/async/tags/ES6.json","count":2},{"name":"Generator","permalink":"http://lingyu.life/tags/Generator/","url":"/async/tags/Generator.json","count":1},{"name":"语言特性","permalink":"http://lingyu.life/tags/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/","url":"/async/tags/语言特性.json","count":4}],"categories":[{"name":"前端工程化","permalink":"http://lingyu.life/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/","url":"/async/categories/前端工程化.json","count":6}],"url":"/async/posts/2014/07/29/old/generator.json","date":1406563200000,"path":{"year":2014,"month":7,"day":29,"name":"old/generator"},"subtitle":"剖析Generator的本质","title":"细说Generator","permalink":"http://lingyu.life/2014/07/29/old/generator/","content":"<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>\n<a id=\"more\"></a>\n\n<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href=\"/#/post/post/2014/3/28/js-basis\">JavaScript一些基础知识简介</a></p>\n<h1 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h1><p>generator函数执行的时候，会进行如下动作：</p>\n<ol>\n<li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>\n<li>创建一个generator对象，其有如下值：<ul>\n<li>Scope：新建的作用域链</li>\n<li>Code：generator function内部的代码</li>\n<li>ExecutionContext：EC，目前值为null</li>\n<li>State：”newborn”</li>\n<li>Handler：默认的generator的处理器</li>\n</ul>\n</li>\n</ol>\n<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>\n<h1 id=\"yield的行为\"><a href=\"#yield的行为\" class=\"headerlink\" title=\"yield的行为\"></a>yield的行为</h1><p>当执行到<code>yield e</code>时：</p>\n<ol>\n<li>计算出表达式e的值</li>\n<li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>\n<li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>\n<li>从EC栈弹出当前的EC</li>\n<li>返回(normal, 1中的结果值, null)</li>\n</ol>\n<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>\n<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>\n<h1 id=\"return行为\"><a href=\"#return行为\" class=\"headerlink\" title=\"return行为\"></a>return行为</h1><p>当执行到<code>return e</code>时：</p>\n<ol>\n<li>计算出表达式e的值</li>\n<li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>\n<li>将这个generator对象的状态修改为closed</li>\n<li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>\n<li>throw这个对象</li>\n</ol>\n<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>\n<h1 id=\"Generator对象的私有属性\"><a href=\"#Generator对象的私有属性\" class=\"headerlink\" title=\"Generator对象的私有属性\"></a>Generator对象的私有属性</h1><ul>\n<li>prototype：Object.prototype</li>\n<li>code：generator函数的函数体</li>\n<li>ExecutionContext：内部代码运行使用的EC</li>\n<li>Scope：作用域链</li>\n<li>Handler：标准的generator句柄</li>\n<li>State：newborn、executing、suspended、closed</li>\n<li>Send：看内部方法部分</li>\n<li>Throw：看内部方法部分</li>\n<li>Close：看内部方法部分</li>\n</ul>\n<h1 id=\"外部接口\"><a href=\"#外部接口\" class=\"headerlink\" title=\"外部接口\"></a>外部接口</h1><h2 id=\"next\"><a href=\"#next\" class=\"headerlink\" title=\"next\"></a>next</h2><ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.send，传入一个undefined</li>\n<li>返回结果</li>\n</ol>\n<p>调用私有send方法</p>\n<h2 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send\"></a>send</h2><p>send方法允许指定一个值，作为上一次yield的返回值</p>\n<ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.send，传入当前第一个参数</li>\n<li>返回结果</li>\n</ol>\n<p>同样是调用私有send方法，不过传入了参数</p>\n<h2 id=\"throw\"><a href=\"#throw\" class=\"headerlink\" title=\"throw\"></a>throw</h2><ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.throw，传入当前第一个参数</li>\n<li>返回结果</li>\n</ol>\n<h2 id=\"close\"><a href=\"#close\" class=\"headerlink\" title=\"close\"></a>close</h2><p>调用close方法可以直接以当前的value作为Generator的返回值</p>\n<ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.close，不传入任何参数</li>\n<li>返回结果</li>\n</ol>\n<h2 id=\"iterate\"><a href=\"#iterate\" class=\"headerlink\" title=\"iterate\"></a>iterate</h2><p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>\n<h1 id=\"状态定义\"><a href=\"#状态定义\" class=\"headerlink\" title=\"状态定义\"></a>状态定义</h1><ul>\n<li>newborn：Code不为null，EC为null</li>\n<li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>\n<li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>\n<li>closed：Code为null，EC为null</li>\n</ul>\n<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>\n<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>\n<p>当然也可以通过close方法，手动修改状态为closed</p>\n<h1 id=\"内部方法\"><a href=\"#内部方法\" class=\"headerlink\" title=\"内部方法\"></a>内部方法</h1><h2 id=\"send方法\"><a href=\"#send方法\" class=\"headerlink\" title=\"send方法\"></a>send方法</h2><ol>\n<li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>\n<li>如果state为newborn<ol>\n<li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>\n<li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>\n<li>将这个EC压入EC栈中</li>\n<li>执行generator中的代码，并返回或得到的结果</li>\n</ol>\n</li>\n<li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>\n</ol>\n<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>\n<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>\n<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>\n<h2 id=\"throw-1\"><a href=\"#throw-1\" class=\"headerlink\" title=\"throw\"></a>throw</h2><ol>\n<li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>\n<li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>\n<li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>\n</ol>\n<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>\n<h2 id=\"close-1\"><a href=\"#close-1\" class=\"headerlink\" title=\"close\"></a>close</h2><ol>\n<li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>\n<li>如果state已经是closed了，那直接return就好</li>\n<li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>\n<li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>\n</ol>\n<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>\n<h2 id=\"Resume-EC-completionType-V\"><a href=\"#Resume-EC-completionType-V\" class=\"headerlink\" title=\"Resume(EC, completionType, V)\"></a>Resume(EC, completionType, V)</h2><ol>\n<li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>\n<li>从EC通过currentGenerator获取单签generator对象</li>\n<li>设置当前作用域链为当前generator对象的作用域链</li>\n<li>继续执行代码，并根据completionType做相应的处理</li>\n</ol>\n<h1 id=\"NodeJs上的不同\"><a href=\"#NodeJs上的不同\" class=\"headerlink\" title=\"NodeJs上的不同\"></a>NodeJs上的不同</h1><p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h2><p><a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:generators\" target=\"_blank\" rel=\"noopener\">harmony generators ES Wiki</a></p>\n"}