{"tags":[{"name":"HTML","permalink":"http://lingyu.life/tags/HTML/","url":"/async/tags/HTML.json","count":17},{"name":"性能优化","permalink":"http://lingyu.life/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","url":"/async/tags/性能优化.json","count":5}],"categories":[{"name":"性能优化","permalink":"http://lingyu.life/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","url":"/async/categories/性能优化.json","count":5}],"url":"/async/posts/2014/02/20/old/application-cache.json","date":1392825600000,"path":{"year":2014,"month":2,"day":20,"name":"old/application-cache"},"subtitle":"前端性能优化系列","title":"前端性能优化（Application Cache篇）","permalink":"http://lingyu.life/2014/02/20/old/application-cache/","content":"<p>之前在segmentfault上刷问题看到一个关于manifest的问题，很好奇就研究了一下application cache。Application Cache是HTML5的新特性，允许浏览器在本地存储页面所需要的资源，使得页面离线也可以访问。之前研究的目的是为了在博客中使用，将一些不需要改动的CSS、JavaScript、图片文件离线缓存，这样加载速度必然飞起，希望能用在博客上，但是失败了，但还是记录一下学到的知识</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Application-Cache的配置文件\"><a href=\"#Application-Cache的配置文件\" class=\"headerlink\" title=\"Application Cache的配置文件\"></a>Application Cache的配置文件</h2><p>首先需要在服务器上建立一个文件，里面的内容确定了哪些文件需要缓存，哪些文件不需要，如果资源无法访问会使用什么页面等</p>\n<p>这个文件一般为<code>.appcache</code>类型，称为<strong>缓存清单(cache manifest)文件</strong>，一个完整的缓存清单文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"># version xx.xx.xx</span><br><span class=\"line\">CACHE:</span><br><span class=\"line\">needBeCached.png</span><br><span class=\"line\">needBeCached2.js</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">notNeedBeCached.html</span><br><span class=\"line\">notNeedBeCached2.css</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\">&#x2F; 404.html</span><br></pre></td></tr></table></figure>\n<p>可以看到，文件的头部信息<code>CACHE MANIFEST</code>用来标注这个文件是缓存清单文件，其后一般情况下（最好是）跟着一行标明版本的注释，这行注释非常重要，将在后面文件加载部分详细介绍这行注释的重要性</p>\n<h2 id=\"CACHE部分\"><a href=\"#CACHE部分\" class=\"headerlink\" title=\"# CACHE部分\"></a># CACHE部分</h2><p>除了头部信息，这个缓存清单文件分为几部分，第一部分为CACHE部分: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE:</span><br><span class=\"line\">needBeCached.png</span><br><span class=\"line\">needBeCached2.js</span><br></pre></td></tr></table></figure>\n<p>这一部分标注了哪些资源文件需要被缓存可以列出多个</p>\n<p>如果有路径，如需要缓存blog下的blog.css文件，可以写成<code>blog/blog.css</code>。</p>\n<p>另外<code>CACHE:</code>可以被省略，让需要缓存的资源文件直接跟在注释之后</p>\n<h2 id=\"NETWORK部分\"><a href=\"#NETWORK部分\" class=\"headerlink\" title=\"# NETWORK部分\"></a># NETWORK部分</h2><p>第二部分为NETWORK部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NETWORK:</span><br><span class=\"line\">notNeedBeCached.html</span><br><span class=\"line\">notNeedBeCached2.css</span><br></pre></td></tr></table></figure>\n<p>这一部分定义了哪些文件不需要缓存，这些文件需要与服务器连接</p>\n<p>与CACHE一样，可以定义多个资源，而如果直接输入一个文件夹路径，也是合法的，比如<code>/blog</code>这样，blog文件夹下的所有文件都不会被缓存</p>\n<p>可以使用通配符来，如除了上面CACHE中定义的资源，其他都必须与服务器连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NETWORK:</span><br><span class=\"line\">*</span><br></pre></td></tr></table></figure>\n\n<p>需要注意一点是，载有这个manifest文件的HTML文档将一定会缓存，这个会在后面再次提到</p>\n<h2 id=\"FALLBACK部分\"><a href=\"#FALLBACK部分\" class=\"headerlink\" title=\"# FALLBACK部分\"></a># FALLBACK部分</h2><p>第三部分为FALLBACK部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FALLBACK:</span><br><span class=\"line\">&#x2F; 404.html</span><br></pre></td></tr></table></figure>\n<p>这一部分指定了一个后备页面，当资源无法访问时，浏览器会使用该页面</p>\n<p>同样可以定义多条记录，每条记录列出两个URI，一个表示资源，一个表示后备页面。需要注意的是两个资源文件都需要使用相对路径切与manifest文件同源</p>\n<p>同样可以使用通配符</p>\n<h2 id=\"保存和引用manifest文件\"><a href=\"#保存和引用manifest文件\" class=\"headerlink\" title=\"# 保存和引用manifest文件\"></a># 保存和引用manifest文件</h2><p>manifest文件可以保存在服务器上，保存为<code>.appcache</code>后缀，但必须与应用本身同源。在HTML文档中，可以指定清单文件的相对路径和绝对URL。需要注意的是，manifest文件的MIME类型必须是<code>text/cache-manifest</code></p>\n<p>需要在HTML文档中引入manifest文件，可以使用类似如下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"manifest.appcache\"</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样，HTML文档加载后，就会根据manifest.appcache的内容来缓存资源文件，在下次访问相同页面的时候，会直接使用缓存的资源文件来进行加速</p>\n<h2 id=\"缓存和加载机制\"><a href=\"#缓存和加载机制\" class=\"headerlink\" title=\"缓存和加载机制\"></a>缓存和加载机制</h2><p>在第一次访问时，浏览器加载完HTML文档后，会查看其是否有引入manifest文件。若引入，则加载manifest文件，然后根据manifest的文件内容进行资源的缓存，并缓存当前文档</p>\n<p>之后访问，浏览器首先会查看manifest文件是否被修改（无论是内容还是注释），如果被修改，将当做第一次访问，重新根据manifest文件内容进行缓存</p>\n<p>如果应用缓存存在，且manifest没有被修改，浏览器直接从缓存中加载文档（注意：加载文档）和资源，不会访问网络（注意：无论联网与否，都不会访问网络）</p>\n<p>在缓存多个资源文件时，浏览器下载资源文件会先放在一个临时的缓存中，如果有任何一个资源文件下载失败，浏览器将停止其他缓存资源的下载，并清除临时缓存。如果所有资源文件都被成功下载，浏览器将会把这些资源文件以及引用manifest文件的HTML文档移动到永久离线缓存中</p>\n<h2 id=\"满满的都是坑\"><a href=\"#满满的都是坑\" class=\"headerlink\" title=\"满满的都是坑\"></a>满满的都是坑</h2><h2 id=\"一些小坑\"><a href=\"#一些小坑\" class=\"headerlink\" title=\"# 一些小坑\"></a># 一些小坑</h2><ol>\n<li>需要注意的是manifest文件放在服务器上，MIME类型必须是<code>text/cache-manifest</code>，如果使用 Apache，需要修改.htaccess文件。IE下默认application/octet-stream，需要在服务器指定</li>\n<li>每个需要缓存的页面的html都需要加入manifest属性</li>\n<li>不要将manifest文件本身加入缓存，如果加入，浏览器将不会检测到服务器上manifest的更新，页面版本将万年不变</li>\n<li>不要以为一个资源文件加载失败，其他文件就会被缓存，原因参见缓存和加载机制的最后一段</li>\n</ol>\n<h2 id=\"一些大坑\"><a href=\"#一些大坑\" class=\"headerlink\" title=\"# 一些大坑\"></a># 一些大坑</h2><ol>\n<li>在manifest文件中定义的资源全部被成功加载后，这些资源文件连同<strong>引用manifest文件的HTML文档</strong>一并被移动到永久离线缓存中。所以如果想只缓存js、css、图片等文件，而不希望缓存HTML文档以保持获得最新内容的情况来说，这就是个大坑</li>\n<li>根据Application Cache的加载机制，如果仅仅修改资源文件的内容（没有修改资源文件的路径或名称），浏览器将直接从本地离线缓存中获取资源文件。所以在每次修改资源文件的同时，需要修改manifest文件，以触发资源文件的重新加载和缓存。这其中，最有效的方式是修改manifest文件内部的版本注释（所以说那句注释相当重要）</li>\n<li>如果资源没有被缓存，在而没有设置NETWORK的情况下，将会无法加载（浏览器不会去网络上进行加载），所以需要使用通配符来表明除了CACHE中确定的资源以外，其他资源都需要去网络上加载</li>\n</ol>\n<h2 id=\"使用iframe来避开一号坑？\"><a href=\"#使用iframe来避开一号坑？\" class=\"headerlink\" title=\"# 使用iframe来避开一号坑？\"></a># 使用iframe来避开一号坑？</h2><p>网上传言避开一号坑的方法是使用iframe来指定需要缓存的资源，而避开HTML文档的缓存。具体做法是在HTML中嵌入一个iframe，iframe中的页面的HTML标签包含manifest属性引用manifest文件，里面定义了需要缓存的文件。这样就会只缓存iframe中的HTML文档，而持续更新主页面：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"zh\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>主页面<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"css/style.css\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/javascript.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cache.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，主页面的html标签中，并没有引入manifest文件。只是在其中加载了一个iframe，而这个iframe所加载的页面文档如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"manifest.appcache\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">utf-8</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>缓存页面<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>缓存页面中引入了manifest文件，这样浏览器就会缓存manifest文件中定义的资源列表，比如这里manifest文件的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"># VERSION 1.0</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\">css&#x2F;someStyle.css</span><br><span class=\"line\">js&#x2F;someJavaScript.js</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">*</span><br></pre></td></tr></table></figure>\n<p>在chrome中运行，可以在命令行中看到如下效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating Application Cache with manifest http:&#x2F;&#x2F;localhost:8000&#x2F;manifest.appcache</span><br><span class=\"line\">Application Cache Checking event</span><br><span class=\"line\">Application Cache Downloading event</span><br><span class=\"line\">Application Cache Progress event (0 of 2) http:&#x2F;&#x2F;localhost:8000&#x2F;css&#x2F;someStyle.css</span><br><span class=\"line\">Application Cache Progress event (1 of 2) http:&#x2F;&#x2F;localhost:8000&#x2F;js&#x2F;someJavaScript.js</span><br><span class=\"line\">Application Cache Progress event (2 of 2)</span><br><span class=\"line\">Application Cache Cached event</span><br></pre></td></tr></table></figure>\n<p>浏览器缓存了manifest文件中定义的资源文件，其实同时还缓存了iframe中的缓存页面的文档，但不会缓存主页面，修改一下主页面，并按F5刷新</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document was loaded from Application Cache with manifest http:&#x2F;&#x2F;localhost:8000&#x2F;manifest.appcache</span><br><span class=\"line\">Application Cache Checking event</span><br><span class=\"line\">Application Cache NoUpdate event</span><br></pre></td></tr></table></figure>\n<p>可以看到主页面被更新了，但是someStyle.css和someJavaScript.js文件依旧从网络上加载了，而没有从cache中加载。打开chrome的<code>chrome://appcache-internals/</code>可以看到，里面cache.html、someStyle.css、someJavaScript.js确实被缓存了，去掉NETWORK段，结果也是一样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flags       URL                                         Size (headers and data)</span><br><span class=\"line\">Master,     http:&#x2F;&#x2F;localhost:8000&#x2F;cache.html            388 B</span><br><span class=\"line\">Explicit,   http:&#x2F;&#x2F;localhost:8000&#x2F;css&#x2F;someStyle.css     228 B</span><br><span class=\"line\">Explicit,   http:&#x2F;&#x2F;localhost:8000&#x2F;js&#x2F;someJavaScript.js  244 B</span><br><span class=\"line\">Manifest,   http:&#x2F;&#x2F;localhost:8000&#x2F;manifest.appcache     316 B</span><br></pre></td></tr></table></figure>\n<p>在firefox、opera上测试也是一样，虽然被缓存了，但依旧会从网络上加载，而iframe的解答方法也是2011~2012年左右提出的，后来就没有相关文章了，估计已经彻底失效了</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Application主要是为了构建离线缓存，使得页面在离线模式下也能浏览。这比较适合一些页面上的应用以及静态的不经常变更的页面。其会缓存载体页面也是由于其机制。如果上面iframe机制实现有错误，或是有其他方法只缓存资源不缓存HTML文档，请联系我</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache\" target=\"_blank\" rel=\"noopener\">使用应用缓存</a></p>\n<p><a href=\"http://zoomzhao.com/2012/11/08/application-cache-is-a-douchebag\" target=\"_blank\" rel=\"noopener\">Application Cache 就是个坑</a></p>\n"}