{"tags":[{"name":"JavaScript","permalink":"http://lingyu.life/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":28}],"categories":[{"name":"JS技术","permalink":"http://lingyu.life/categories/JS%E6%8A%80%E6%9C%AF/","url":"/async/categories/JS技术.json","count":12}],"url":"/async/posts/2014/05/12/read-jq-src-3.json","date":1399824000000,"path":{"year":2014,"month":5,"day":12,"name":"read-jq-src-3"},"subtitle":"闲来没事读源码系列——jQuery","title":"jQuery的事件机制——核心篇","permalink":"http://lingyu.life/2014/05/12/read-jq-src-3/","content":"<p>这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等</p>\n<a id=\"more\"></a>\n\n<h1 id=\"jQuery源码——事件机制\"><a href=\"#jQuery源码——事件机制\" class=\"headerlink\" title=\"jQuery源码——事件机制\"></a>jQuery源码——事件机制</h1><p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>\n<h2 id=\"事件管理器\"><a href=\"#事件管理器\" class=\"headerlink\" title=\"事件管理器\"></a>事件管理器</h2><p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>\n<h3 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h3><p>存放事件是否存在</p>\n<h3 id=\"add-elem-types-handler-data-selector\"><a href=\"#add-elem-types-handler-data-selector\" class=\"headerlink\" title=\"add (elem, types, handler, data, selector)\"></a>add (elem, types, handler, data, selector)</h3><p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>\n<p>所以代码大致流程如下：</p>\n<h4 id=\"事件创建逻辑\"><a href=\"#事件创建逻辑\" class=\"headerlink\" title=\"事件创建逻辑\"></a>事件创建逻辑</h4><p>在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handleObjIn, eventHandle, tmp,</span><br><span class=\"line\">    events, t, handleObj,</span><br><span class=\"line\">    special, handlers, type, namespaces, origType,</span><br><span class=\"line\">    elemData = data_priv.get( elem );</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !elemData ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( handler.handler ) &#123;</span><br><span class=\"line\">    handleObjIn = handler;</span><br><span class=\"line\">    handler = handleObjIn.handler;</span><br><span class=\"line\">    selector = handleObjIn.selector;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( !handler.guid ) &#123;</span><br><span class=\"line\">    handler.guid = jQuery.guid++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( !(events = elemData.events) ) &#123;</span><br><span class=\"line\">    events = elemData.events = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !(eventHandle = elemData.handle) ) &#123;</span><br><span class=\"line\">    eventHandle = elemData.handle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> e </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> jQuery !== strundefined &amp;&amp; jQuery.event.triggered !== e.type ?</span><br><span class=\"line\">            jQuery.event.dispatch.apply( elem, <span class=\"built_in\">arguments</span> ) : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>\n<h4 id=\"事件绑定逻辑\"><a href=\"#事件绑定逻辑\" class=\"headerlink\" title=\"事件绑定逻辑\"></a>事件绑定逻辑</h4><p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：</p>\n<ol>\n<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>\n<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>\n<li>特殊事件需要进行名称转换，以及钩子调用</li>\n<li>如果是事件代理也需要注意代理逻辑</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">types = ( types || <span class=\"string\">\"\"</span> ).match( rnotwhite ) || [ <span class=\"string\">\"\"</span> ];</span><br><span class=\"line\">t = types.length;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( t-- ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//后面的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp = rtypenamespace.exec( types[t] ) || [];</span><br><span class=\"line\">type = origType = tmp[<span class=\"number\">1</span>];</span><br><span class=\"line\">namespaces = ( tmp[<span class=\"number\">2</span>] || <span class=\"string\">\"\"</span> ).split( <span class=\"string\">\".\"</span> ).sort();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !type ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">special = jQuery.event.special[ type ] || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">type = ( selector ? special.delegateType : special.bindType ) || type;</span><br><span class=\"line\"></span><br><span class=\"line\">special = jQuery.event.special[ type ] || &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleObj = jQuery.extend(&#123;</span><br><span class=\"line\">    type: type,</span><br><span class=\"line\">    origType: origType,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    handler: handler,</span><br><span class=\"line\">    guid: handler.guid,</span><br><span class=\"line\">    selector: selector,</span><br><span class=\"line\">    needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),</span><br><span class=\"line\">    namespace: namespaces.join(<span class=\"string\">\".\"</span>)</span><br><span class=\"line\">&#125;, handleObjIn );</span><br></pre></td></tr></table></figure>\n<p>这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：</p>\n<ol>\n<li>type：事件的映射后的名称</li>\n<li>origType：事件的原始名称</li>\n<li>data：事件的默认数据</li>\n<li>handler：回调函数</li>\n<li>guid：回调函数的id</li>\n<li>selector：启用事件代理时，被代理的节点的选择器</li>\n<li>needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文</li>\n<li>namespace：重组后的命名空间</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( !(handlers = events[ type ]) ) &#123;</span><br><span class=\"line\">    handlers = events[ type ] = [];</span><br><span class=\"line\">    handlers.delegateCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === <span class=\"literal\">false</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( elem.addEventListener ) &#123;</span><br><span class=\"line\">            elem.addEventListener( type, eventHandle, <span class=\"literal\">false</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( special.add ) &#123;</span><br><span class=\"line\">    special.add.call( elem, handleObj );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !handleObj.handler.guid ) &#123;</span><br><span class=\"line\">        handleObj.handler.guid = handler.guid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( selector ) &#123;</span><br><span class=\"line\">    handlers.splice( handlers.delegateCount++, <span class=\"number\">0</span>, handleObj );</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    handlers.push( handleObj );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.event.global[ type ] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>最后再全局中标记一下事件已存在就行了</p>\n<h3 id=\"remove-elem-types-handler-selector-mappedTypes\"><a href=\"#remove-elem-types-handler-selector-mappedTypes\" class=\"headerlink\" title=\"remove (elem, types, handler, selector, mappedTypes)\"></a>remove (elem, types, handler, selector, mappedTypes)</h3><p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：</p>\n<ol>\n<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>\n<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>\n<li>特殊事件需要进行名称转换，以及钩子调用</li>\n<li>如果是事件代理也需要注意代理逻辑</li>\n<li>在移除了一个事件的所有回调对象后，可以移除这个事件</li>\n<li>在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> j, origCount, tmp,</span><br><span class=\"line\">    events, t, handleObj,</span><br><span class=\"line\">    special, handlers, type, namespaces, origType,</span><br><span class=\"line\">    elemData = data_priv.hasData( elem ) &amp;&amp; data_priv.get( elem );</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !elemData || !(events = elemData.events) ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">types = ( types || <span class=\"string\">\"\"</span> ).match( rnotwhite ) || [ <span class=\"string\">\"\"</span> ];</span><br><span class=\"line\">t = types.length;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( t-- ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//后面的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>处理情况1，和上面的add一样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp = rtypenamespace.exec( types[t] ) || [];</span><br><span class=\"line\">type = origType = tmp[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">namespaces = ( tmp[<span class=\"number\">2</span>] || <span class=\"string\">\"\"</span> ).split( <span class=\"string\">\".\"</span> ).sort();</span><br></pre></td></tr></table></figure>\n<p>获取事件的命名空间，和add方法一样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( !type ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( type <span class=\"keyword\">in</span> events ) &#123;</span><br><span class=\"line\">        jQuery.event.remove( elem, type + types[ t ], handler, selector, <span class=\"literal\">true</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">special = jQuery.event.special[ type ] || &#123;&#125;;</span><br><span class=\"line\">type = ( selector ? special.delegateType : special.bindType ) || type;</span><br><span class=\"line\">handlers = events[ type ] || [];</span><br><span class=\"line\">origCount = j = handlers.length;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( j-- ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//详细删除代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleObj = handlers[ j ];</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;</span><br><span class=\"line\">    ( !handler || handler.guid === handleObj.guid ) &amp;&amp;</span><br><span class=\"line\">    ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;</span><br><span class=\"line\">    ( !selector || selector === handleObj.selector || selector === <span class=\"string\">\"**\"</span> &amp;&amp; handleObj.selector ) ) &#123;</span><br><span class=\"line\">    handlers.splice( j, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( handleObj.selector ) &#123;</span><br><span class=\"line\">        handlers.delegateCount--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( special.remove ) &#123;</span><br><span class=\"line\">        special.remove.call( elem, handleObj );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( origCount &amp;&amp; !handlers.length ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === <span class=\"literal\">false</span> ) &#123;</span><br><span class=\"line\">        jQuery.removeEvent( elem, type, elemData.handle );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> events[ type ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( jQuery.isEmptyObject( events ) ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> elemData.handle;</span><br><span class=\"line\">    data_priv.remove( elem, <span class=\"string\">\"events\"</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果节点中没有任何事件了，直接释放掉事件存储空间</p>\n<h3 id=\"trigger-event-data-elem-onlyHandlers\"><a href=\"#trigger-event-data-elem-onlyHandlers\" class=\"headerlink\" title=\"trigger (event, data, elem, onlyHandlers)\"></a>trigger (event, data, elem, onlyHandlers)</h3><p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, cur, tmp, bubbleType, ontype, handle, special,</span><br><span class=\"line\">    eventPath = [ elem || <span class=\"built_in\">document</span> ],</span><br><span class=\"line\">    type = hasOwn.call( event, <span class=\"string\">\"type\"</span> ) ? event.type : event,</span><br><span class=\"line\">    namespaces = hasOwn.call( event, <span class=\"string\">\"namespace\"</span> ) ? event.namespace.split(<span class=\"string\">\".\"</span>) : [];</span><br><span class=\"line\"></span><br><span class=\"line\">cur = tmp = elem = elem || <span class=\"built_in\">document</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">3</span> || elem.nodeType === <span class=\"number\">8</span> ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( rfocusMorph.test( type + jQuery.event.triggered ) ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>检测是否有focus和blur事件，它们不会在这里被触发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( type.indexOf(<span class=\"string\">\".\"</span>) &gt;= <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">    namespaces = type.split(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">    type = namespaces.shift();</span><br><span class=\"line\">    namespaces.sort();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ontype = type.indexOf(<span class=\"string\">\":\"</span>) &lt; <span class=\"number\">0</span> &amp;&amp; <span class=\"string\">\"on\"</span> + type;</span><br></pre></td></tr></table></figure>\n<p>获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event = event[ jQuery.expando ] ?</span><br><span class=\"line\">    event :</span><br><span class=\"line\">    <span class=\"keyword\">new</span> jQuery.Event( type, <span class=\"keyword\">typeof</span> event === <span class=\"string\">\"object\"</span> &amp;&amp; event );</span><br><span class=\"line\"></span><br><span class=\"line\">event.isTrigger = onlyHandlers ? <span class=\"number\">2</span> : <span class=\"number\">3</span>;</span><br><span class=\"line\">event.namespace = namespaces.join(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">event.namespace_re = event.namespace ?</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>( <span class=\"string\">\"(^|\\\\.)\"</span> + namespaces.join(<span class=\"string\">\"\\\\.(?:.*\\\\.|)\"</span>) + <span class=\"string\">\"(\\\\.|$)\"</span> ) :</span><br><span class=\"line\">    <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">event.result = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !event.target ) &#123;</span><br><span class=\"line\">    event.target = elem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:</p>\n<ol>\n<li>isTrigger: 判断是否需要出发浏览器本身的事件回调</li>\n<li>namespace: 事件的命名空间</li>\n<li>namespace_re: 一个用于匹配当前命名空间的正则</li>\n<li>result: 事件运行的结果</li>\n<li>target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</li>\n</ol>\n<p>事件对象的具体实现，后面会说</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = data == <span class=\"literal\">null</span> ?</span><br><span class=\"line\">    [ event ] :</span><br><span class=\"line\">    jQuery.makeArray( data, [ event ] );</span><br><span class=\"line\"></span><br><span class=\"line\">special = jQuery.event.special[ type ] || &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === <span class=\"literal\">false</span> ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*如果是特殊事件，需要找到对应的真实名称*/</span></span><br><span class=\"line\">    bubbleType = special.delegateType || type;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !rfocusMorph.test( bubbleType + type ) ) &#123;</span><br><span class=\"line\">        cur = cur.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; cur; cur = cur.parentNode ) &#123;</span><br><span class=\"line\">        eventPath.push( cur );</span><br><span class=\"line\">        tmp = cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( tmp === (elem.ownerDocument || <span class=\"built_in\">document</span>) ) &#123;</span><br><span class=\"line\">        eventPath.push( tmp.defaultView || tmp.parentWindow || <span class=\"built_in\">window</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过<code>elem.parentNode</code>来获取元素到window的路径</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) &#123;</span><br><span class=\"line\">    event.type = i &gt; <span class=\"number\">1</span> ?</span><br><span class=\"line\">        bubbleType :</span><br><span class=\"line\">        special.bindType || type;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = ( data_priv.get( cur, <span class=\"string\">\"events\"</span> ) || &#123;&#125; )[ event.type ] &amp;&amp; data_priv.get( cur, <span class=\"string\">\"handle\"</span> );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( handle ) &#123;</span><br><span class=\"line\">        handle.apply( cur, data );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = ontype &amp;&amp; cur[ ontype ];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) &#123;</span><br><span class=\"line\">        event.result = handle.apply( cur, data );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( event.result === <span class=\"literal\">false</span> ) &#123;</span><br><span class=\"line\">            event.preventDefault();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">event.type = type;</span><br></pre></td></tr></table></figure>\n<p>顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (!special._default || special._default.apply( eventPath.pop(), data ) === <span class=\"literal\">false</span>) &amp;&amp;</span><br><span class=\"line\">        jQuery.acceptData( elem ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) &#123;</span><br><span class=\"line\">            tmp = elem[ ontype ];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( tmp ) &#123;</span><br><span class=\"line\">                elem[ ontype ] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            jQuery.event.triggered = type;</span><br><span class=\"line\">            elem[ type ]();</span><br><span class=\"line\">            jQuery.event.triggered = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( tmp ) &#123;</span><br><span class=\"line\">                elem[ ontype ] = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> event.result;</span><br></pre></td></tr></table></figure>\n<p>运行完了，返回事件运行的结果</p>\n<h3 id=\"dispatch-event\"><a href=\"#dispatch-event\" class=\"headerlink\" title=\"dispatch (event)\"></a>dispatch (event)</h3><p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：</p>\n<ol>\n<li>事件代理的情况</li>\n<li>特殊事件</li>\n<li>回调终止（stopPropagation）</li>\n<li>事件的命名空间</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event = jQuery.event.fix( event );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i, j, ret, matched, handleObj,</span><br><span class=\"line\">    handlerQueue = [],</span><br><span class=\"line\">    args = slice.call( <span class=\"built_in\">arguments</span> ),</span><br><span class=\"line\">    handlers = ( data_priv.get( <span class=\"keyword\">this</span>, <span class=\"string\">\"events\"</span> ) || &#123;&#125; )[ event.type ] || [],</span><br><span class=\"line\">    special = jQuery.event.special[ event.type ] || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">args[<span class=\"number\">0</span>] = event;</span><br><span class=\"line\">event.delegateTarget = <span class=\"keyword\">this</span>;</span><br></pre></td></tr></table></figure>\n<p>这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( special.preDispatch &amp;&amp; special.preDispatch.call( <span class=\"keyword\">this</span>, event ) === <span class=\"literal\">false</span> ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>钩子你好，钩子再见…这次是preDispatch钩子…</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handlerQueue = jQuery.event.handlers.call( <span class=\"keyword\">this</span>, event, handlers );</span><br></pre></td></tr></table></figure>\n<p>将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) &#123;</span><br><span class=\"line\">    event.currentTarget = matched.elem;</span><br><span class=\"line\">    j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) &#123;</span><br><span class=\"line\">            event.handleObj = handleObj;</span><br><span class=\"line\">            event.data = handleObj.data;</span><br><span class=\"line\">            ret = ( (jQuery.event.special[ handleObj.origType ] || &#123;&#125;).handle || handleObj.handler )</span><br><span class=\"line\">                    .apply( matched.elem, args );</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( ret !== <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( (event.result = ret) === <span class=\"literal\">false</span> ) &#123;</span><br><span class=\"line\">                    event.preventDefault();</span><br><span class=\"line\">                    event.stopPropagation();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>\n<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( special.postDispatch ) &#123;</span><br><span class=\"line\">    special.postDispatch.call( <span class=\"keyword\">this</span>, event );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> event.result;</span><br></pre></td></tr></table></figure>\n<p>钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>\n<h3 id=\"handlers-event-handlers\"><a href=\"#handlers-event-handlers\" class=\"headerlink\" title=\"handlers (event, handlers)\"></a>handlers (event, handlers)</h3><p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, matches, sel, handleObj,</span><br><span class=\"line\">    handlerQueue = [],</span><br><span class=\"line\">    delegateCount = handlers.delegateCount,</span><br><span class=\"line\">    cur = event.target;</span><br></pre></td></tr></table></figure>\n<p>获取当前事件的目标和代理个数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果存在代理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== <span class=\"string\">\"click\"</span>) ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从被代理元素冒泡到代理元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; cur !== <span class=\"keyword\">this</span>; cur = cur.parentNode || <span class=\"keyword\">this</span> ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//屏蔽disable元素的点击事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cur.disabled !== <span class=\"literal\">true</span> || event.type !== <span class=\"string\">\"click\"</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cur元素需要执行的回调对象列表</span></span><br><span class=\"line\">            matches = [];</span><br><span class=\"line\">            <span class=\"comment\">//获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; delegateCount; i++ ) &#123;</span><br><span class=\"line\">                handleObj = handlers[ i ];</span><br><span class=\"line\">                sel = handleObj.selector + <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">                <span class=\"comment\">//判断元素是否符合选择器,这里还进行了缓存防止重复判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( matches[ sel ] === <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">                    matches[ sel ] = handleObj.needsContext ?</span><br><span class=\"line\">                        jQuery( sel, <span class=\"keyword\">this</span> ).index( cur ) &gt;= <span class=\"number\">0</span> :</span><br><span class=\"line\">                        jQuery.find( sel, <span class=\"keyword\">this</span>, <span class=\"literal\">null</span>, [ cur ] ).length;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果符合,说明cur元素需要执行这个回调,加到列表中</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( matches[ sel ] ) &#123;</span><br><span class=\"line\">                    matches.push( handleObj );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( matches.length ) &#123;</span><br><span class=\"line\">                handlerQueue.push(&#123; <span class=\"attr\">elem</span>: cur, <span class=\"attr\">handlers</span>: matches &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>\n<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>\n<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>\n<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( delegateCount &lt; handlers.length ) &#123;</span><br><span class=\"line\">    handlerQueue.push(&#123; <span class=\"attr\">elem</span>: <span class=\"keyword\">this</span>, <span class=\"attr\">handlers</span>: handlers.slice( delegateCount ) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> handlerQueue;</span><br></pre></td></tr></table></figure>\n<p>对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>\n"}